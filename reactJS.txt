-----------------------Установка-----------------------
1. Установить Node.js
2. Установить npm
3. Выполнить npm install -g create-react-app
4. Перейти в папку с проектом и выполнить create-react-app app-name
5. Перейти в папку с только что созданным проектом (в нашем случае это папка app-name) и выполнить npm start

----Без create-react-app
1. npm init - создастся package.json
2. npm i -S react react-dom - установить эти 2 пакета в dependencies
3. npm i -D webpack webpack-cli webpack-dev-server - установить webpack
	webpack-dev-server - для использование live-reloading
4. npm i -D babel babel-core babel-loader babel-preset-env babel-preset-react html-webpack-plugin http-server - установить babel
	babel - собственно сам babel
	babel-core - API для Node.js
	babel-loader - позволяет транспайлить js, исползуя babel и webpack
	babel-preset-env - использует browserlist чтобы транспайлить только то что не поддерживается
	babel-preset-react - для транспайлинга JSX синтаксиса
	html-webpack-plugin - упрощает создание html-файлов для обслуживания бандлов webpack'а.
	http-server - простой http сервер.

----Папка src
	index.js - точка входа в наше приложение
	index.html - тут подключаем наш скомпиленый js-файл

package.json - какие пакеты мы устанавливаем
package-lock.json - какие версии каких зависимостей нужны

----webpack.config.js
const path = require("path");

module.exports = {
	entry: './src/index.js', //точка входа или исходный файл
	output: { //выход
		path: path.resolve(__dirname, "dist"), //в текущей папке проекта будет искать папку dist
		file: "bundle.js" //название выходного файла
	}
	mode: "development"
};

Можно поставить дев-сервер:
	npm -D webpack-dev-server webpack-cli

-----------------------BabelJS-----------------------
Вообще, импользуется для переработки JS синтаксиса одного стандарта в синтаксис другого, но, функция преобразования JSX (XML в js) в нем тоже есть.
Необходимо установить:
	1. Node.js
	2. npm
	3. Babel client
	4. BabelPreset react

------------------------Компоненты----------------------
Можно все компоненты создать в файле App.js или создать папку с компонентами, где для каждого из них, будет свой js-файл, а их уже импортировать в App.js
Компонент используется как класс, наследующий от класса Component, в котором есть метод render().
	Метод render() возвращает JSX код, который и будет преобразован babel'ом в html и показан на странице.
App.css - стили компонента
ReactDOM.render(JSXelem, DOMContainer, callback) - отрендерить JSX-код внутри container
Компоненты бывают:
Функциональными
	Представляют собой обычные функции
	fucntion Hello (props) { //Определили элемент. Props - объект, хранящий атрибуты и свойства элемента
		return <h1>Hello, {props.name}</h1>
	}

	const elem = <Hello name="Viktor" />; //Создаем компонент с атрибутом name. Названия компонентов всегда с заглавной буквы
	ReactDOM.render(elem, document.getElementById("root"));
Классовыми
	Представляют собой классы ES6
	class Hello extends React.Component {
		name: "Viktor",
		render() {
			return <h1>Hello, {this.name}!</h1>
		}
	}
	export default Hello
Эти два вида компонентов являются равноценными. Разница в удобстве написания.

React.createElement(tag, attrs, content) - создает и возвращает DOM элемент (замена JSX)
	tag - имя тега в виде строки или React компонент
	attrs - атрибуты, элемента. Их нельзя изменить внутри их компонентов. Наследуются.
		{id: "dog", petName: "Helga"}
	content - содержимое элемента. Текст в виде строки или список дочерних элементов
	
	Использование в определении компонента
		class Hello extends React.Component {
			render() {
				//Определим в качестве attr, объект в контексте вызова, в который будет записано, в дальнейшем, свойство petName
				return React.createElement("h1", this.props, "hello, my " + this.props.petName);
			}
		}

		ReactDOM.render(
			React.createElement(Hello, {id: "dog", petName: "Helga"}),
			document.getElementById("root");
		)

key - специальное свойство React. Когда элемент изменяется, React ищет key из текущего списка состояний элементов в предыущем спике.
	- Если key нет в текущем списке, то данный элемент будет уничтожен
	- Если key нет в предыдущем списке, но есть в текущем - будет создан
	- Во всех остальных случаях - элемент key будет уничтожен и воссоздан с новым состоянием
	- key похож на обычное свойство их props, но таковым не является
	- Компонент не может узнать про свой key

--------------------------Состояния---------------------------
this.state - приватное свойство, которое видно только внутри компонента.
При изменении state компонента, меняется View
class Clock extends React.Component {
	constructor(props) {
		super(props); //все конструкторы подклассов должны начинаться с этой строки
		this.state = { //Компонент получает this.state только после определения его в конструкторе
			currentTime: (new Date()).toLocaleString()
		}
	}

	clockLaunch() {
		this.setState(target, callback) //Специальный метод для смены состояния. target - какое свойство this.state будет меняться
	}
}

getInitialState() - метод, позволяющий получить изначальное состояние элемента

Свойства не меняются, а состояния меняются
Свойства наследуются, состояния - нет

Компоненты в виде функций - лучший способ определения компонентов, который содержат только метод render
	function Square(props) {
		return (
			<button
				className = "square"
				onClick = { () => {props.onClick();} }
			>
				{props.value}
			</button>
		);
	}


--------------------------JSX---------------------------
Препроцессор, добавляющий в js, синтаксис xml. React можно использовать и без него, но с ним проще.
Значение атрибута в кавычках представляет собой строку.
Значение атрибута в фигурных скобках представляет собой вложенное выражение JS
В фигурных скобках можно записать самовызывающуюся функцию, возвращающую значение.
Если render должен вернуть несколько элементов, то их нужно обернуть одним контейнером и вернуть его.
Комментарии также нужно заключать в фигурные скобки
	{//comment}
Имена тегов в нижнем регистре, а компоненты React с верхнего
-------Стилизация
Для использования встроенных стилей React, нужно использовать синтаксис CamelCase
	...
	var myStyle = {
		backgroundColor: "green",
		fontSize: 30
	}
	render() {
		return (
			<h1 style={myStyle}>Hello World!</h1>
		)
	}

--------------------------Рендеринг-----------------------
Элементы React, в отличие от элементов DOM, являются обычными объектами, легковесными для создания
Пакет ReactDOM - занимается созданием DOM иэ React-элементов. Он имеет методы render(), unmountComponentAtNode(), findDOMNode()
	render(component, DOMElem) - рендерит React-компонент в переданном контейнере и возвращает ссылку на сам компонент. Если компонент был ранне отображен, то выполнится его обновление. Если передан еще коллбэк, то он будет выполнен после визуализации контента
React-элементы неизменяемы. Единственный способ обновить интерфейс - создать новый и отрендерить вместо старого.

--------------------------События-----------------------
В React используются все стандартные js события
Пишутся в camel case.
	onclick => onClick
Полный список событий см в документации.
Обработчик, который будет обращаться к контексту компонента, на котором он сработал, нужно привязать к этому контексту заранее. Лучше всего это делать в конструкторе
	constructor(props) {
		super(props);
		this.handler = this.handler.bind(this);
	}
Но можно привязать и в рендере, а так же передать аргументы.
	render() {
		return (
			<button onClick={this.updateCount.bind(this, step)}>{this.props.title}</button>
		)
	}
Для обмена данными между компонентами, нужно создать 2 класса и использовать их в рендере 3го, "общего", класса.
В 3м классе данные будут храниться в this.state и передаваться, как свойтва, первым двум классам
	class Common extends React.Component {
		handler() {...}
		render() {
			return (
				<First prop1={this.handler} />
				<Second prop2={this.state.data} />
			);
		}
	}

	class First extends React.Component {
		render() {
			return(
				<div onClick={this.props.prop1}>...</div>
			);
		}
	}

	class Second extends React.Component {
		render() {
			return (
				<div style.fontSize={this.props.prop2}>...</div>
			);
		}
	}


----------------------------Списки и ключи--------------------------
При создании списка, нужно определять в каждом его элементе атрибут key
	<li key="...">...</li>
Атрибут key помогает React идентифицировать какой элемент изменен, добавлен или удален. Это актуально, если предполагается что список будет меняться


--------------------------Работа с формами--------------------------
React использует virtualDOM, который непрерывно синхронизируется с настоящим.
onChange - событие изменения элемента формы
onSubmit - событие отправки формы
Свойства у элементов форм меняются. Это:
	value
	checked
	selected
У тега select, в React, вместо атрибута selected, меняется свойство value у самого тега select. Значение этого свойства и будет считаться выбранным элементом. Если передать в value массив, это будет значить несколько выбранных элементов.

--------------------Масштабирование компонентов----------------------
defaultProps - объект со значениями свойств компонента, которые будут использоваться по умолчанию
	Добавляется вне класса
		class Button ... {
			...
		};
		Button.defaultProps = {prop: value};
---Валидация типов свойств
Это можно делать только в неминифицированной версии, т.к. в минифицированной все сообщения об ошибках удалены.
Объект propTypes - хранит типы свойств. Определяется, как и defaultProps, вне класса. Хранит пары в виде <propName>: type
	Button.propTypes = {
		title: React.PropTypes.string //свойство title может хранить толко string-значения. Иначе ошибка
	}
children - свойство, хранящее все дочерние элементы компонента
	class Content ... {
		render(
			return <div>
				{this.props.children} //дочерние элементы компонента
			</div>
		);
	}

	ReactDOM.render(
		return (
			<Content>
				<h1>Hello</h1>
				<p>React!</p>
			</Content>
		);
	)

Композиция - термин, обозначающий ситуацию, когда более специфичные компоненты, в своем рендре, исопльзуют более общие.


---------------------------------------JSX изнутри-------------------------------------------
Если не используется сборщик проекта и React подгружается в документе через <script>, то он уже находится в глобальной области видимости как объект React.
Если мы импортируем модуль (например MyComponent), содержащий несколько компонентов, то можно обратиться к компоненту через точку.
	<MyComponent.Button ... />
Начиная с 16 версии, компонент может возвращать массив элементов. Больше нет необходимости оборачивать несколько элементов в дополнительный div

--------------------------------Проверка типов с помощью PropTypes------------------------------
С версии 15.5 свойтсво React.PropTypes устарело. Вместо него используется библиотека prop-types

-----------------------------------------Ссылки ref и DOM---------------------------------------
Атрибут ref может быть применен к любому компоненту.
Он принимает функцию, которая будет вызвана в момент монтирования и демонтирования.
	В момент монтирования элемента, функция принимает в свой аргумент текущий элемент.
	В момент демонтирования, в качестве аргумента, в коллбек передается null.
	class CustomTextInput extends React.Component {
		constructor(props){
			super(props);
			this.focus = this.focus.bind(this);
		}

		focus() {
			this.textInput.focus();
		}

		render() {
			return (
				<div>
					<input
						type="text"
						ref={(input) => { this.textInput = input; }}
					/>
					<input
						type="button"
						value="Focus on the text input"
						onClick={this.focus}
					/>
				</div>
			);
		}
	}

Ссылки лучше использовать пореже. Существует несоклько случаев, в которых рекомендуется исполльзование ref-ссылок:
	- Управление фокусом, Выделением текста или воспроизведением мультимедиа
	- Переключение необходимой анимации
	- Интеграция со сторонними DOM-библиотеками
Создаются ссылки с помощью метода React.createRef().
Присваиваются элементам с помощью атрибута ref.
	class MyComponent extends React.Component {
		constructor(props) {
			super(props);
			this.myRef = React.createRef();
		}
		render() {
			return <div ref={this.myRef} />; //ref передается элементу в методе render
		}
	}

let node = this.myRef.current //после того как, через ref, передана ссылка, целевой узел можно получить по свойству current
Когда ref применился к обычному HTML

---------------------------------------React Router----------------------------------
1. Сначала нужно установить пакеты react-router и react-router-dom
2. В главном файле
	import { BrowserRouter as Router, Route, Link } from 'react-router-dom'
		BrowserRouter - сам роутер. Использует History API и следит за тем чтобы ui совпадал с написанным в адресной строке
		Route - отвечает за отображение, непосредственно, ui и следит за тем чтобы пути между компонентом и адресной строкой совпадали
		Link - "видоизмененная" ссылка для редиректа на нужную страницу

	import createBrowserHistory from 'history/createBrowserHistory'
		Дополнительный модуль 'history' устанавливается вместе с react-router. Нужен для того, чтоб js-приложение вело свою историю одинаково, независимо от той среды, в которой оно находится

3. const history = createBrowserHistory();

4. Каждая страница должна представлять собой компонент.
	const Home = () => {<div>Home</div>}
	const About = () => {<div>About</div>}
	const Contacts = () => {<div>Contacts</div>}

5. Создадим сам роутер. Это обычный react-компонент
	class Navigation extends React.Component {
		render() {
			return (
				<Router history={history}>
					<div>
						<ul>
							<li>
								<Link to="/"> 	//Атрибут to отвечает за то на какую страницу будет идти редирект.
									Home
								</Link>			//слеш означает что на страницу "home"
							</li>
							<li>
								<Link to="/about">About</Link>
							</li>
							<li>
								<Link to="/contacts">Contacts</Link>
							</li>
						</ul>

						<hr />

						<Route exact path="/" component={Home} /> //отвечает за рендер нужного компонента
																	//атрибут exact обязывает компонент рендериться ТОЛЬКО по указанному адресу
						<Route path="/about" component={About} />
						<Route path="/contacts" component={Contacts} />
					</div>
				</Router>
			)
		}
	}

	export default Navigation;




=======================================Advanced Guide===========================================
--------Accessbility---------
Это свод рекомендаций, соблюдая которые, можно построить сайт, понятный для использования любому пользователю. Есть различные списки таких рекомендаций: WCAG, WAI-ARIA. Семантика кода - один из основных компонентов доступности сайта.
Когда мы добавляем группу элементов, заключая их в <div> - это может нарушить семантику кода. В таких случаях лучше использовать React Fragment. Когда нет необходимости в props, можно использовать Fragment short syntax.
---Accessible forms
-Необходимо снабжать каждый элемент формы, объяснительным label (атрибут for).
В React атрибут for => htmlFor
-Необходимо уведомлять пользователей о важных ошибках. Делать это нужно так, чтоб суть ошибки была ясна всем пользователям. Рекомендации о том, как оформлять такие ошибки есть на W3C.
-Обеспечте работу вашего web-приложения только с клавиатуры
-Линия, выдуляющая элемент, который получил фокус должна меняться только на CSS.
-Необходимо реализовать ссылки-якоря, для быстрой навигации по странице
-Поскольку React непрерывно модифицирует страницу, во время выполнения, то фокус может теряться или устанавливаться не на нужный элемент. Для избежания этого, необходимо программно "поправлять" установку фокуса. Например, кнопка, получившая фокус и открывшая модальное окно, должна получать фокус и после закрытия модалки.


-----------------------------------Занятие 1----------------------------------------
Можно пдключить React по cdn.
react.production.min.js - для создания виртуальных DOM-узлов.
react-dom.production.min.js - для превращения виртуальных узлов в HTML-узлы
Babel-транспайлер browser.min.js - для транспайлига JSX-синтаксиса в html на лету
Чтобы babel мог транспайлить jsx из нашего скрипта, нужно тегу последнего задать атрибут type="text/babel"
Для того чтоб это все работало, без webpack, нужно в папке с проектом запустить команду npx http-server -c-1
	Это запустит сервер в текущей папке. 
	Аргумент -c-1 запрещает кешировать файлы

-----------------------------------Занятие 2----------------------------------------

----Жизненный цикл компонентов
Он проходит 4 фазы:
	Фаза инициализации - фаза, на которой определяются все обычные и default-свойства, так же и когда вызываеются методы getDefaultProps() и getInitialState().
		getDefaultProps() и getInitialState() - методы, которые использовались при создании классов, вместо defaultProps-объекта до ES6-синтаксиса:
			class Greeting extends React.Component { //with ES6
				...
			}
			Greeting.defaultProps = {
				...
			}

			var Greeting = createReactClass({ //without ES6
				getDefaultProps: function() {
					return {
						...
					}
				}
			});

		getDefaultProps() вызывается единожды, когда создан класс, и кешируется. Его результат является общим для всех экземпляров.
		getInitialState() так же вызывается один раз, прямо перед mounting-фазой. Возвращает объект, свойства которого будут присвоены this.state-объекту.

Есть 3 группы событий, которые можно использовать для взаимодействия компонентов
	1. Происходят при создании компонента (Mounting Events) - mounting-фаза происходит когда компонент вставляется в DOM
		Эта группа содержит 2 метода
			1.1. componentWillMount() //выполняется перед созданием элемента.
				Вызовы setState внутри него не приведут к ре-рендеру
			1.2. componentDidMount() //выполнится сразу после создания элемета
	2. Происходят при обновлении компонента (Update Events)
		Содержит 4 метода, которые вызываются когда компонент уже вставлен в DOM, т.е. не при первом render'е
			2.1. componentWillReceiveProps(nextProps) //выполнится когда компонент готов получить свойства от родителя-контейнера
			2.2. shouldComponentUpdate(nextProps, nextState) //позволяет предупредить React о том, должен ли компонент обновляться или нет. Должен вернуть true (да) или false (нет)
			2.3. componentWillUpdate(nextProps, nextState) //выполнится сразу перед обновлением (render) компонента
			2.4. componentDidUpdate(prevProps, prevState) //выполнится сразу после обновления компонента
				2.3 и 2.4 вызываются уже ПОСЛЕ изменения state. Если в них еще поменять state, то изменение state рекурсивно зациклится
	3. Происходят при удалении компонента
		Содержит 1 метод
			componentWillUnmount() //тут мы можем "почистить за собой" - удалить разные таймеры и прочие элементы, созданные данным компонентом
	Все события определяются как методы классов компонентов

Атрибуты, хранящие обработчики события, рекомендуется называть в формате on[Event]
Обработчики событий, принято называть handle[Event]

Тернарный оператор
class Item extends React.Component {
	render() {
		const {
			title,
			image,
			imageAlt,
			text,
		} = this.props;

		return (
			<div className-"news">
				<h2>{title}</h2>
				{
					image ? <img src={image} alt={imageAlt} /> : null //null или undefined React не рендерит.
				}
				<p>{text}</p>
			</div>
		);
	}
}

В return'е мы не можем использовать if-else, т.к. это конструкция, которая вычисляется. Тернарный оператор же, просто оставит только то, что соответсвует условию.

Когда меняется объект state - снова вызывается метод render

----SyntheticEvent
Это обертка вокруг стандартного браузерного event'а.
Имеет такой-же интерфейс.
Свойство nativeEvent - получить экземпляр нативного события браузера
С версии v0.14, в React, больше нельзя отменять сыбытья, возвратом false из обработчика. Для этого, необходимо явно использоватьe e.stopPropagation() или e.preventDefault().
SyntheticEvent имеет следующие свойства:
	boolean bubbles
	boolean cancelable
	DOMEventTarget currentTarget
	boolean defaultPrevented
	number eventPhase
	boolean isTrusted
	DOMEvent nativeEvent
	void preventDefault()
	boolean isDefaultPrevented()
	void stopPropagation()
	boolean isPropagationStopped()
	DOMEventTarget target
	number timeStamp
	string type

По соображениям производительности, все свойства SyntheticEvent-объекта, после выполнения обработчика события, будут приравнены к null. Таким образом, данные свойства не будут доступны в асинхронном коде (например в setTimeout)

Если все же необходимо получить доступ к event-свойствам в async-коде, то нужно предварительно вызвать в обработчике event.persist(). Этот метод удаляет SyntheticEvent из пула и позволяет обращаться к свойствам стандартного event'а.

По умолчанию, все обработчики срабатывают на фазе всплытия события. Чтобы зарегестрировать обработчик для срабатывания на фазе захвата, нужно добавить "Capture" к названию события.
	<button onClickCapture={this.handler}</button>

Перечень возможных SyntheticEvent
	См. Доку


------------Context--------------
ПОзволяет передавать данные, рассматриваемые как гллобальные, глубоко вниз по иерархии, без промежуточной передачи предкам целевого элемента.
Пример:
	const ThemeContext = React.createContext("light"); //создадим переменную, хранящую контекст. По умолчанию он будет иметь значение "light"

	class App extends React.Component {
		render() {
			return (
				<ThemeContext.Provider value="dark"> //provider используется для передачи контекста компоненту. Все дочерние элементы 										компонента, независимо от того, как глубоко они находятся, смогут читать 											  контекст. Текущее значение "dark". В value передаем значение для шаринга в 										  нашем контексте
					<Toolbar />
				</ThemeContext.Provider>
			);
		}
	}

	function Toolbar(props) {
		return (
			<div> //Нет необходимости передавать контекст промежуточному компоненту
				<ThemeButton />
			</div>
		);
	}

	class ThemeButton extends React.Component {

	}

----API----
const MyContext = React.createContext(defaultValue) - создает объект с контекстом. Когда рендерится объект, подписанный на Context, он читает значение context из ближайшего Provider'a, что выше по дереву.
	defaultValue - используется когда выше по дереву нет Provider. Если Provider'у передать значение undefined, то defaultValue, в этом случае, не будет читаться.
<MyContext.Provider value={/*some value*/}> - все дочерние компоненты Provider'a подписываются на контекст, указанный в value 
	(иначе, defaultValue). Все компоненты будут ре-рендерить изменения в их контексте. Provider не является субъектом shouldComponentUpdate, потому, компонент будет обновлен, даже если предок запретит обновление.
	При передаче объектов как value, могут возникнуть некоторые проблемы. Об этом ниже.
MyClass.contextType = MyContext - свойству contextType присваивается объект, созданный React.createContext(). 
	Его значение (свойство value) можно получить внутри класса, по this.context. Оно досупно на всех стадиях жизненного цикла.
	Таким образом можно подписываться ТОЛЬКО на один контекст. Для подписывания на множество контекстов, испольхыется другой подход, о котором ниже.

Consumer
	<MyContext.Consumer>
		(value) => {/*content for rendering, based on value prop*/}
	</MyContext.Consumer>
	Отличается от Provider тем, что свое содержимое рендерит как возвращенное функцией значение. Это позволяет менять контекст в функции.
	Данный метод требует описание контента для рендеринга, внутри функции.
	Аргумент value равен свойству value ближайшего Provider'a. 
	Если провайдера нет, то используется значение defaultValue, метода React.createContext();

Изменение контекста из грубины дерева:
	//Создадим контекст
	const MyContext = React.createContext({
		defaultValue: someData,
		contextToggler: () => {...}
	});

	//Далее (возможно и в другом файле), провайдер (консьюмер) получает не только дефолтное значение, но и функцию, которое его меняет.
	function MyClass(props) {
		return (
			<MyContext.Consumer>
				{ ({defaultValue, contextToggler}) => {
					<button
						onCLick={contextToggler}
						style={{backgroundColor: defaultValue.background}}
					>
						Change my color
					</button>
				} }
			</MyContext.Consumer>
		)
	}