-----------------------Установка-----------------------
1. Установить Node.js
2. Установить npm
3. Выполнить npm install -g create-react-app
4. Перейти в папку с проектом и выполнить create-react-app app-name
5. Перейти в папку с только что созданным проектом (в нашем случае это папка app-name) и выполнить npm start

-----------------------BabelJS-----------------------
Вообще, импользуется для переработки JS синтаксиса одного стандарта в синтаксис другого, но, функция преобразования JSX (XML в js) в нем тоже есть.
Необходимо установить:
	1. Node.js
	2. npm
	3. Babel client
	4. BabelPreset react

------------------------Компоненты----------------------
Можно все компоненты создать в файле App.js или создать папку с компонентами, где для каждого из них, будет свой js-файл, а их уже импортировать в App.js
Компонент используется как класс, наследующий от класса Component, в котором есть метод render().
	Метод render() возвращает JSX код, который и будет показан на странице.
App.css - стили компонента
ReactDOM.render(JSXelem, DOMContainer, callback) - отрендерить JSX-код внутри container
Компоненты бывают:
Функциональными
	Представляют собой обычные функции
	fucntion Hello (props) { //Определили элемент. Props - объект, хранящий атрибуты и свойства элемента
		return <h1>Hello, {props.name}</h1>
	}

	const elem = <Hello name="Viktor" />; //Создаем компонент с атрибутом name. Названия компонентов всегда с заглавной буквы
	ReactDOM.render(elem, document.getElementById("root"));
Классовыми
	Представляют собой классы ES6
	class Hello extends React.Component {
		name: "Viktor",
		render() {
			return <h1>Hello, {this.name}!</h1>
		}
	}
	export default Hello
Эти два вида компонентов являются равноценными. Разница в удобстве написания.

React.createElement(tag, attrs, content) - создает и возвращает DOM элемент (замена JSX)
	tag - имя тега в виде строки или React компонент
	attrs - атрибуты, элемента. Их нельзя изменить внутри их компонентов. Наследуются.
		{id: "dog", petName: "Helga"}
	content - содержимое элемента. Текст в виде строки или список дочерних элементов
	
	Использование в определении компонента
		class Hello extends React.Component {
			render() {
				//Определим в качестве attr, объект в контексте вызова, в который будет записано, в дальнейшем, свойство petName
				return React.createElement("h1", this.props, "hello, my " + this.props.petName);
			}
		}

		ReactDOM.render(
			React.createElement(Hello, {id: "dog", petName: "Helga"}),
			document.getElementById("root");
		)

key - специальное свойство React. Когда элемент изменяется, React ищет key из текущего списка состояний элементов в предыущем спике.
	- Если key нет в текущем списке, то данный элемент будет уничтожен
	- Если key нет в предыдущем списке, но есть в текущем - будет создан
	- Во всех остальных случаях - элемент key будет уничтожен и воссоздан с новым состоянием
	- key похож на обычное свойство их props, но таковым не является
	- Компонент не может узнать про свой key

--------------------------Состояния---------------------------
this.state - приватное свойство, которое видно только внутри компонента.
При изменении state компонента, меняется View
class Clock extends React.Component {
	constructor(props) {
		super(props); //все конструкторы подклассов должны начинаться с этой строки
		this.state = { //Компонент получает this.state только после определения его в конструкторе
			currentTime: (new Date()).toLocaleString()
		}
	}

	clockLaunch() {
		this.setState(target, callback) //Специальный метод для смены состояния. target - какое свойство this.state будет меняться
	}
}

getInitialState() - метод, позволяющий получить изначальное состояние элемента

Свойства не меняются, а состояния меняются
Свойства наследуются, состояния - нет

Компоненты в виде функций - лучший способ определения компонентов, который содержат только метод render
	function Square(props) {
		return (
			<button
				className = "square"
				onClick = { () => {props.onClick();} }
			>
				{props.value}
			</button>
		);
	}

-----------------Жизненный цикл компонентов-------------
Есть 3 группы событий, которые можно использовать для взаимодействия компонентов
	1. Происходят при создании компонента (Mounting Events)
		Эта группа содержит 2 метода
			1.1. componentWillMount() //выполняется перед созданием элемента
			1.2. componentDidMount() //выполнится сразу после создания элемета
	2. Происходят при обновлении компонента (Update Events)
		Содержит 4 метода
			2.1. willReceiveProps() //выполнится когда компонент готов получить свойства от родителя
			2.2. shouldComponentUpdate() //позволяет предупредить React о том, должен ли компонент обновляться или нет. Должен вернуть true (да) или false (нет)
			2.3. componentWillUpdate() //выполнится сразу перед обновлением компонента
			2.4. componentDidUpdate() //выполнится сразу после обновления компонента
	3. Происходят при удалении компонента
		Содержит 1 метод
			componentWillUnmount()
	Все события определяются как методы классов компонентов

Атрибуты, хранящие обработчики события, рекомендуется называть в формате on[Event]
Обработчики событий, принято называть handle[Event]

--------------------------JSX---------------------------
Препроцессор, добавляющий в js, синтаксис xml. React можно использовать и без него, но с ним проще.
Значение атрибута в кавычках представляет собой строку.
Значение атрибута в фигурных скобках представляет собой вложенное выражение JS
В фигурных скобках можно записать самовызывающуюся функцию, возвращающую значение.
Если render должен вернуть несколько элементов, то их нужно обернуть одним контейнером и вернуть его.
Комментарии также нужно заключать в фигурные скобки
	{//comment}
Имена тегов в нижнем регистре, а компоненты React с верхнего
-------Стилизация
Для использования встроенных стилей React, нужно использовать синтаксис CamelCase
	...
	var myStyle = {
		backgroundColor: "green",
		fontSize: 30
	}
	render() {
		return (
			<h1 style={myStyle}>Hello World!</h1>
		)
	}

--------------------------Рендеринг-----------------------
Элементы React, в отличие от элементов DOM, являются обычными объектами, легковесными для создания
Пакет ReactDOM - занимается созданием DOM иэ React-элементов. Он имеет методы render(), unmountComponentAtNode(), findDOMNode()
	render(component, DOMElem) - рендерит React-компонент в переданном контейнере и возвращает ссылку на сам компонент. Если компонент был ранне отображен, то выполнится его обновление. Если передан еще коллбэк, то он будет выполнен после визуализации контента
React-элементы неизменяемы. Единственный способ обновить интерфейс - создать новый и отрендерить вместо старого.

--------------------------События-----------------------
В React используются все стандартные js события
Пишутся в camel case.
	onclick => onClick
Полный список событий см в документации.
Обработчик, который будет обращаться к контексту компонента, на котором он сработал, нужно привязать к этому контексту заранее. Лучше всего это делать в конструкторе
	constructor(props) {
		super(props);
		this.handler = this.handler.bind(this);
	}
Для обмена данными между компонентами, нужно создать 2 класса и использовать их в рендере 3го, "общего", класса.
В 3м классе данные будут храниться в this.state и передаваться, как свойтва, первым двум классам
	class Common extends React.Component {
		handler() {...}
		render() {
			return (
				<First prop1={this.handler} />
				<Second prop2={this.state.data} />
			);
		}
	}

	class First extends React.Component {
		render() {
			return(
				<div onClick={this.props.prop1}>...</div>
			);
		}
	}

	class Second extends React.Component {
		render() {
			return (
				<div style.fontSize={this.props.prop2}>...</div>
			);
		}
	}


----------------------------Списки и ключи--------------------------
При создании списка, нужно определять в каждом его элементе атрибут key
	<li key="...">...</li>
Атрибут key помогает React идентифицировать какой элемент изменен, добавлен или удален. Это актуально, если предполагается что список будет меняться


--------------------------Работа с формами--------------------------
React использует virtualDOM, который непрерывно синхронизируется с настоящим.
onChange - событие изменения элемента формы
onSubmit - событие отправки формы
Свойства у элементов форм меняются. Это:
	value
	checked
	selected
У тега select, в React, вместо атрибута selected, меняется свойство value у самого тега select. Значение этого свойства и будет считаться выбранным элементом. Если передать в value массив, это будет значить несколько выбранных элементов.

--------------------Масштабирование компонентов----------------------
defaultProps - объект со значениями свойств компонента, которые будут использоваться по умолчанию
	Добавляется вне класса
		class Button ... {
			...
		};
		Button.defaultProps = {prop: value};
---Валидация типов свойств
Это можно делать только в неминифицированной версии, т.к. в минифицированной все сообщения об ошибках удалены.
Объект propTypes - хранит типы свойств. Определяется, как и defaultProps, вне класса. Хранит пары в виде <propName>: type
	Button.propTypes = {
		title: React.PropTypes.string //свойство title может хранить толко string-значения. Иначе ошибка
	}
children - свойство, хранящее все дочерние элементы компонента
	class Content ... {
		render(
			return <div>
				{this.props.children} //дочерние элементы компонента
			</div>
		);
	}

	ReactDOM.render(
		return (
			<Content>
				<h1>Hello</h1>
				<p>React!</p>
			</Content>
		);
	)

Композиция - термин, обозначающий ситуацию, когда более специфичные компоненты, в своем рендре, исопльзуют более общие.


---------------------------------------JSX изнутри-------------------------------------------
Если не используется сборщик проекта и React подгружается в документе через <script>, то он уже находится в глобальной области видимости как объект React.
Если мы импортируем модуль (например MyComponent), содержащий несколько компонентов, то можно обратиться к компоненту через точку.
	<MyComponent.Button ... />
Начиная с 16 версии, компонент может возвращать массив элементов. Больше нет необходимости оборачивать несколько элементов в дополнительный div

--------------------------------Проверка типов с помощью PropTypes------------------------------
С версии 15.5 свойтсво React.PropTypes устарело. Вместо него используется библиотека prop-types

-----------------------------------------Ссылки ref и DOM---------------------------------------
Атрибут ref может быть применен к любому компоненту.
Он принимает функцию, которая будет вызвана в момент монтирования и демонтирования.
	В момент монтирования элемента, функция принимает в свой аргумент текущий элемент.
	В момент демонтирования, в качестве аргумента, в коллбек передается null.
	class CustomTextInput extends React.Component {
		constructor(props){
			super(props);
			this.focus = this.focus.bind(this);
		}

		focus() {
			this.textInput.focus();
		}

		render() {
			return (
				<div>
					<input
						type="text"
						ref={(input) => { this.textInput = input; }}
					/>
					<input
						type="button"
						value="Focus on the text input"
						onClick={this.focus}
					/>
				</div>
			);
		}
	}

Ссылки лучше использовать пореже. Существует несоклько случаев, в которых рекомендуется исполльзование ref-ссылок:
	- Управление фокусом, Выделением текста или воспроизведением мультимедиа
	- Переключение необходимой анимации
	- Интеграция со сторонними DOM-библиотеками
Создаются ссылки с помощью метода React.createRef().
Присваиваются элементам с помощью атрибута ref.
	class MyComponent extends React.Component {
		constructor(props) {
			super(props);
			this.myRef = React.createRef();
		}
		render() {
			return <div ref={this.myRef} />; //ref передается элементу в методе render
		}
	}

let node = this.myRef.current //после того как, через ref, передана ссылка, целевой узел можно получить по свойству current
Когда ref применился к обычному HTML

ReactDOM.findDOMNode(component) - находит и возвращает, соответствующий компоненту, узел DOM
