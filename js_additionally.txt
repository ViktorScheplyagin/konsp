********************CSS for JS developer*********************
vmin - минимальное от vh или vw
vmax - максимальное
---------------Flexbox-----------------
Состоит из контейнера и дочерних элементов
Flexbox использует для компоновки 2 оси
	горизонтальная - главная
	вертикальная - вторичная
Поддержка браузерами
	IE 10.0, 11.0 - -ms-
	Остальные все браузеры полностью поддерживают
Контейнер:
	display: flex
	display: inline-flex - делает контейнер инлайновым
	Не является блочным контейнером.
	Для внутренних блоков не работают:
		float,
		clear,
		vertical-align
		column-свойства
		::first-line, ::last-line
	Все дочерние элементы выстраиваются вдоль главной оси, колонками, по высоте равными высоте контейнера
	Ширина блоков равна ширине содержимого.
	Строчные и блочные дочерние элементы (ДЭ) ведут себя одинаково.
	Если контейнер содержит текст или картинки без оберток
		Текст выравнивается по верхней границе контейнера
		Высота изображения становится равна высоте контейнера и оно деформируется
	Выравнивание элементов по горизонтали:
		justify-content:
			flex-start - по умолчанию. Элементы располагаются относительно начала главной оси
			flex-end - то же, что и flex-start, но выравнивание относительно конца главной оси
			center - выравнивание ДЭ по центру контейнера
			space-between - выравниваются по главной оси. Первый блок - в начале контейнера, последний - в конце. Все остальные ДЭ 			равномерно распределяются между ними
			space-around - выстраиваются по главной оси, а свободное место равномерно делится между ВСЕМИ ДЭ.
			inherit - получает значение от родителя.
		Не наследуется
		
	Выравнивание по вертикали:
		align-items:
			stretch - по умолчанию. ДЭ растягиваются, занимая все пространство по высоте
			flex-start - ДЭ выстраиваются по левому краю контейнера, относительно верхнего края контейнера
			flex-end - ...относительно нижнего края контейнера
			center - ДЭ выстраиваются по центру контейнера
			baseline - выстраиваются по базовой линии
		Не наследуется.
		Все элементы выстраиваются по вторичной оси

	Направление главной оси:
		flex-direction:
			row - по умолчанию. Слева направо
			row-reverse - справа налево
			column - сверху вниз
			column-reverse - снизу вверх
			Не наследуется	
		
	Многострочность:
		flex-wrap:
			nowrap - по умолчанию. Все ДЭ располагаются в одну линию, слева направо.
			wrap - если ДЭ не помещаются в один ряд, они переносятся, выстраиваясь слева направо
			wrap-reverse - ...справа налево
		Не наследуется

	Краткая запись flex-direction + flex-wrap:
		flex-flow: [flex-direction] [flex-wrap]

	Выравнивание строк:
		align-content:
			stretch - по умолчанию. Строки равномерно растягиваются, заполняя доступное пространство
			flex-start - строки выравниваются по левому краю, относительно верхнего края контейнера
			flex-end - ...относительно нижнего края контейнера
			center - по левому краю, посередине по вертикали
			space-between -  аналогично align-items
			space-around - аналогично align-items
		Выравнивает строки по вертикали
		Работает только при разрешенном переносе ДЭ и указанном направлении и высоте контейнера.

Дочерние элементы:
	Порядок отображения:
		order:
			число - порядковый номер ДЭ. По умолчанию, у всех стоит 0. Чтобы добавить ДЭ в начало строки, нужно установить значение 	равным -1, в конец строки - 1.
		Не наследуется

	Базовая ширина:
		flex-basis:
			auto - по умолчанию. ДЭ получает ширину, равную ширине его контента, если оная не задана явно.
			число - задается в px, % и др. единицах.
		Базовое значение ширины ДЭ, относительно которого будет происходить растяжение (flex-grow) или сужение (flex-shrink)

	Растяжение элемента:
		flex-grow:
			число - положительное целое или дробное число. По умолчаннию равно 0.
		Коэффициент увеличения ширины, относительно flex-basis.
		Не наследуется
	
	Сужение элемента:
		flex-shrink:
			число - положительное целое или дробное число. По умолчаннию равно 0.
		Не наследуется
		Работает только если задан flex-basis или width.

	Краткая запись flex-basis + flex-shrink + flex-grow:
		flex:
			[flex-grow] [flex-shrink] [flex-basis]
			auto - эквивалентно 1 1 auto
			none - эквивалентно 0 0 auto
		W3C рекомендует это использовать, т.к. такая запись корректно сбрасывает неуказанные свойства

	Выравнивание отдельных элементов:
		align-self:
			auto - по умолчанию. Использует значение align-items контейнера
			flex-start, flex-end, center, baseline, stretch - значения аналогичны align-items
		Не наследуется
		Переопределяет align-items

-----------------------CSS-grid--------------------------
Терминология
	Grid Container - единственный родитель всех grid-элементов. Определяется как display: grid
	Grid Items - прямые потомки grid container. Их содержмое не является уже grid-элементом
	Grid Line - линия стыка Grid Items вдоль всей сетки. Бывают вертикальные и горизонтальные
	Grid Track - ширина колонок/строк. Другими словами - пространство между 2мя соседними Grid Lines
	Grid Cell - одна ячейка сетки
	Grid Area - площадь, состояшая из любого числа (>1) прилегающих друг ко другу ячеек.

Свойства: https://css-tricks.com/snippets/css/complete-guide-grid/
Контейнер
	display:
		grid - устанавливает контекст grid-форматирования для ДЭ
		inline-grid - ..., придавая контейнеру свойства inline-элемента
	grid-template-columns:/
	grid-template-rows:
		<track-size> - перечистяются ширины вертикальных/горизонтальных грид-треков, разделенные пробелом
		<line-name> <track-size> - line-name в квадратных скобках пишется произвольное имя, которое присваивается линии, ограничивающей трек сначала (слева). Линия может иметь больше чем одно имя. Для этого, в этих же квадратных скобках, необходимо перечислить имена через пробел. ([row1-end row2-start])
		Значение auto - "расталкивает по обе стороны, все колонки, занимая получившееся доступное пространство"
		Если определение свойства имеет несколько одинаковых частей, можно использовать функцию repeat(times, value)
			grid-template-columns: repeat(3, [col-start] 20px);
		Если несколько линий разделяют одно имя, то в определении конкретной линии, мы можем сослаться на ее определение в контейнере и она получит необходимые значения. После ссылочного имени нужно указать порядковый номер линии, под которым она определена в контейнере.
			.item {
				grid-column-start: col-start 2;
			}
	grid-template-areas:
		Определяет грид-шаблон, ссылаясь на имена областей.
		<grid-area-name> - имя грид-области, определенное в свойстве ДЭ - grid-area
			Повторение имени означает охват контентом данных ячеек.
		. - означает пустую ячейку
		none - отсутствие определенной грид-области
		Пример:
		.item-a {
			grid-area: header;
		}
		.item-b {
			grid-area: main;
		}
		.item-c {
			grid-area: sidebar;
		}
		.item-d {
			grid-area: footer;
		}
		.container {
			grid-template-columns: 50px 50px 50px 50px; //сетка будет иметь 4 колонки по 50px
			grid-template-rows: auto; //Сетка займет все доступное пространство по высоте. Неумещающийся в 4-х колонках контент, будет переноситься на новосозданную строку. Высота сетки будет поровну разделяться между строками.
			grid-template-areas:
				"header header header header" //4 колонки займет область header
				"main main . sidebar" //2 колонки займет область main, одну колонку - пустая ячейка и одну колонку - sidebar. Поскольку колонки всего 4 и они были заняты header'ом, то будет создана новая строка.
				"footer footer footer footer" //И, 4 колонки в еще одной строке, займут 4 области footer
		}

	Можно использовать несколько точек подряд (...) для объявления одной пустой ячейки.
	При таком синтаксисе, именование грид-линий происходит автоматически. Например, если имя области foo, то starting row line и starting column line будут называться как foo-start. Аналогично, ending row line и ending column line будут называться foo-end.
	Грид-линии могут иметь множество имен сразу. Например, в примере выше, крайняя левая линия сетки, будет иметь имена header-start main-start и footer-start, крайняя прававя - header-end, sidebar-end, footer-end

	grid-template:
		Короткая запись grid-template-columns + grid-template-rows + grid-template-areas
		none - установить все 3 свойства и их значения по умолчанию
		Синтаксис:
			.container {
				grid-template:
					[row1-start] "header header header" 25px [row1-end] //первая строка с 3мя областями header, высотой в 25px
					[row2-start] "footer footer footer" 25px [row2-end] //вторая строка с 3мя областями footer
					/ auto 50px auto //обе строки разделены на 3 колонки, шириной auto 50px auto
			}
			Эквивалентно записи:
			.container {
				grid-template-rows: [row1-start] 25px [row1-end row2-start] 25px [row2-end];
				grid-template-columns: auto 50px auto;
				grid-template-areas:
					"header header header"
					"footer footer footer"
			}
		Поскольку grid-template не сбрасывает неявные grid-свойства (grid-auto-columns, grid-auto-rows, grid-auto-flow), что вы, вероятно, захотите сделать в большинстве случаев, рекомендуется использовать grid вместо grid-template.

	grid-column-gap
	grid-row-gap
	grid-gap

	justify-items
	align-items
	place-items

	justify-content
	align-content
	place-content

	grid-auto-columns
	grid-auto-rows
	grid-auto-flow
	grid

Grid-элемент
	grid-column-start
	grid-column-end

	grid-row-start
	grid-row-end

	grid-column
	grid-row
	grid-area

	justify-self
	align-self
	place-self

Новая grid-единица измерения fr - равна величине доступного свободного пространства, умноженной на количество fr-единиц.
	width: 1fr //(free-space) * 1
	width: 0.5fr //(free-space) * 0.5
	
	Если указано несколько значений, то доступное пространство делится на их сумму и результат деления, помноженный на количество указанных fr-единиц присваивается конкредному грид-треку
		grid-template-columns: 1fr 0.5fr 1fr
			Будет вычислено примерно так:
				1) unit = free-space / (1 + 0.5 + 1);
				2) первый трек = unit * 1
				   второй трек = unit * 0.5
				   третий трек = unit * 1
		grid-template-columns: 1fr 50px 0.5fr 1fr
			1) free-space -= 50px
			2) unit = (free-space) / (1 + 0.5 + 1)
		Коэффициент уменьшения ширины, относительно free-space
*************************JS Patterns*************************
---------------Паттерн "Модуль"--------------
Суть состоит в написании самовызывающейся функции, которая возвращает объект
var BasketModule = (function () {
	var sum = 0; //тут хранятся приватные свойства. Это область замыкания методов возвращаемого объекта
	var goods = [];

	return {
		addProduct: function (product) {
			sum += product.price;
			goods.push(product);
		},

		printProducts: function () {
			for (var i = 0; i < goods.length; i++) {
				console.log(goods[i].name, goods[i].price);
			}
		}
	}
})();

//Для примера,создадим продукт
var salt = {
	name: "Salt",
	price: "20"
};

//Модуль корзины в действии
BasketModule.addProduct(salt);
BasketModule.printProducts();


---------------Паттерн "Синглтон"--------------
Паттерн, когда конструктор создает всегда один и тот же экземпляр класса и работа ведется уже с ним.
Похож на "Модуль". Все потому что для реализации сабжа, используем замыкание
var Singleton = (function () {
	var instance; //Переменная, которая будет хранить единственно возвращаемый экземпляр

	function Singleton() {
		if(instance) {
			instance = this;
		} else {
			return instance;
		}
	}

	return Singleton; //Возвращаем конструктор
});