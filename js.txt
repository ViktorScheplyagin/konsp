*************************************************Часть 1**********************************************************

-------------------------Введение--------------------------------
Спецификафия языка называется ECMAScript
babejs - транслятор, который транслирует JS-код, в код более старого стандарта

----Справочники и спецификации
	Mozilla Developer Network - https://developer.mozilla.org/
	MSDN - http://msdn.microsoft.com/ //полезна при разработке под IE
	Safari Developer Library - https://developer.apple.com/library/safari/navigation/index.html
	https://kangax.github.io/compat-table – таблица с обзором поддержки спецификации ECMAScript различными платформами.
	ECMAScript спецификация - http://www.ecma-international.org/publications/standards/Ecma-262.htm


----------------------Основы JavaScript---------------------------
Скрипты можно вставить в любое место html с помощью тега <script>
<meta charset="utf-8"> - тег, для корректного отображения текста в браузере

Современная разметка для <script>
	Атрибут type="text/javascript" - был обязателен в HTML4
	Атрибут language=... - по умолчанию язык - JavaScript

----Подключенные скрипты. Порядок исполнения
Браузер скачает скрипт только первый раз, а затем закеширует его
По умолчанию браузер сначала должен выполнить скрипт, а затем продолжить отображать страницу - такое поведение называется "синхронным"
	<script src="..." async> - скрипт будет загружаться, параллельно с отображением страницы. Когда скрипт будет загружен, он выполнится. Имеет приоритет перед defer. IE9 не поддерживается.
	<script src="..." defer> - То же самое, что и async, но относительный порядок скриптов будет сохранен и скрипт сработает только когда весь документ будет обработан браузером

В имени переменной не долдно быть дефиса
Имя переменной, состоящее из нескольких слов, пишетсяВотТак.
Лучше хранить в переменной что-то одно, а для нового значения объявить новую

----Операторы
typeof x - оператор вернет тип переменной "x"
'1' + 1 = строка '11'. Остальные арифметические операторы всегда приводят операнды к числу
Унарный плюс приведет операнд к числу: +'1' = число 1
Оператор присваивания, еще и возвращает (подобно функции) то значение, которое присвоил переменной
	с = 3 - (а = 2 + 3); //в "с" запишется -2, а в "а" 5
	alert(a);
Оператор "заптая" - a = (5 + 3, 3 * 6). Каждое выражение вычисляется и отбрасывается, а последнее возращается

----Сравнение
Для корректного сравнения строк, они должны быть в одинаковом регистре
При сравнении значений разных типов, применяется ЧИСЛОВОЕ преобразование.
null и undefined равны друд другу и не равны больше ничему
Числовые преобразования:
	null -> 0
	undefined -> NaN

----Логические операторы
Несколько ИЛИ слева направо. При первом true, вся дальнейшая часть конструкции опускается. Возвращается то значение, на котором остановилось вычисление, не преобразованное к логическому типу.
Аналогично с логическим И, только он запинается на ЛЖИ
У логического И приоритет выше чем у ИЛИ, но Короткий Цикл вычислений все равно начинается с слева направо.
	alert( null || 2 && 3 || 4 ); // 3
		то же что и alert( null || (2 && 3) || 4 ), т.е. сначала проверится null, потом проверится 2 && 3 (а не только 2)

----Преобразование типов
строковое преобразование:
	alert() преобразовывает к строке
	String(val) - преобразование явным образом
	Так же оператор "+", у которого один из аргументов строка, преобразует и второй к строке
Численное преобразование:
	При сравнении данных различных типов (кроме операторов строгого стравнения)
	Number(val) - явное преобразование
	Преобразование унарным плюсом
	Численное преобразование типов: //undefined и null при сравнении "==", не приводятся к NaN и 0, а считаются равными
		+undefined //NaN
		+null //0
			null >= 0 //true
			null > 0 и null < 0 //false
		*Для избежания путанницы, лучше не давать специальным значениям учавствовать в сранении*
		+true //1
		+false //0
		+"string" //Пробельные символы по краям обрезаются. Если остается пустая строка, то получаем 0, если не пустая, то из нее считывается число. При ошибке получаем NaN
Логическое преобразование:
	!!value или Boolean(value) - явное логическое преобразование
	Преобразование типов:
		0, '', undefined, NaN, null -> false
		Все остальное, в т.ч. объекты -> true
if выполняет логическое преобразование

----Метки break/continue
break метка / continue метка - выйти из цикла. Ставится перед циклом, из которого необходимо выйти
	outer: //метка
	for(var i=0; i<100; i++){
		for(var j=0; j<100; j++){
			if(j = 98) break outer;
		}
	}
	alert('End of cycle');
	В данном коде произойдет выход из внешнего цикла (перед которым стоит метка) и управление передастся alert(). В случае с continue, вместо выхода, произойдет переход на следующую итерацию внешнего цикла.

----Конструкция switch
Если в кейсе нету брейка, то продолжится выполнение всех нижестоящих кейсов, без проверки условий.
Оператор switch делает строгую проверку (===).

----Функции
Если внутри функции объявить переменную (var) с таким же именем, как у внешней переменной, то внутрянняя переопределит внутри внешнюю переменную
Function Declaration создаются интерпретатором до выполнения кода
В режиме use strict Function Declaration видны только внутри блока кода, в котором объявлены
Еще один способ создания функций. Используется очень редко:
	var sum = new Function('a, b', 'return a+b') //1ый аргумент - параметры, 2й - тело
Значение, на котором заканчивается рекурсия, называют "базисом рекурсии".
Контекст функции - это служебная информация, которая включает в себя локальные переменные и место в цепочке команд, на котором произошел вызов функции.
При вложенных вызовах, контексты хранятся в специальной внутренней структуре данных - стеке контекстов. Для вложенной функции создается новый контекст, а контекст внешней записывается в стек. Когда выполнение вложенной функции завершено, ее контекст удаляется, из стека достается контекст внешней функции и ее выполнение возобновляется.
Именованные функциональные выражения (NFE):
	var f = function sayHi(...){ //имя sayHi доступно только ВНУТРИ самой функции.
		sayHi = 'text' //ошибка. Перезаписать это имя невозможно
	}
	Данное имя используется только для рекурсии
	Если Function Declaration обрамить в круглые скобки, то оно превратится в NFE
		var func = (function f(){...});




------------------------Качество кода------------------------------
----Отладка
debugger; - команда, заставившая отладчик остановиться на ней, как на брейкпойнте

----Советы по стилю кода
Между параметрами пробел
Пробел перед открывающей фигурной скобкой
Пробел после for
Пробелы вокруг операторов
Пустая строка между логическими блоками
else без перевода строки
Пробелы вокруг вложенного вызова функции
Одна функция = одно действие
В начале сложного скрипта архитектурный коментарий (или справочный перед функцией) в формате JSDoc


------------Автоматические тесты при помощи chai и mocha------------
BDD (Behavion Driven Development) = тесты + документация + примеры использования
Разработка функции pow(x, n):
	Сначала пишем спецификацию
		describe("pow", function() {
			it("Возводит в n-ю степень", function() {
				assert.equal(pow(2, 3), 8);
			});
		});

		describe(название, function() { ... }) - задает что именно мы описываем. Используется для группировки "рабочих лошадок" - блоков it.
		it(название, function() { ... }) - в названии человеческим языком описывается что должна делать функция, далее следует тест, который проверяет это.
		Код внутри it, если реализация верна, должен выполняться без ошибок.
		assert.equal(value1, value2) - сравнивает два значения.
	Поток разработки:
		1. Пишется спецификация, описывающая базовый функционал
		2. Делается начальная реализация
		3. Для проверки соответсвия спецификации используем фреймворк (в нашем случае Mocha) который запускает тесты it и выводит ошибки. При ошибках вносятся исправления
		4. Спецификафия расширяется, в нее добавляются возможности, которые, возможно, не поддерживаются реализацией.
		5. Идем в пункт 2 и расширяем реализацию. И так до конца.
	Mocha - содержит общие функции для тестирования, включая describe и it.
	Chai - содержит разнообразные функции для проверок (assert.equal())
	Sinon - для эмуляции и подмены функций "заглушками".

Запуск тестов инициируется командой mocha.run();
Результат тестирования будет выводиться в элемент <div id="mocha"></div>
Если в одном it несколько assert-ов и если один из них обнаружит ошибку, то он сразу же завершает выполнение блока it
Можно создавать отдельные подгруппы тестов, с помощью вложенных describe блоков
before(functions) / after(functions) - можно внутри describe создать блоки функций, которые будут выполнены, соответственно до и после it тестов
beforeEach(functions) / afterEach(functions) - аналогично предыдущим, но функции будут выполнены после каждого it теста
assert(выражение) - выдает ошибку, если выражение, при приведении к логическому типу, не true
assert.strictEqual(value1, value2) - проверка строгого равенства
assert.notEqual(value1, value2), assert.notStrictEqual(value1, value2) - проверка неравенства и строгого неравенства соответственно
assert.isTrue(value) - если value === t
assert.isFalse(value) - если value === false
assert.isNaN(value) - true если value === NaN



------------------------Структуры Данных----------------------------
string.length - длина строки
str.toUpperCase() - возвращает строку в верхнем регистре

----Числа
Можно записывать числа в 16-ричной системе счисления, предварив число "0х"
num.toString(система счисления) - получить число в 16-чной системе, в виде строки. Основание системы может быть от 2 до 36
<number>e<quantity of zeroes> - "научный" формат записи числа
isNaN(num) - true, если num === NaN
isFinite(num) - true, если num не равно NaN/+-Infinity
parseInt(num)/parseFloat(num) - посимвольное преобразование строки в целые/дробные числа, пока это возможно. В случае ошибки, возвращается то, что получилось, иначе сразу NaN
Math.floor(num) - округляет вниз
Math.ceil(num) - округляет вверх
Math.round(num) - до ближайшего целого
~~num - двойное побитовое НЕ, обрезает дробную часть, делая число целым
	~~12.3 == 12
Подойдет так же ИСКЛЮЧАЮЩЕЕ ИЛИ с нулем
	12.3 ^ 0 == 12
num.toFixed(precission) - округляет num до точности precission. Возвращает результат в виде строки
num.toLoacleString() - форматированный вывод числа

----Строки
\uNNNN - символ в кодировке юникод, представленный кодом NNNN
str.indexOf(substr[, start_position]) - возвращает позицию искомой подстроки или -1
	if(~str.indexOf(...)) - оператор '~' эквивалентен -(n + 1). Т.е. ? если подстрока не найдена и возвращен -1, он автоматически превращается в 0 (-(-1 + 1)), что интерпретируется if'ом как false
Взятие подстроки:
	str.substring(start [, end]) - возвращиет подстроку со start по end (не включительно). Если end нету, то идет до конца строки. Отрицательные аргументы интерпретируются как равные 0. Слишком большие усекаются до длины строки. Если start > end, то аргументы меняются местами
	str.substr(start, [, length]) - аналогичен предыдущему, только lenght обозначает количество возвращаемых сиволов
	str.slice(start [, end]) - аналогичен substring(). При отрицательных аргументах отсчет идет с конца строки. Если end > start, возвращается пустая строка.
String.fromCharCode(code) - получить символ, по его коду Unicode
str.charCodeAt(pos) - возвращает код символа на позиции pos
str.localeCompare(str2) - корректное сравнение строк разных языков

----Объекты
Создание объекта:
	o = new Object(); или o = {};
Удалить свойство:
	delete obj.property;
Проверка на существование свойства:
	if("propertyName" in object_name)
object_name["property"] - доступ к свойству объекта через квадратные скобки
Объекты могут быть вложенными
Перебор свойств:
	for(var key in obj){ //если key числовая строка, то такие свойства, при переборе, сортируются как числа.
		console.log(obj[key]) //доступ через квадратные скобки
	}

----Массивы
Удаление/Добавление элементов:
	arr.pop() - удаляет последний элемент из масива
	arr.push(elem) - добавляет элемент в конец массива. Возвращает добавленный элемент
	arr.shift() - удаляет первый элемент массива
	arr.unshift(elem) - добавляет элемент в начало массива
	Можно так же удалять элемент оператором delete
	arr.length = 0 - очистить массив
	arr.splice(index [, deleteCount, elem1, ..., elemnN]) - удалить deleteCount элементов, начиная с номера index, а затем вставить на их место elem1, ..., elemN. Возвращает массив из удаленных элементов.
		Если index < 0 - отсчет с конца строки
		Если deleteCount < 0, или другое недопустимое значение - считается равным 0
	arr.concat(value1, ... valueN) - присоединяет к концу массива переданные элементы. Можно так же передать массив. Возвращает результат, не изменяя arr.
Взятие подмассивов:
	str.split(s [, qty]) - разбивает строку по разделителю s на массив. qty - ограничение на количество элементов вмассиве. Возвразает результат.
	arr.join(str) - создает из массива строку, разделяя элементы str. Возвращает результат.
	Если номер отрицательный, то отсчет начинается с конца
	all.slice(start, end) - копирует участок массива, со start по end (не включительно). Если end не указан, то копирование будет до конца массива. Отрицательные индексы - отсчет с конца. Вообще без аргументов - скопируется весь массив
Сортировка:
	arr.sort(fn) - сортировка элементов массива. По умолчанию сортирует, преобразовывая элементы к строке.
		fn - функция, принимающая 2 аргумента - сравниваемые элементы. Если функция возвращает положительное значение, то элементы меняются местами.
	arr.reverse() - меняет порядок элементов на обратный
arr.indexOf(elem [, fromIndex]) - возвращает индекс элемента elem или -1, начиная поиск с позиции fromIndex. Для поиска используется строгое стравнение
arr.lastIndexOf(elem [, fromIndex]) - аналогично предыдущему, только начинает поиск с конца.
Object.keys(obj) - возвращает массив ключей объекта
Перебирающие методы:
	arr.forEach(callback, context) - для каждого элемента вызывается функция callback(item, i, arr)
		item - текущий элемент массива
		i - его индекс
		arr - массив, который перебирается
	arr.filter(callback) - создает новый массив с теми элементами, для которых callback(item, i, arr) вернет true
	arr.map(callback) - создает новый массив, с возвращенными результатами callback(item, i, arr), после работы с каждым элементом
	arr.every(callback) - возвращает true, если callback(item, i, arr) вернул true для каждого элемента в массиве
	arr.some(callback) - возвращает true, если callback(item, i, arr) вернул true хотябы для одного элемента в массиве
	arr.reduce(callback [, initialValue]) - применяет callback(previousValue, currentItem, index, arr) к каждому элементу массива, сохраняя промежуточный результат вычислений
		previousValue - последний результат работы метода. Он же "промежуточный результат"
		currentItem - текущий элемента массива, элементы перебираются по очереди, слева направо
		index - номер текущего элемента
		arr - массив который перебираются
		initialValue - начальное значение промежуточного результата. Если этот аргумент не передан, то оно равно первому элементу массива, а перебор осуществляется со второго
	arr.reduceRight() - все аналогично arr.reduce(), но перебор справаналево
Псевдомассив arguments - объект с числовыми ключами и имеющий свойство length. Его значения отвязаны от параметров и не влюяют друг на друга.
Когда очень много параметров, можно в качестве аргумента, передать в функцию объект, свойства которого будут хранить необходимые значения

----Дата и время
Создание даты:
	new Date() - создать объект Date, с текущей датой и временем
	new Date(milliseconds) - создает объект в котором milliseconds миллисекунд, которые считаются прошедшими с 01.01.1970
	new Date(datestring) - Если единственный аргумент - строка, то надо использовать Date.parse для чтения даты из нее
	new Date(year, month, date, hours, minutes, seconds, ms) -  создать дату
		первые 2 аргумента обязательны
		year должен состоять из 4х цифр
		отсутствующие параметры, начиная с hours, считаются равными 0, а date единице
		Номер месяца начинается с 0
		Номер дня в месяце начинается с единицы
Получение компонентов даты:
	getFullYear() - получить год (из 4 цифр)
	getMonth() - получить месяц (от 0 до 11)
	getDate() - получить число дня месяца (от 1 до 31)
	getHours(), getMinutes(), getSeconds(), getMilliseconds() - получить соответствующие компоненты
	getDay() - получить номер дня недели, начиная с воскресения (от 0 до 6)
	getTime() - возвращает количество миллисекунд с 01.01.1970
	getTimezoneOffset() - возвращает разницу между текущей и UTC зонами в минутах
	Все методы возвращают значения для местной временной зоны
	В UTC вариантах все то же самое, только в названиях методов, после "get" ставится "UTC" (getUTCMonth())
Установка компонетов даты:
	setFullYear(year [, month, date])
	setMonth(month [, date])
	setDate(date)
	setHours(hours [, min, sec, ms])
	setMinutes(min [, sec, ms])
	setSeconds(sec [, ms])
	setMilliseconds(ms)
	setTime(ms) - устанавливает всю дату по миллисекундам
	Все методу, кроме setTime() обладают UTC вариантом
	Date автоматически исправляет дату. 32 марта станет 1 апреля. Можно просто прибавлять количество дней к текущему значению
Date в числовом контексте преобразуется в количество миллисекунд. Эти значения можно подвергать арифметическим операциям
Бенчмаркинг:
	performance.now() - возаратит время от момента выгрузки предыдущей страницы из памяти, до места в коде, где этот метод вызван
	console.time(метка) - включить внутренний хронометр браузера. Метка предназначена для идентификации замера
	console.timeEnd(метка) - выключить внутренний хронометр браузера и вывести результат
Форматированный вывод дат:
	toString(), toTimeString(), toDateString() - возвращает стандартное строчное представление, зависящее от браузера. Имеют UTC аналоги
	date.toLocaleString(locale, {options}) - возможны другие варианты использования. Показано использование только для форматированного вывода даты.
		locale = "ru";
		options = {
			weekday: "narrow"/"short"/"long",
			era: "narrow"/"short"/"long",
			year: "numeric"/"2-digit",
			month: "numeric"/"2-digit",
			day: "numeric"/"2-digit",
			hour: "numeric"/"2-digit",
			minute: "numeric"/"2-digit",
			second: "numeric"/"2-digit",
			timeZoneName: "short"/"long"
		}
Разбор строки, Date.parse:
	Формат ISO 8601 Extended: YYYY-MM-DDTHH:mm:ss:sssZ:
		YYYY - год
		MM - месяц
		T - обычный символ. Используется как разделитель
		HH:ss:sss - часы, секунды, миллисекунды соответственно
		Z - временная зона в формате +-hh:mm
	Date.parse(str) - разбирает строку в вышеуказанном формате и возвращает количество мс. Иначе возвращает NaN
Date.now() - вернет текущую дату в миллисекундах
----[[Scope]] для new Function
При создании функции через new Function, ее внутреннее свойство [[Scope]] будет указывать всегда на window, а значит такие функции не могут использовать замыкание
Минификатор переименовывает все локальные переменные на более которкие имена



------------------------Замыкания, область видимости----------------------------
----Глобальный объект
Все глобальные функции и переменные являются свойствами глобального объекта window
Во время инициализации скрипта, функции, объявленные как Function Declaration, создаются сразу работающими, а var-переменные = undefined
Тела конструкций (и блоки инициализации счечиков в циклах) if, while, for, switch и т.п. не влияют на область видимости.
----Замыкания функции
Замыкание - это все внешние переменные, которые доступны функции.
Все переменные внутри функции = это свойства специального внутреннего объекта LexicalEnvironment, который создается при ее запуске.
После выполнения функции, LexicalEnvironment удаляется из памяти.
При обращении к переменной, остутствующей в текущем LexicalEnvironment, интерпритатор ищет ее объявление во внешнем окружении.
В каждом окружении есть свойство-ссылка [[Scope]], которое ссылается на родительское окружение.
[[Scope]] закрыто от прямого доступа.
[[Scope]] никогда не меняется, всюду храня ссылку на окружение в котором она была создана
Функции в JavaScript являются объектом, поэтому можно создавать свойства и у них
	f.test = 5;
	Это свойство так же будет привязано к функции. Отличие от переменной внешнего окружения лишь в том. что свойство можно изменить из внешнего кода, где доступен объект функции:
		f();
		f.test = 7;
----[[Scope]] для new Function
Функции, создаваемые через new Function, имеют значением [[Scope]] не внешний объект переменных, а window
Следствие – такие функции не могут использовать замыкание. Но это хорошо, так как бережёт от ошибок проектирования, да и при сжатии JavaScript проблем не будет. Если же внешние переменные реально нужны – их можно передать в качестве параметров.
----Модули через замыкания
Модуль - подключаемый в html-странице скрипт, в котором весь код заключен в одну функцию.
Сделано так для того, чтобы изолировать его содержимое от "внешнего мира" и избежать конфликта имен
(function() {
	...code...
})() - с помощью FE создается функция и сразу вызывается
Во вне, значения экспортируются двумя способами:
	1) return <var_name>;
	2) window.<var_name> = <value>;
----Управление памятью в JavaScript
Удаление неиспользуемых объектов происходит сборщиком мусора
Критерий выбора объекта для удаления основывается на условии недостижимости кода - когда нет ни одной ссылки на объект
----Устаревшая конструкция with
with(obj) {
	...code...
} - внутри блока в качестве области видимости используется объект obj. Не создает собственной области видимости
Интерпритатор сначала ищет область видимости внутри блока и только потом поиск продолжает во вне
С use strict не работает
Отказались от данной конструкции потому что минификаторы плохо ее обрабатывают и она делает выполнение кода более ресурсоемким
Вместо данной конструкции лучше использовать временную переменную
	var s = elem.style;
	s.top = "10px";
	s.left = "0";


-----------------------------Методы объектов и контекст вызова-----------------------------------
----Методы объектов, this
Для доступа к данным текущего объекта, используется ключевое слово this хранящее ссылку на него
Значение this называется контекстом вызова
Значение this определяется во время выполнения кода
	function f() {
		alert(this.name);
	}
	var one = {name: "Vasya"};
	var two = {name: "Petya"};
	one.f = f; //Значени this будет разным
	two.g = f;
	one.f(); //"Vasya"
	two.g(); //"Petya"
Чтобы контекст передался, нужно вызвать функцию через точку.
Если код функции возвращается каким-либо другим оператором, кроме точки, то контекст изначального объекта теряется.
Возвращать ссылку this на объект может только его собственный МЕТОД. Если попытаться обратиться к СВОЙСТВУ, хранящему this, то контекст теряется
Функция получает контекст только родительского объекта. Иными словами, this внутри функции ссылается только на родительский объект
Объект получает контекст самого первого предка (в браузере это window). Другими словами this в объекте на любом уровне вложенности равен window
Если объявить переменную, внутри функции, через var, то она станет свойством LexicalEnvironment, который удаляется после выполнения функции.
Если же переменную объявить как свойство самой функции (как объкта), то ее значение будет закреплено за ней.

----Преобразование объектов: toString(), valueOf()
Объект преобразовывается в примитив:
	Строковое преобразование - если объект выводится через alert(obj);
		Стандартное представление пользовательского объекта в виде строки "[object Object]"
		Если в объекте присутствует метод toString, то он используется для преобразования
			var obj = {
				name: "Vasya",
				toString: function() {
					return "User " + this.name;
				}
			}
			alert(obj); // "User Vasya"
			Большинство объектов имеют внутреннюю реализацию toString
	Численное преобразование - при арифметических операциях, сравнении с примитивом;
		Для численного преобразования объекта используется метод valueOf, а если его нет, то toString
		У большинства объектов нет valueOf
		Проверка равенства между объектом и примитивом вызывает численное преобразование объекта
	Логическое преобразование - при if(obj) и других логических операциях
		Любой объект в логическом преобразовании true, даже пустой массив [] или объект {}
	Методы toString и valueOf обязаны возвращать примитивный тип, иначе они будут проигнорированы
У объектов Date, метод valueOf возвращает количество миллисекунд, а toString строку с датой. Однако оператор "+" использует у них метод toString, хотя должен valueOf.
Если фигурные скобки {} идут не в выражении, то они считаются блоком кода

----Создание объектов через new
При создании объекта через new, вызывается функция-конструктор.
	function Animal(arg) { //конструкторы принято называть с большой буквы
		this.a = arg;
		this.b = arg + 2;
	}
	var tiger = new Animal(1);

	this получает ссылку на создаваемый объект
	создаются свойства и методы
	возвращается this
Если в конструкторе есть return
	При вызове return с объектом, будет возвращён он, а не this.
	При вызове return с примитивным значением, оно будет отброшено.
В конструкторе можно объявлять локальные переменные и вспомогательные функции. В объект попадет только то, что определяется через this

----Дескрипторы, геттеры и сеттеры свойств
Основной метод для управления свойствами – Object.defineProperty.
	Object.defineProperty(obj, "prop", descriptor)
		obj - имя объекта
		"prop" - имя свойсвта в двойных кавычках
		descriptor - объект имеющий следующие свойства
			value - значение свойства. По умолчанию undefined
			writable - можно ли менять значение свойтсва. По умолчанию false
			configurable - можно ли удалять свойтсва (при помощи оператора delete) или изменять при помощи новых вызовов defineProerty. По умолчанию false
			enumerable - будет ли перечисляться свойство циклом for..in и войдет ли в массив, возвращаемый Object.keys(). По умолчанию false
			get - функция, которая возвращает значение свойства. По умолчанию undefined
				Object.defineProerty(o, "value", {
					get: function() { //можно объявить как свойство дескриптора
						return "Hello";
					}
				}); // Теперь при обращении o.value, при чем без скобок, будет вызываться код функции get()
			set - функции, для установки значения свойства. По умолчанию undefined
					set: function(val) {
						this.value = val;
					}
				}); //Работа функции set
	Запрещено одновременно указывать value или writable совместно с get/set
Можно так же создать get/set прямо в определении объекта
	var o = {
		name: "Vasya",
		surname: "Pupkin",
		
		get fullName() { //или объявить в самом объекте, прописав соответствующее ключевое слово, вместо function
			return this.name + " " + this.surname;
		}
		set fullName(value) {
			var split = value.split(" ");
			this.name = split[0];
			this.surname = split[1];
		}
	}
Другие методы работы со свойствами
	Object.defineProperties(obj, descriptors) - позволяет объявить несколько объектов сразу
		Object.defineProperties(user, { //объект свойства которого названы как свойства в изменяемом объекте. Тут в них записывается объект с дескриптором
			propertyName: {
				...descriptor...
			},
			secondProperty: {
				...descriptor...
			},
			...
		})
Object.keys(obj) - возвращает только enumerable свойства
object.getOwnPropertyNames(obj) - возвращает все свойства
Object.getOwnPropertyDescriptor(obj, propName) - возвращает дескриптор указанного свойства
Object.preventExtensions(obj) - запретить добавление новых свойств в объект
object.seal(obj) - запрещает добавление и удаление свойств, все текущие свойства делает configurable: false
Object.freeze(obj) - всем свойствам делает writable: false, configurable: false
Object.isExtensible(obj) - возвращает false, если добавление свойствв объект было запрешено вызовом preventEtensions
Object.isSealed(obj) - true, если у свойств configurable: false
Object.isFrozen(obj) - true, если у свойств configurable: false, writable: false

----Статические и фабричные методы
Статические методы - это функции, которые являются свойствами конструктора
	function Article(){
		Article.count++; //статическое свойство
	}
	Article.showCount = function() {
		alert(this.count); //this тут равен Article
	}
Фабричные методы - статический метод, который осуществляет определенную реализацию объекта
	function User() {
		this.sayHi = function() {
			alert(this.name);
		};
	}

	User.createAnon = function() {
		var user = new User();
		user.name = "Anon";
		return user;
	};

	User.createFromData = function(userData) {
		var user = new User();
		user.name = userData.name;
		user.age = userData.age;
		return user;
	};

	var guest = new User();
	guest.sayHi(); //Anon

	var knowUser = User.createFromData({name: "Vasya", age: 25});
	knowUser.sayHi() //Vasya
Полиморфные конструкторы лучше использовать когда не знаешь какие параметры будут переданы

----Явное указание через this: "call", "apply"
Метод call
	func.call(context, arg1, arg2, ...) - вызывается функция func, в контексте context и аргументами arg1, arg2, ...
Метод apply
	func.apply(context, [arg1, arg2, ...]) - то же что и call, но вместо списка принимает массив аргументов
func.apply/или call/.(this, args) - this будет равен func

----Привязка контекста и карринг: "bind"
func.bind(Context [, arg1 arg2, ...]) - возвращает код функции (обертку вокруг нее), привязанной к контексту Context. Если указаны аргументы arg1, arg2, ... то они будут добавлены перед аргументами в вызовах возвращенной функции, т.е. как бы "фиксируем" аргументы.
Карринг - создание новой функции, путем фиксирования аргументов старой
	function mul(a, b) {
		return a * b;
	}
	var double = mul.bind(null, 2) //контектс null (он нам не нужен), второй аргумент (множитель) фиксируем 2
	duoble(3); //умножит на 2
double является "частичной функцией" от mul

----Функции-обертки, декораторы
Декоратор - функция, которая возвращает оберку вокруг целевой функции.
	function isAdmin(){...} //проверка наличия прав администратора
	function save() {...} //сохранить результаты дейтсвий
	function checkPermissionsAdmin(f) {
		return function() {
			if( isAdmin() ) {
				return f.apply(this, arguments);
			}
			alert("Нет прав доступа");
		}
	}

	save = checkPermissionsAdmin(save); //теперь, при вызове save, всегда будет происходить проверка прав администратора


------------------------Некоторые другие возможности----------------------------
----Типы данных: [[Class]], instanceof и утки
Во всех встроенных объектах есть специальное внутреннее свойство [[Class]], которое хранит информацию о его типе или конструкторе. Явно получить его нельзя.
Свойство toString стандартного объекта Object выводит [[Class]] в формате "[object значение]".
	{}.toString.call(new Date); //"[object Date]";
Можно использовать и с примитивами
	{}.toString.call(123); //"[object Number]"
Array.isArray(arr) - возвратит true, если arr массив. Иначе false
user instanceof User - оператор вернет true, если объект user был создан конструктором User
Утиная типизация - можно проверить что массив является таковым и без Array.isArray(). Например, если у массива есть типичный для него метод 	splice.
	if(arr.splice) {} //Конечно, такую проверку можно обойти, но в этом есть смысл утиной типизации. Т.е. будем тогда работать с этим как с массивом.
	//"Если нечто выглядит как утка, плавает как утка, то, вероятнее всего, это утка (не важно что это на самом деле)"
	Иными словами, duck tying - это проверка реализации объектом определенного интерфейса

----Формат JSON, метод toJSON
Это промежуточный формат, для передачи таких данных в виде стоки, как:
	 - JavaScript-объекты
	 - Массивы
	 - Строки в двойных кавычках
	 - Число
	 - Логическое значение true/false
	 - null
Строки в JSON-объектах должны быть в двойных кавычках
В формате JSON не поддерживаются комментарии
Методы для работы с JSON
	JSON.parse(str, reviewer) - читает объект из JSON-строки
		reviewer - функция function(key, value)
			key - ключ в объекте
			value - его значение
			Пример:
				//Если объект имеет несколько уровней вложенности, то reviewer проходится и по ним
				var str = '{"title":"Конференция","date":"2014-11-30T12:00:00.000Z"}';

				var event = JSON.parse(str, function(key, value) {
				  //если ключ с именем date (подразумеваем что он хранит дату), то создаем объект с датой
				  if (key == 'date') return new Date(value);
				  return value;
				});
	JSON.stringify(value, replacer, space) - преобразует («сериализует») значение в JSON-строку.
		value - объект, подлежащий сериализации
		replacer - массив свойств, подлежащих сериализации (ключи в двойных кавычках). Либо можно передать function(key, value), которая возвращает сериализованное value или undefined, если его не нужно включать в результат. replacer-функция работает рекурсивно.
		space - если передано число, то уровни вложенности объекта отмечаются указанным числом пробелов, если строка - вставляется эта строка.

При сериализации объекта, вызывается его встроенный метода toJSON (например, сериализация даты). Если такой метод отсутствует, то JSON строка будет содержать перечисление свойств и их значений (без методов).
Можно создать свой метод toJSON, тогда в строку попадет то, что указано в return

----setTimeout и setInterval
var timerId = setTimeout(func, delay[, arg1, arg2, ...]) - возвращает числовой идентификатор таймера, который можно использовать для отмены дейтсвия
	func - функция или строка кода для исполнения. Строку кода использовать не рекомендуется
	delay - задержка в мс.
	arg1, arg2, ... - аргументы, которые нужно передать функции.
clearTimeout(timerId) - удалить таймер
var timerId = setInterval(func, delay[, arg1, arg2, ...]) - смысл аргументов аналогичен setTimeout, только func запускается циклически. Время выполнения func не учитывается.
clearInterval(timerId) - удалить интервал
Рекурсивный setTimeout
	var timerId = setTimeout(function tick() {
		alert("tick!");
		timerId = setTimeout(tick, 2000);
	}, 2000)
	Более гибкий способ отсроченного вызова, т.к. каждый раз можно время интервала задавать разное.
	Время выполнения func учитывается, т.к. следующий отсроченный вызов происходит только после выполнения текущего.
Пример 1:
	setTimeout(function() {
		alert( i );
	}, 100);

	hardWork() //выполняется дольше 100мс
	В данном примере, пока setTimeout держит паузу (и ничего еще не вызвано), запускается hardWork. Пока hardWork выполняется, уже подошлп очередь запуска функции setTimeout. Как только hardWork выполнился, сразу вызывается функция в setTimeout.
Пример 2:
	var timer = setInterval(function() {
	  i++;
	}, 10);

	setTimeout(function() {
	  clearInterval(timer);
	  alert( i ); // (*)
	}, 50);

	var i;

	function f() {
	  // точное время выполнения не играет роли
	  // здесь оно заведомо больше 100 мс
	  for (i = 0; i < 1e8; i++) f[i % 2] = i;
	}

	f();

	Пока setInterval ждет паузу, щапустится f. Пока выполняется f, дойдет очередь до вызовов setInterval, но интерпретатор в это время же занят f. После выполнения f, будет только один раз вызван setInterval и сразу же setTimeout, очередь которого уже тоже подошла. Т.е. накопления вызовов не происходит.

----Запуск кода из строки: eval
eval(code) - выполнит код, переданный в виде строки. Выполнение произоудет в собственной eval обасти видимости. Возвращает последнее выполненное выражение.
eval используется редко, т.к. работа скрипта, содержащего его вызов, после сжатия становится непредсказуемой
Альтернатива eval - это new Function. Она не имеет замыкания и не сможет воздействовать на внешние переменные, но может получить их копии, переданные по параметрам

----Перехват ошибок, "try..catch"
Три основных свойства объекта ошибки:
	name - тип ошибки
	message - текстовое сообщение о деталях ошибки
	stack - строка с информацией о последовательности вызовов, которая привела к ошибке
new Error(message) - конструктор нового объекта ошибки
throw <объект> - передать объект ошибки в catch-блок
Проброс исключения
	Ошибку, тип которов catch не знает, он не должен обрабатывать
	Оператор throw, внутри catch пробрасывает объект с общибкой наружу. Там он может быть пойман другим catch-блоком ("более внешним") или "повалит" скрипт.
finally-блок - необязательный блок, после try...catch, который выполнится в любом случае
Если выход из try происходит посредством return, то сначала выполнится finally-блок, а потом обработается возвращенные return'ом данные. Например, если код был внутри функции, то сначала выполнится finally, а затем return'ом будет передано управление во внешний код.
Если ошибка произошла вне try...catch или выпала из catch наружу, то в браузере есть метод window.onerror, который, в таком случае, обработает эту ошибку. Нужно лишь определить его заранее
	window.onerror = function(message, url, lineNumber) {...}
		message - сообщение об ошибке
		url - текущий урл
		lineNumber - место в коде, откуда выпала ошибка




------------------------ООП в функциональном стиле----------------------------
----Введение
Конструкторы называют еще Классами
По приёмам объектно-ориентированной разработки пишут книги, к примеру:
	"Объектно-ориентированный анализ и проектирование с примерами приложений." Гради Буч и др..
	"Приемы объектно-ориентированного проектирования. Паттерны проектирования." Э. Гамма, Р. Хелм, Р. Джонсон, Дж. Влиссидес.

----Внутренний и внешний интерфейс
Один из важнейших принципов ООП - отделение внутреннего интерфейса от внешнего
В JS, приватные свойства - это локальные переменные конструктора.
Публичные - свойства, объявленные через this
Можно привязать к функции контекст, с помощью bind, а можно сохранить его значени во вспомогательную переменную в замыкании, и посредством нее, в функции уже обращаться ко свойствам конкретного контектса.
Отделение внутреннего интерфейса от внешнего, называется "инкапсуляция"

----Геттеры и сеттеры
Называются, обычно, getСвойство и setСвойство - это публичные методы, для получения и установки значений приватных свойств.
Так же, делают и единый метод, отвечающий за запись и за чтение. Называют его одноименно с обрабатываемым свойством. При вызове с параметрами, такой метод устанавливает свойство, а без них - возвращает.

----Функциональное наследование
Один из способов реализации оного - использование наложения конструкторов
	function Machine() {
		var enabled = false;

		this.enable = function() {
			enabled = true;
		}

		this.disable = function() {
			enabled = false;
		}
	}

	function CoffeeMachine() {
		Machine.call(this); // (*)
		...
	}

	(*) - Вызываетс с передачей контектса текущего объекта и записывает в него (контекст, а следовательно в объект) какие-нибудь свойства. Однако локальные переменные и свойства для Machine, будут скрыты в дочернем классе (конструкторе).
Чтобы обозначить внутреннее свойство родителя, его имя начинают с нижнего подчеркивания "_", который условно обозначает что свойство предназначено только для чтения. Такие свойства называют защищенными
Расширение родительского метода
	function Child() {
		Parent.call(this);

		var parentMethod = this.method; //Копируем родительский метод в переменную
		this.menthod = function() { //в дочернем расширяемом методе
			parentMethod.call(this);	 //вызываем родительский метод с передачей текущего this
			/new instructions/ //А после него, дополнительные инструкции
		}
	}




------------------------ООП в прототипном стиле----------------------------
----Прототип proto
__proto__ - специальная ссылка на объект, в котором будут искаться свойства, отсутствующие в данном объекте. Указывается явно.
	var animal = {
		eats: true
	};

	var rabbit = {
		jump: true
	};

	rabbit.__proto__ = animal;

	alert(rabbit.jump);
	alert(rabbit.eats); //По proto, будет искать свойство eats в animal
Прототип - объект, на которое указывает __proto__. Несколько прототипов присвоить одному объекту нельзя.
Прототип используется только при чтении свойств. Запись или удаление (н.п. rabbit.eats = false) будет работать напрямую, с данным объектом
Цикл for...in не различает между свойствами объекта и его прототипа. Переберет свойства, непосредственно перебераемого объекта, и всех его прототипов.
obj.hasOwnProperty("propName") - возвращает true, если свойство принадлежит самому объекту, а не его прототипу. Иначе false
Чтобы использовать объект как простую коллекцию, рекомендуется сделать так:
	var obj = Object.create(null);
	obj.data = "someData";
	/.../
	Создать объект, у которого proto = null, а потом добавлять к нему свойства.
	Таким образом в созданном объекте не бутет прототипа (__proto__ = Object), а значит не будет встроенных методов, а только те, которые мы присвоили.
Вспомогательные методы:
	Object.getPrototypeOf(obj) - возвращает __proto__ переданного объекта
	Object.setPrototypeOf(obj, proto) - устанавливает значение __proto__ для объекта obj
	Object.create(proto, descriptors) - создает пустой объект с __proto__, равным первому агрументу и свойствами, определенными в дескрипторах

----Свойство F.prototype и создание объектов через new
Чтобы объекту автоматически присваивался прототип, при создании через конструктор, свойсту prototype последнего, присваивается значение для __proto__ создаваемого объекта
	//есть конструктор Rabbit и объект animal, который должен быть прототипом объектов, создаваемых черерез Rabbit.
	Rabbit.prototype = animal;
	var rabbit = new Rabbit(); //rabbit.__proto__ = animal
Если в prototype записан примитив, оно будет проигнорировано
У каждой функции есть свойство prototype по умолчанию. Оно содержит объект вида:
	function Rabbit();
	Rabbit.prototype = {
		constuctor: Rabbit;
	}
	//можно его использовать, для создания объекта с тем же конструктором, которым был создан данный
	var rabbit = new Rabbit();
	var rabbit2 = new rabbit.constuctor() //значение свойства constuctor нет в rabbit, потому оно будет искаться в __proto__, которое было задано в момент создания rabbit и равно значению prototype конструктора
Итого
	prototype - свойство, значение которого будет записано в __proto__ у дочерних объектов
	__proto__ - свойство, ссылающееся, обычно, на родетельский класс (конструктор)

Итого:
	Функциональный стиль ООП - когда наследование осуществляется путем вызова родительского конструктора в контексте


----Встроенные классы в JavaScript
При создании объекта, его свойство __proto__ равно Object
Все встроенные методы, новый объект получает из Object.prototype, по __proto__. Object.prototype = Object;
Лучше вызывать встроенные методы через prototype, в нужном контексте, чем через объект
	Array.prototype.call(argumetns) //нет необходимости в создании объекта
	вместо
	[].join.call(arguments)
При вызове метода примитива, создается временный объект (н.п. для строки new String), после выполнения метода он уничтожается.
Свойство prototype во встроенных классах также можно изменять. Однако так делать не очень хорошо с архетитектурной точки зрения

----Свои классы на прототипах
Новый класс в функциональном стиле (все методы в конструкторе)
	function Animal() {
		/this.props/
		/this.methods/
	}
Новый класс в прототипном стиле (все методы в прототипе конструктора)
	function Animal() {
		/this.props/
	}
	Animal.prototype.method1 = function() {...};
	Animal.prototype.method2 = function() {...};
	...
Достоинства:
	Функциональный метод записывает в каждый экземпляр и методы, тогда как прототипный - только свойства. Прототипный потому экономнее по памяти
Недостатки:
	В прототипном стиле нельзя использовать локальные переменные как приватные свойства конструктора. Потому, приходится записывать такое свойство через this, условно обозначив его как защищиенное
		function Animal(name) {
			this._name = name;
		}
		Animal.prototype.method = function() {
			/тут уже работаем с this._name/
		}

----Наследование классов в JavaScript
Для прототипного наследования классов (они же конструкторы), нужно prototype, явно задать ссылку __proto__, указывающую prototype на класса-родителя
	function Animal() {...};
	function Rabbit() {...}
	Rabbit.prototype.__proto__ = Animal.prototype
Однако в некоторых старых браузерах не поддерживается явный доступ к __proto__, потому лучше использовать Object.create()
	Rabbit.prototype = Object.create(Animal.prototype); //однако потеряем constuctor
	Rabbit.prototype.constuctor = Rabbit; //явно сохраняем конструктор
	//и добавляем уже свои методы
	Rabbit.prototype.method = function() {...}
В страых руководствах рекомендуется делать наследование так:
	Rabbit.prototype = new Animal();
Однако так делать не рекомендуется, т.к. при этом будет создан новый объект
Чтобы переопределить метод в прототипном стиле, нужно просто объявить одноименный метод в prototype наследника
Чтобы расширить метод радилеля, то нужно в одноименном методе наследника вызвать, с указанием контекста метод из prototype родителя
	Rabbit.prototype.run = function() {
		Animal.prototype.run.apply(this, arguments);
		/расширяющие инструкции/
	}

----Проверка класса: "instanceof"
instanceof - оператор, позволяющий проверить принадлежность объекта конструктору, с учетом прототипного наследования (если конструктор объекта наследует от проверяемого конструктора)
	var a = [];
	alert(a instanceof Array); //true
	alert(a instanceof Object); //true
Проверка происходит через сравнение прототипов
Алгоритм работы obj instanceof Constructor
1. Получить obj.__proto__
2. Сравнить obj.__proto__ с Constructor.prototype
3. Если не совпадает, тогда заменить obj на obj.__proto__ и повторить проверку на шаге 2 до тех пор, пока либо не найдется совпадение (результат true), либо цепочка прототипов не закончится (результат false).
Если объект создан в iframe и передан в родительское окно, то instanceof не сможет проверить его в родительском окне

----Свои ошибки, наследование от Error
Свой объект ошибки
	function PropertyError(property) { //своя ошибка
	  Error.call(this, property); //Наследуем свойства стандартного конструктора ошибок
	  
	  this.name = "PropertyError"; //переопределяем некоторые стандартные свойства
	  this.property = property;
	  this.message = "Ошибка в свойстве " + property;

	  if (Error.captureStackTrace) { //в V8 есть расширение, позволяющее получить стэк вызовов, приведшик к данной ошибке
	    Error.captureStackTrace(this, PropertyError);
	  } else { //Если такого расширения нет, то записываем стэк в свойство, из тут же сгенерированного объекта ошибки
	    this.stack = (new Error()).stack; //Это нужно, т.к. у нашего навого объекта, по умолчанию свойства stack не будет
	  }

	}

	PropertyError.prototype = Object.create(Error.prototype)
	Error.call(this, property); - вообще, этот вызов не обязателен в данной ситуации. Единственное что он устанавливает специальное внутреннее свойство [[ErrorData]], которое выводится в toString и позволяет увидеть что это ошибка.

Error.captureStackTrace(this [, PropertyError]) - записывает в контекст this (текущий объект), стэк вызовов. Второй аргумент, говорит о том, что при генерации стека, нужно на этой функции остановиться (и не включать ее в стек).
Чтобы наследовать от ошибок Error, нужно самостоятельно позаботиться об инициализации свойств name, stack и message

----Примеси
В JS невозможно наследовать от >1 объекта
Примесь - класс или объект, реализующий какое-либо четко-выделенное поведение. Используется для уточнения поведения других классов. Не предназначен для самостоятельного использования.
Использование
	function Mixin() {
		method1: function() {...},
		method2: function(args) {...}
	}

	function Class() {...}

	for (var key in object) Class.prototype[key] = Mixin[key]; //копируем методы из примеси в класс

Методы примеси активно используют this, и предназначены для запуска внутри контекста
Пример примеси:
	var eventHandlers = {
		"event": function() {}, //обработчик
		...
	}




------------------------Современные возможности ES-2015----------------------------
----Переменные: let и const
let
	Область видимости - блок
	let переменная видна только после объявления
	При повторном объявлении ошибка
	В цикле, для каждой итерации будет создаваться своя отдельная переменная. Замыкания вложенных в цикл функций получат разные переменные.
const
	Нельзя переопределять
	В остальном - то же что и let

----Деструктуризация
Особый синтаксис присваивания, когда можно присвоить объект или массив сразу нескольким переменным.
	var [a, b] = [1, 2]; //a будет равно 1, а b - 2
Лишние элементы массива можно отбросить, поставив запятые
	var [, , a] = [1, 2, 3];
	alert(a); // 3
Оператор "spread" (троеточие) запишет в элемент с ним, все остальное содержимое инициализирующего массива. Должен стоять последним в списке слева
	var [a, b, ...c] = [1, 2, 3, 4, 5];
	alert(a); // 1
	alert(b); // 2
	alert(c); // массив [3, 4, 5]
Если в инициализируемом массиве больше значений, чем в инициализирующем, то у первого "лишние" значения будут равны undefined
Значения по умолчанию - после переменных поставить = и значение
	var [a, b, c = 3, d = 4] = [1, 2];
	alert(c); // 3
	alert(d); // 4
Деструктуризация объектов: слева - список переменных, справа - существующий объект (может быть объявлен и ранее)
	var {var1, var2} = {var1: 1, var2: 2}; //переменные должны иметь одинаковые со свойствами объекта имена
	alert(var1); // 1
	alert(var2); // 2
Если нужно присвоить свойсто объекта переменной с другим именем, то нужно указать соответствие через двоеточие
	var {prop1: a, prop2: b} = {prop1: 1, prop2: 2};
	alert(a); // 1
Можно сочетать двоеточие и равенство
	var {prop1: a, prop2: b, prop3: c = 3} = {prop1: 1, prop2: 2};
	alert(c); // 3
Оператора "spread" в деструктуризации объектов аналогичен с массивами
Если в объекте или массие есть вложенные объекты или массивы, то можно сохранить структуру так
	var {prop1: a, prop2: {aa, bb}} = {prop1: 1, prop2: {aa: 11, bb: 22}}; //при этом prop2 == undefined, аa а и bb будут иметь значения

----Функции
Парамметры по умолчанию
	function f(a = 1, b = 2) {...}
	При передаче любого значения, кроме undefined, параметр считается переданным и значение по умолчанию не используется
Оператор spread вместо arguments
	function f(a, b, ...rest) {} //...rest - настоящий массив (не псевдо) и в него попадут все остальные переданные аргументы
	Оператор spread должен быть в конце списка параметров
spread для передачи массива аргументов как списка
	var numbers = [1, 2, 3, 4, 5];
	let max = Math.max(...numbers);
Деструктуризация в параметрах
	Если функция получает объект, то она может сразу же разбит его на переменные
	function f({title="title", number="0"}) {...} //можно использовать и более сложную деструктуризацию, согласно всем правилам оной

	var obj = {
		title: "name",
		number: 5
	};

	f(obj);
	Чтобы можно было вызвать функцию f вообще без аргументов, объявить ей параметр по умолчанию так
		function f({title="title", number="0"} = {}) {...}
Имя "name"
	В свойстве функции name хранится ее имя
	При создании анонимной фунции, с записью в переменную, свойство name будет равно имени переменной
Функции в блоке
	Function Declaration сделанное в блоке кода, видно только в этом блоке
Функции через =>
	let f = (a, b) => a + b; // аналогично function(a, b) {return a + b;}
	Если тело функции сложное, то оно оборачивается в скобки {...}, однако ее результат уже не будет возвращен автоматически. Уже тут нужно применять return
	Удобны в качестве коллбеков
	Не имеют своего this, внутри такой функции он тот же что и снаружи. Потому их нельзя использовать в качестве конструктора.
	Функции-стрелки не имеют собственного arguments

----Строки
Доступен новый вид кавычек `str <перевод строки> ing` - строка будет выведена со всеми переводами строки
	В такие кавычки можно вставлять выражения при помощи ${...}. Такая вставка называется интерполяцией
Функции шаблонизации
	function(strings, ...values) {...}
	func`my string ${a} + ${b}`; //вызов функции перед `строкой`, передаст элементы этой строки в эту функцию как аргументы
		func - имя вызываемой функции
		В обратных кавычках строка как список аргументов. Все что вне ${}, считается строкой и будет записано в первый аргумент, а остальные значения получит второй аргумент.
		Можно объявить список параметров и явно, суть в том, что все строковые значения будут записываться только в первый.
	У первого параметра есть свойство raw (strings.raw), в котором все спец символы записаны "как есть". Это дает возможность обрабатывать их "по-своему".
"Суррогатная пара" - когда два юникодных символа (по 2 байта), образуют неюникодный символ (которому требуется 4 байта).
Методы для работы с суррогатными парами
	String.fromCodePoint - аналог String.fromCharCode
	String.codePointAt - аналог String.charCodeAt
String.charCodeAt считает суррогатную пару двумя символами, а String.codePointAt рассматривает ее правильно - как единый символ
String.fromCodePoint(code) - создает строку из длинного кода code. String.fromCharCode(code) берет только первые два байта из переданого кода, а остальные отбрасывает
Давно есть поддержка юникод-символов, путем ввода \uNNNN, где NNNN - четырехзначный шестнадцатеричный код. Остальные символы в коде будут отброшены.
Если символ имеет >4 значный код, то его нужно обрамить в фигурные скобки {}
Unicode-нормализация - если в строке стоит нормальный символ, а потом юникод-символ, то нормализация сливает их в один
	"S\u0307\u0323" - сначала "S", а потом символы "точка сверху" и "точка снизу". Получим "Ṩ";
	Если верхнюю и нижнюю точки поменять местами в юникод-представлении, то символ визуально не поменяется никак. Для того чтобы в таких случаях приводить юникод-символы к единому представлению и существует Unicode-нормализация.
	Реализует ее метод string.normalize()
		"S\u0307\u0323".normalize() == "S\u0323\u0307".normalize(); //true
Полезные методы
	str1.includes(str2) - true, если str1 содержит в себе str2, иначе false
	str1.endsWith(str2) - true, если str1 заканчивается подстрокой str2, иначе false
	str1.startsWith(str2) - аналогично предыдущему, только рассматривается начало
	str.repeat(times) - повторяет строку str times раз

----Объекты и прототипы
Короткое свойство - при объявлении объекта достаточно указать только имя свойства, а значение будет взято из переменной с аналогичным именем
	var name = "Vasya";
	var surname = "Pupkin";

	var obj = {
		name,
		surname
	};

	alert(obj.name); //"Vasya"
Вычисляемое имя свойства - вместо имени свойства можно использовать переменную со строкой или даже выражение из нескольких переменных
	var a = "Vasya";
	var b = "Pupkin";
	var o = {
		[a + b]: "Hello"
	};
Добавлен метод для установки прототипа
	Object.setPrototypeOf(obj, newProto)
"Конкатенация" объектов - добавлен метод Object.assign(target, src1, src2, ...)
	Добавляет свойства src-объектов в target-объект. При этом, существующие свойства будут перезаписаны последующими свойствами с таким же именем
Object.is(value1, value2) - сравнивает value1 и value2. Во многом аналогичен работе оператора строгого равенства "===", с небольщими отличиями
	Object.is(+0, -0); //false
	+0 === -0; //true
	Object.is(NaN, NaN); //true
	NaN === NaN; //false
	


















--------------------Стандартные функции JS-------------------------
result = prompt(title, default) - выводит модальное окно, с тектсом title и текстовым полем, заполненным изначально default. Возвращает введенное пользователем значение или null, в случае отмены ввода.
result = confirm(question) - выводит модальное окно с вопросом question и возвращает true, в случае нажатия OK, иначе false
