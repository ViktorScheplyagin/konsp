<<<<<<< HEAD
*************************************************Часть 1**********************************************************

-------------------------Введение--------------------------------
Спецификафия языка называется ECMAScript
babejs - транслятор, который транслирует JS-код, в код более старого стандарта

----Справочники и спецификации
	Mozilla Developer Network - https://developer.mozilla.org/
	MSDN - http://msdn.microsoft.com/ //полезна при разработке под IE
	Safari Developer Library - https://developer.apple.com/library/safari/navigation/index.html
	https://kangax.github.io/compat-table – таблица с обзором поддержки спецификации ECMAScript различными платформами.
	ECMAScript спецификация - http://www.ecma-international.org/publications/standards/Ecma-262.htm


----------------------Основы JavaScript---------------------------
Скрипты можно вставить в любое место html с помощью тега <script>
<meta charset="utf-8"> - тег, для корректного отображения текста в браузере

Современная разметка для <script>
	Атрибут type="text/javascript" - был обязателен в HTML4
	Атрибут language=... - по умолчанию язык - JavaScript

----Подключенные скрипты. Порядок исполнения
Браузер скачает скрипт только первый раз, а затем закеширует его
По умолчанию браузер сначала должен выполнить скрипт, а затем продолжить отображать страницу - такое поведение называется "синхронным"
	<script src="..." async> - скрипт будет загружаться, параллельно с отображением страницы. Когда скрипт будет загружен, он выполнится. Имеет приоритет перед defer. IE9 не поддерживается.
	<script src="..." defer> - То же самое, что и async, но относительный порядок скриптов будет сохранен и скрипт сработает только когда весь документ будет обработан браузером

В имени переменной не долдно быть дефиса
Имя переменной, состоящее из нескольких слов, пишетсяВотТак.
Лучше хранить в переменной что-то одно, а для нового значения объявить новую

----Операторы
typeof x - оператор вернет тип переменной "x"
'1' + 1 = строка '11'. Остальные арифметические операторы всегда приводят операнды к числу
Унарный плюс приведет операнд к числу: +'1' = число 1
Оператор присваивания, еще и возвращает (подобно функции) то значение, которое присвоил переменной
	с = 3 - (а = 2 + 3); //в "с" запишется -2, а в "а" 5
	alert(a);
Оператор "заптая" - a = (5 + 3, 3 * 6). Каждое выражение вычисляется и отбрасывается, а последнее возращается

----Сравнение
Для корректного сравнения строк, они должны быть в одинаковом регистре
При сравнении значений разных типов, применяется ЧИСЛОВОЕ преобразование.
null и undefined равны друд другу и не равны больше ничему
Числовые преобразования:
	null -> 0
	undefined -> NaN

----Логические операторы
Несколько ИЛИ слева направо. При первом true, вся дальнейшая часть конструкции опускается. Возвращается то значение, на котором остановилось вычисление, не преобразованное к логическому типу.
Аналогично с логическим И, только он запинается на ЛЖИ
У логического И приоритет выше чем у ИЛИ, но Короткий Цикл вычислений все равно начинается с слева направо.
	alert( null || 2 && 3 || 4 ); // 3
		то же что и alert( null || (2 && 3) || 4 ), т.е. сначала проверится null, потом проверится 2 && 3 (а не только 2)

----Преобразование типов
строковое преобразование:
	alert() преобразовывает к строке
	String(val) - преобразование явным образом
	Так же оператор "+", у которого один из аргументов строка, преобразует и второй к строке
Численное преобразование:
	При сравнении данных различных типов (кроме операторов строгого стравнения)
	Number(val) - явное преобразование
	Преобразование унарным плюсом
	Численное преобразование типов: //undefined и null при сравнении "==", не приводятся к NaN и 0, а считаются равными
		+undefined //NaN
		+null //0
			null >= 0 //true
			null > 0 и null < 0 //false
		*Для избежания путанницы, лучше не давать специальным значениям учавствовать в сранении*
		+true //1
		+false //0
		+"string" //Пробельные символы по краям обрезаются. Если остается пустая строка, то получаем 0, если не пустая, то из нее считывается число. При ошибке получаем NaN
Логическое преобразование:
	!!value или Boolean(value) - явное логическое преобразование
	Преобразование типов:
		0, '', undefined, NaN, null -> false
		Все остальное, в т.ч. объекты -> true
if выполняет логическое преобразование

----Метки break/continue
break метка / continue метка - выйти из цикла. Ставится перед циклом, из которого необходимо выйти
	outer: //метка
	for(var i=0; i<100; i++){
		for(var j=0; j<100; j++){
			if(j = 98) break outer;
		}
	}
	alert('End of cycle');
	В данном коде произойдет выход из внешнего цикла (перед которым стоит метка) и управление передастся alert(). В случае с continue, вместо выхода, произойдет переход на следующую итерацию внешнего цикла.

----Конструкция switch
Если в кейсе нету брейка, то продолжится выполнение всех нижестоящих кейсов, без проверки условий.
Оператор switch делает строгую проверку (===).

----Функции
Если внутри функции объявить переменную (var) с таким же именем, как у внешней переменной, то внутрянняя переопределит внутри внешнюю переменную
Function Declaration создаются интерпретатором до выполнения кода
В режиме use strict Function Declaration видны только внутри блока кода, в котором объявлены
Еще один способ создания функций. Используется очень редко:
	var sum = new Function('a, b', 'return a+b') //1ый аргумент - параметры, 2й - тело
Значение, на котором заканчивается рекурсия, называют "базисом рекурсии".
Контекст функции - это служебная информация, которая включает в себя локальные переменные и место в цепочке команд, на котором произошел вызов функции.
При вложенных вызовах, контексты хранятся в специальной внутренней структуре данных - стеке контекстов. Для вложенной функции создается новый контекст, а контекст внешней записывается в стек. Когда выполнение вложенной функции завершено, ее контекст удаляется, из стека достается контекст внешней функции и ее выполнение возобновляется.
Именованные функциональные выражения (NFE):
	var f = function sayHi(...){ //имя sayHi доступно только ВНУТРИ самой функции.
		sayHi = 'text' //ошибка. Перезаписать это имя невозможно
	}
	Данное имя используется только для рекурсии
	Если Function Declaration обрамить в круглые скобки, то оно превратится в NFE
		var func = (function f(){...});




------------------------Качество кода------------------------------
----Отладка
debugger; - команда, заставившая отладчик остановиться на ней, как на брейкпойнте

----Советы по стилю кода
Между параметрами пробел
Пробел перед открывающей фигурной скобкой
Пробел после for
Пробелы вокруг операторов
Пустая строка между логическими блоками
else без перевода строки
Пробелы вокруг вложенного вызова функции
Одна функция = одно действие
В начале сложного скрипта архитектурный коментарий (или справочный перед функцией) в формате JSDoc


------------Автоматические тесты при помощи chai и mocha------------
BDD (Behavion Driven Development) = тесты + документация + примеры использования
Разработка функции pow(x, n):
	Сначала пишем спецификацию
		describe("pow", function() {
			it("Возводит в n-ю степень", function() {
				assert.equal(pow(2, 3), 8);
			});
		});

		describe(название, function() { ... }) - задает что именно мы описываем. Используется для группировки "рабочих лошадок" - блоков it.
		it(название, function() { ... }) - в названии человеческим языком описывается что должна делать функция, далее следует тест, который проверяет это.
		Код внутри it, если реализация верна, должен выполняться без ошибок.
		assert.equal(value1, value2) - сравнивает два значения.
	Поток разработки:
		1. Пишется спецификация, описывающая базовый функционал
		2. Делается начальная реализация
		3. Для проверки соответсвия спецификации используем фреймворк (в нашем случае Mocha) который запускает тесты it и выводит ошибки. При ошибках вносятся исправления
		4. Спецификафия расширяется, в нее добавляются возможности, которые, возможно, не поддерживаются реализацией.
		5. Идем в пункт 2 и расширяем реализацию. И так до конца.
	Mocha - содержит общие функции для тестирования, включая describe и it.
	Chai - содержит разнообразные функции для проверок (assert.equal())
	Sinon - для эмуляции и подмены функций "заглушками".

Запуск тестов инициируется командой mocha.run();
Результат тестирования будет выводиться в элемент <div id="mocha"></div>
Если в одном it несколько assert-ов и если один из них обнаружит ошибку, то он сразу же завершает выполнение блока it
Можно создавать отдельные подгруппы тестов, с помощью вложенных describe блоков
before(functions) / after(functions) - можно внутри describe создать блоки функций, которые будут выполнены, соответственно до и после it тестов
beforeEach(functions) / afterEach(functions) - аналогично предыдущим, но функции будут выполнены после каждого it теста
assert(выражение) - выдает ошибку, если выражение, при приведении к логическому типу, не true
assert.strictEqual(value1, value2) - проверка строгого равенства
assert.notEqual(value1, value2), assert.notStrictEqual(value1, value2) - проверка неравенства и строгого неравенства соответственно
assert.isTrue(value) - если value === t
assert.isFalse(value) - если value === false
assert.isNaN(value) - true если value === NaN



------------------------Структуры Данных----------------------------
string.length - длина строки
str.toUpperCase() - возвращает строку в верхнем регистре
num.toFixed(n) - округляет число num до n знаков после запятой, при необходимости, дополняя нулями. Возвращает результат в виде строки.

----Числа
Можно записывать числа в 16-ричной системе счисления, предварив число "0х"
num.toString(система счисления) - получить число в 16-чной системе, в виде строки. Основание системы может быть от 2 до 36
<number>e<quantity of zeroes> - "научный" формат записи числа
isNaN(num) - true, если num === NaN
isFinite(num) - true, если num не равно NaN/+-Infinity
parseInt(num)/parseFloat(num) - посимвольное преобразование строки в целые/дробные числа, пока это возможно. В случае ошибки, возвращается то, что получилось, иначе сразу NaN
Math.floor(num) - округляет вниз
Math.ceil(num) - округляет вверх
Math.round(num) - до ближайшего целого
~~num - двойное побитовое НЕ, обрезает дробную часть, делая число целым
	~~12.3 == 12
Подойдет так же ИСКЛЮЧАЮЩЕЕ ИЛИ с нулем
	12.3 ^ 0 == 12
num.toFixed(precission) - округляет num до точности precission. Возвращает результат в виде строки
num.toLoacleString() - форматированный вывод числа

----Строки
\uNNNN - символ в кодировке юникод, представленный кодом NNNN
str.indexOf(substr[, start_position]) - возвращает позицию искомой подстроки или -1
	if(~str.indexOf(...)) - оператор '~' эквивалентен -(n + 1). Т.е. ? если подстрока не найдена и возвращен -1, он автоматически превращается в 0 (-(-1 + 1)), что интерпретируется if'ом как false
Взятие подстроки:
	str.substring(start [, end]) - возвращиет подстроку со start по end (не включительно). Если end нету, то идет до конца строки. Отрицательные аргументы интерпретируются как равные 0. Слищком большие усекаются до длины строки. Если start > end, то аргументы меняются местами
	str.substr(start, [, length]) - аналогичен предыдущему, только lenght обозначает количество возвращаемых сиволов
	str.slice(start [, end]) - аналогичен substring(). При отрицательных аргументах отсчет идет с конца строки
String.fromCharCode(code) - получить символ, по его коду Unicode
str.charCodeAt(pos) - возвращает код символа на позиции pos
str.localeCompare(str2) - корректное сравнение строк разных языков

----Объекты
Создание объекта:
	o = new Object(); или o = {};
Удалить свойство:
	delete obj.property;
Проверка на существование свойства:
	if("propertyName" in object_name)
obj.["property"] - доступ к свойству объекта через квадратные скобки
Объекты могут быть вложенными
Перебор свойств:
	for(var key in obj){ //если key числовая строка, то такие свойства, при переборе, сортируются как числа.
		console.log(obj[key]) //доступ через квадратные скобки
	}

----Массивы
Удаление/Добавление элементов:
	arr.pop() - удаляет последний элемент из масива
	arr.push(elem) - добавляет элемент в конец массива
	arr.shift() - удаляет первый элемент массива
	arr.unshift(elem) - добавляет элемент в начало массива
	Можно так же удалять элемент оператором delete
	arr.length = 0 - очистить массив
	arr.splice(index [, deleteCount, elem1, ..., elemnN]) - удалить deleteCount элементов, начиная с номера index, а затем вставить на их место elem1, ..., elemN. Возвращает массив из удаленных элементов. 
	arr.concat(value1, ... valueN) - присоединяет к концу массива переданные элементы. Можно так же передать массив.
Взятие подмассивов:
	str.split(s [, qty]) - разбивает строку по разделителю s на массив. qty - ограничение на количество элементов вмассиве.
	arr.join(str) - создает из массива строку, разделяя элементы str
	Если номер отрицательный, то отсчет начинается с конца
	all.slice(start, end) - копирует участок массива, со start по end (не включительно). Если end не указан, то копирование будет до конца массива. Отрицательные индексы - отсчет с конца. Вообще без аргументов - скопируется весь массив
Сортировка:
	arr.sort(fn) - сортировка элементов массива. По умолчанию сортирует, преобразовывая элементы к строке.
		fn - функция, принимающая 2 аргумента - сравниваемые элементы. Если функция возвращает положительное значение, то элементы меняются местами.
	arr.reverse() - меняет порядок элементов на обратный
arr.indexOf(elem [, fromIndex]) - возвращает индекс элемента elem или -1, начиная поиск с позиции fromIndex. Для поиска используется строгое стравнение
arr.lastIndexOf(elem [, fromIndex]) - аналогично предыдущему, только начинает поиск с конца.
Object.keys(obj) - возвращает массив ключей объекта
Перебирающие методы:
	arr.forEach(callback, context) - для каждого элемента вызывается функция callback(item, i, arr)
		item - текущий элемент массива
		i - его индекс
		arr - массив, который перебирается
	arr.filter(callback) - создает новый массив с теми элементами, для которых callback(item, i, arr) вернет true
	arr.map(callback) - создает новый массив, с возвращенными результатами callback(item, i, arr), после работы с каждым элементом
	arr.every(callback) - возвращает true, если callback(item, i, arr) вернул true для каждого элемента в массиве
	arr.some(callback) - возвращает true, если callback(item, i, arr) вернул true хотябы для одного элемента в массиве
	arr.reduce(callback [, initialValue]) - применяет callback(previousValue, currentItem, index, arr) к каждому элементу массива, сохраняя промежуточный результат вычислений
		previousValue - последний результат работы метода. Он же "промежуточный результат"
		currentItem - текущий элемента массива, элементы перебираются по очереди, слева направо
		index - номер текущего элемента
		arr - массив который перебираются
		initialValue - начальное значение промежуточного результата. Если этот аргумент не передан, то оно равно первому элементу массива, а перебор осуществляется со второго
	arr.reduceRight() - все аналогично arr.reduce(), но перебор справаналево
Псевдомассив arguments - объект с числовыми ключами и имеющий свойство length. Его значения отвязаны от параметров и не влюяют друг на друга.
Когда очень много параметров, можно в качестве аргумента, передать в функцию объект, свойства которого будут хранить необходимые значения

----Дата и время
Создание даты:
	new Date() - создать объект Date, с текущей датой и временем
	new Date(milliseconds) - создает объект в котором milliseconds миллисекунд, которые считаются прошедшими с 01.01.1970
	new Date(datestring) - Если единственный аргумент - строка, то надо использовать Date.parse для чтения даты из нее
	new Date(year, month, date, hours, minutes, seconds, ms) -  создать дату
		первые 2 аргумента обязательны
		year должен состоять из 4х цифр
		отсутствующие параметры, начиная с hours, считаются равными 0, а date единице
		Номер месяца начинается с 0
		Номер дня в месяце начинается с единицы
Получение компонентов даты:
	getFullYear() - получить год (из 4 цифр)
	getMonth() - получить месяц (от 0 до 11)
	getDate() - получить число дня месяца (от 1 до 31)
	getHours(), getMinutes(), getSeconds(), getMilliseconds() - получить соответствующие компоненты
	getDay() - получить номер дня недели, начиная с воскресения (от 0 до 6)
	getTime() - возвращает количество миллисекунд с 01.01.1970
	getTimezoneOffset() - возвращает разницу между текущей и UTC зонами в минутах
	Все методы возвращают значения для местной временной зоны
	В UTC вариантах все то же самое, только в названиях методов, после "get" ставится "UTC" (getUTCMonth())
Установка компонетов даты:
	setFullYear(year [, month, date])
	setMonth(month [, date])
	setDate(date)
	setHours(hours [, min, sec, ms])
	setMinutes(min [, sec, ms])
	setSeconds(sec [, ms])
	setMilliseconds(ms)
	setTime(ms) - устанавливает всю дату по миллисекундам
	Все методу, кроме setTime() обладают UTC вариантом
	Date автоматически исправляет дату. 32 марта станет 1 апреля. Можно просто прибавлять количество дней к текущему значению
Date в числовом контексте преобразуется в количество миллисекунд. Эти значения можно подвергать арифметическим операциям
Бенчмаркинг:
	performance.now() - возаратит время от момента выгрузки предыдущей страницы из памяти, до места в коде, где этот метод вызван
	console.time(метка) - включить внутренний хронометр браузера. Метка предназначена для идентификации замера
	console.timeEnd(метка) - выключить внутренний хронометр браузера и вывести результат
Форматированный вывод дат:
	toString(), toTimeString(), toDateString() - возвращает стандартное строчное представление, зависящее от браузера. Имеют UTC аналоги
Разбор строки, Date.parse:
	Формат ISO 8601 Extended: YYYY-MM-DDTHH:mm:ss:sssZ:
		YYYY - год
		MM - месяц
		T - обычный символ. Используется как разделитель
		HH:ss:sss - часы, секунды, миллисекунды соответственно
		Z - временная зона в формате +-hh:mm
	Date.parse(str) - разбирает строку в вышеуказанном формате и возвращает количество мс. Иначе возвращает NaN
Date.now() - вернет текущую дату в миллисекундах
----[[Scope]] для new Function
При создании функции через new Function, ее внутреннее свойство [[Scope]] будет указывать всегда на window, а значит такие функции не могут использовать замыкание
Минификатор переименовывает все локальные переменные на более которкие имена










--------------------Стандартные функции JS-------------------------
result = prompt(title, default) - выводит модальное окно, с тектсом title и текстовым полем, заполненным изначально default. Возвращает введенное пользователем значение или null, в случае отмены ввода.
result = confirm(question) - выводит модальное окно с вопросом question и возвращает true, в случае нажатия OK, иначе false
=======
*************************************************Часть 1**********************************************************

-------------------------Введение--------------------------------
Спецификафия языка называется ECMAScript
babejs - транслятор, который транслирует JS-код, в код более старого стандарта

----Справочники и спецификации
	Mozilla Developer Network - https://developer.mozilla.org/
	MSDN - http://msdn.microsoft.com/ //полезна при разработке под IE
	Safari Developer Library - https://developer.apple.com/library/safari/navigation/index.html
	https://kangax.github.io/compat-table – таблица с обзором поддержки спецификации ECMAScript различными платформами.
	ECMAScript спецификация - http://www.ecma-international.org/publications/standards/Ecma-262.htm


----------------------Основы JavaScript---------------------------
Скрипты можно вставить в любое место html с помощью тега <script>
<meta charset="utf-8"> - тег, для корректного отображения текста в браузере

Современная разметка для <script>
	Атрибут type="text/javascript" - был обязателен в HTML4
	Атрибут language=... - по умолчанию язык - JavaScript

----Подключенные скрипты. Порядок исполнения
Браузер скачает скрипт только первый раз, а затем закеширует его
По умолчанию браузер сначала должен выполнить скрипт, а затем продолжить отображать страницу - такое поведение называется "синхронным"
	<script src="..." async> - скрипт будет загружаться, параллельно с отображением страницы. Когда скрипт будет загружен, он выполнится. Имеет приоритет перед defer. IE9 не поддерживается.
	<script src="..." defer> - То же самое, что и async, но относительный порядок скриптов будет сохранен и скрипт сработает только когда весь документ будет обработан браузером

В имени переменной не долдно быть дефиса
Имя переменной, состоящее из нескольких слов, пишетсяВотТак.
Лучше хранить в переменной что-то одно, а для нового значения объявить новую

----Операторы
typeof x - оператор вернет тип переменной "x"
'1' + 1 = строка '11'. Остальные арифметические операторы всегда приводят операнды к числу
Унарный плюс приведет операнд к числу: +'1' = число 1
Оператор присваивания, еще и возвращает (подобно функции) то значение, которое присвоил переменной
	с = 3 - (а = 2 + 3); //в "с" запишется -2, а в "а" 5
	alert(a);
Оператор "заптая" - a = (5 + 3, 3 * 6). Каждое выражение вычисляется и отбрасывается, а последнее возращается

----Сравнение
Для корректного сравнения строк, они должны быть в одинаковом регистре
При сравнении значений разных типов, применяется ЧИСЛОВОЕ преобразование.
null и undefined равны друд другу и не равны больше ничему
Числовые преобразования:
	null -> 0
	undefined -> NaN

----Логические операторы
Несколько ИЛИ слева направо. При первом true, вся дальнейшая часть конструкции опускается. Возвращается то значение, на котором остановилось вычисление, не преобразованное к логическому типу.
Аналогично с логическим И, только он запинается на ЛЖИ
У логического И приоритет выше чем у ИЛИ, но Короткий Цикл вычислений все равно начинается с слева направо.
	alert( null || 2 && 3 || 4 ); // 3
		то же что и alert( null || (2 && 3) || 4 ), т.е. сначала проверится null, потом проверится 2 && 3 (а не только 2)

----Преобразование типов
строковое преобразование:
	alert() преобразовывает к строке
	String(val) - преобразование явным образом
	Так же оператор "+", у которого один из аргументов строка, преобразует и второй к строке
Численное преобразование:
	При сравнении данных различных типов (кроме операторов строгого стравнения)
	Number(val) - явное преобразование
	Преобразование унарным плюсом
	Численное преобразование типов: //undefined и null при сравнении "==", не приводятся к NaN и 0, а считаются равными
		+undefined //NaN
		+null //0
			null >= 0 //true
			null > 0 и null < 0 //false
		*Для избежания путанницы, лучше не давать специальным значениям учавствовать в сранении*
		+true //1
		+false //0
		+"string" //Пробельные символы по краям обрезаются. Если остается пустая строка, то получаем 0, если не пустая, то из нее считывается число. При ошибке получаем NaN
Логическое преобразование:
	!!value или Boolean(value) - явное логическое преобразование
	Преобразование типов:
		0, '', undefined, NaN, null -> false
		Все остальное, в т.ч. объекты -> true
if выполняет логическое преобразование

----Метки break/continue
break метка / continue метка - выйти из цикла. Ставится перед циклом, из которого необходимо выйти
	outer: //метка
	for(var i=0; i<100; i++){
		for(var j=0; j<100; j++){
			if(j = 98) break outer;
		}
	}
	alert('End of cycle');
	В данном коде произойдет выход из внешнего цикла (перед которым стоит метка) и управление передастся alert(). В случае с continue, вместо выхода, произойдет переход на следующую итерацию внешнего цикла.

----Конструкция switch
Если в кейсе нету брейка, то продолжится выполнение всех нижестоящих кейсов, без проверки условий.
Оператор switch делает строгую проверку (===).

----Функции
Если внутри функции объявить переменную (var) с таким же именем, как у внешней переменной, то внутрянняя переопределит внутри внешнюю переменную
Function Declaration создаются интерпретатором до выполнения кода
В режиме use strict Function Declaration видны только внутри блока кода, в котором объявлены
Еще один способ создания функций. Используется очень редко:
	var sum = new Function('a, b', 'return a+b') //1ый аргумент - параметры, 2й - тело
Значение, на котором заканчивается рекурсия, называют "базисом рекурсии".
Контекст функции - это служебная информация, которая включает в себя локальные переменные и место в цепочке команд, на котором произошел вызов функции.
При вложенных вызовах, контексты хранятся в специальной внутренней структуре данных - стеке контекстов. Для вложенной функции создается новый контекст, а контекст внешней записывается в стек. Когда выполнение вложенной функции завершено, ее контекст удаляется, из стека достается контекст внешней функции и ее выполнение возобновляется.
Именованные функциональные выражения (NFE):
	var f = function sayHi(...){ //имя sayHi доступно только ВНУТРИ самой функции.
		sayHi = 'text' //ошибка. Перезаписать это имя невозможно
	}
	Данное имя используется только для рекурсии
	Если Function Declaration обрамить в круглые скобки, то оно превратится в NFE
		var func = (function f(){...});




------------------------Качество кода------------------------------
----Отладка
debugger; - команда, заставившая отладчик остановиться на ней, как на брейкпойнте

----Советы по стилю кода
Между параметрами пробел
Пробел перед открывающей фигурной скобкой
Пробел после for
Пробелы вокруг операторов
Пустая строка между логическими блоками
else без перевода строки
Пробелы вокруг вложенного вызова функции
Одна функция = одно действие
В начале сложного скрипта архитектурный коментарий (или справочный перед функцией) в формате JSDoc


------------Автоматические тесты при помощи chai и mocha------------
BDD (Behavion Driven Development) = тесты + документация + примеры использования
Разработка функции pow(x, n):
	Сначала пишем спецификацию
		describe("pow", function() {
			it("Возводит в n-ю степень", function() {
				assert.equal(pow(2, 3), 8);
			});
		});

		describe(название, function() { ... }) - задает что именно мы описываем. Используется для группировки "рабочих лошадок" - блоков it.
		it(название, function() { ... }) - в названии человеческим языком описывается что должна делать функция, далее следует тест, который проверяет это.
		Код внутри it, если реализация верна, должен выполняться без ошибок.
		assert.equal(value1, value2) - сравнивает два значения.
	Поток разработки:
		1. Пишется спецификация, описывающая базовый функционал
		2. Делается начальная реализация
		3. Для проверки соответсвия спецификации используем фреймворк (в нашем случае Mocha) который запускает тесты it и выводит ошибки. При ошибках вносятся исправления
		4. Спецификафия расширяется, в нее добавляются возможности, которые, возможно, не поддерживаются реализацией.
		5. Идем в пункт 2 и расширяем реализацию. И так до конца.
	Mocha - содержит общие функции для тестирования, включая describe и it.
	Chai - содержит разнообразные функции для проверок (assert.equal())
	Sinon - для эмуляции и подмены функций "заглушками".

Запуск тестов инициируется командой mocha.run();
Результат тестирования будет выводиться в элемент <div id="mocha"></div>
Если в одном it несколько assert-ов и если один из них обнаружит ошибку, то он сразу же завершает выполнение блока it
Можно создавать отдельные подгруппы тестов, с помощью вложенных describe блоков
before(functions) / after(functions) - можно внутри describe создать блоки функций, которые будут выполнены, соответственно до и после it тестов
beforeEach(functions) / afterEach(functions) - аналогично предыдущим, но функции будут выполнены после каждого it теста
assert(выражение) - выдает ошибку, если выражение, при приведении к логическому типу, не true
assert.strictEqual(value1, value2) - проверка строгого равенства
assert.notEqual(value1, value2), assert.notStrictEqual(value1, value2) - проверка неравенства и строгого неравенства соответственно
assert.isTrue(value) - если value === t
assert.isFalse(value) - если value === false
assert.isNaN(value) - true если value === NaN



------------------------Структуры Данных----------------------------
string.length - длина строки
str.toUpperCase() - возвращает строку в верхнем регистре
num.toFixed(n) - округляет число num до n знаков после запятой, при необходимости, дополняя нулями. Возвращает результат в виде строки.

----Числа
Можно записывать числа в 16-ричной системе счисления, предварив число "0х"
num.toString(система счисления) - получить число в 16-чной системе, в виде строки. Основание системы может быть от 2 до 36
<number>e<quantity of zeroes> - "научный" формат записи числа
isNaN(num) - true, если num === NaN
isFinite(num) - true, если num не равно NaN/+-Infinity
parseInt(num)/parseFloat(num) - посимвольное преобразование строки в целые/дробные числа, пока это возможно. В случае ошибки, возвращается то, что получилось, иначе сразу NaN
Math.floor(num) - округляет вниз
Math.ceil(num) - округляет вверх
Math.round(num) - до ближайшего целого
~~num - двойное побитовое НЕ, обрезает дробную часть, делая число целым
	~~12.3 == 12
Подойдет так же ИСКЛЮЧАЮЩЕЕ ИЛИ с нулем
	12.3 ^ 0 == 12
num.toFixed(precission) - округляет num до точности precission. Возвращает результат в виде строки
num.toLoacleString() - форматированный вывод числа

----Строки
\uNNNN - символ в кодировке юникод, представленный кодом NNNN
str.indexOf(substr[, start_position]) - возвращает позицию искомой подстроки или -1
	if(~str.indexOf(...)) - оператор '~' эквивалентен -(n + 1). Т.е. ? если подстрока не найдена и возвращен -1, он автоматически превращается в 0 (-(-1 + 1)), что интерпретируется if'ом как false
Взятие подстроки:
	str.substring(start [, end]) - возвращиет подстроку со start по end (не включительно). Если end нету, то идет до конца строки. Отрицательные аргументы интерпретируются как равные 0. Слищком большие усекаются до длины строки. Если start > end, то аргументы меняются местами
	str.substr(start, [, length]) - аналогичен предыдущему, только lenght обозначает количество возвращаемых сиволов
	str.slice(start [, end]) - аналогичен substring(). При отрицательных аргументах отсчет идет с конца строки
String.fromCharCode(code) - получить символ, по его коду Unicode
str.charCodeAt(pos) - возвращает код символа на позиции pos
str.localeCompare(str2) - корректное сравнение строк разных языков

----Объекты
Создание объекта:
	o = new Object(); или o = {};
Удалить свойство:
	delete obj.property;
Проверка на существование свойства:
	if("propertyName" in object_name)
obj.["property"] - доступ к свойству объекта через квадратные скобки
Объекты могут быть вложенными
Перебор свойств:
	for(var key in obj){ //если key числовая строка, то такие свойства, при переборе, сортируются как числа.
		console.log(obj[key]) //доступ через квадратные скобки
	}

----Массивы
Удаление/Добавление элементов:
	arr.pop() - удаляет последний элемент из масива
	arr.push(elem) - добавляет элемент в конец массива
	arr.shift() - удаляет первый элемент массива
	arr.unshift(elem) - добавляет элемент в начало массива
	Можно так же удалять элемент оператором delete
	arr.length = 0 - очистить массив
	arr.splice(index [, deleteCount, elem1, ..., elemnN]) - удалить deleteCount элементов, начиная с номера index, а затем вставить на их место elem1, ..., elemN. Возвращает массив из удаленных элементов. 
	arr.concat(value1, ... valueN) - присоединяет к концу массива переданные элементы. Можно так же передать массив.
Взятие подмассивов:
	str.split(s [, qty]) - разбивает строку по разделителю s на массив. qty - ограничение на количество элементов вмассиве.
	arr.join(str) - создает из массива строку, разделяя элементы str
	Если номер отрицательный, то отсчет начинается с конца
	all.slice(start, end) - копирует участок массива, со start по end (не включительно). Если end не указан, то копирование будет до конца массива. Отрицательные индексы - отсчет с конца. Вообще без аргументов - скопируется весь массив
Сортировка:
	arr.sort(fn) - сортировка элементов массива. По умолчанию сортирует, преобразовывая элементы к строке.
		fn - функция, принимающая 2 аргумента - сравниваемые элементы. Если функция возвращает положительное значение, то элементы меняются местами.
	arr.reverse() - меняет порядок элементов на обратный
arr.indexOf(elem [, fromIndex]) - возвращает индекс элемента elem или -1, начиная поиск с позиции fromIndex. Для поиска используется строгое стравнение
arr.lastIndexOf(elem [, fromIndex]) - аналогично предыдущему, только начинает поиск с конца.
Object.keys(obj) - возвращает массив ключей объекта
Перебирающие методы:
	arr.forEach(callback, context) - для каждого элемента вызывается функция callback(item, i, arr)
		item - текущий элемент массива
		i - его индекс
		arr - массив, который перебирается
	arr.filter(callback) - создает новый массив с теми элементами, для которых callback(item, i, arr) вернет true
	arr.map(callback) - создает новый массив, с возвращенными результатами callback(item, i, arr), после работы с каждым элементом
	arr.every(callback) - возвращает true, если callback(item, i, arr) вернул true для каждого элемента в массиве
	arr.some(callback) - возвращает true, если callback(item, i, arr) вернул true хотябы для одного элемента в массиве
	arr.reduce(callback [, initialValue]) - применяет callback(previousValue, currentItem, index, arr) к каждому элементу массива, сохраняя промежуточный результат вычислений
		previousValue - последний результат работы метода. Он же "промежуточный результат"
		currentItem - текущий элемента массива, элементы перебираются по очереди, слева направо
		index - номер текущего элемента
		arr - массив который перебираются
		initialValue - начальное значение промежуточного результата. Если этот аргумент не передан, то оно равно первому элементу массива, а перебор осуществляется со второго
	arr.reduceRight() - все аналогично arr.reduce(), но перебор справаналево
Псевдомассив arguments - объект с числовыми ключами и имеющий свойство length. Его значения отвязаны от параметров и не влюяют друг на друга.
Когда очень много параметров, можно в качестве аргумента, передать в функцию объект, свойства которого будут хранить необходимые значения

----Дата и время
Создание даты:
	new Date() - создать объект Date, с текущей датой и временем
	new Date(milliseconds) - создает объект в котором milliseconds миллисекунд, которые считаются прошедшими с 01.01.1970
	new Date(datestring) - Если единственный аргумент - строка, то надо использовать Date.parse для чтения даты из нее
	new Date(year, month, date, hours, minutes, seconds, ms) -  создать дату
		первые 2 аргумента обязательны
		year должен состоять из 4х цифр
		отсутствующие параметры, начиная с hours, считаются равными 0, а date единице
		Номер месяца начинается с 0
		Номер дня в месяце начинается с единицы
Получение компонентов даты:
	getFullYear() - получить год (из 4 цифр)
	getMonth() - получить месяц (от 0 до 11)
	getDate() - получить число дня месяца (от 1 до 31)
	getHours(), getMinutes(), getSeconds(), getMilliseconds() - получить соответствующие компоненты
	getDay() - получить номер дня недели, начиная с воскресения (от 0 до 6)
	getTime() - возвращает количество миллисекунд с 01.01.1970
	getTimezoneOffset() - возвращает разницу между текущей и UTC зонами в минутах
	Все методы возвращают значения для местной временной зоны
	В UTC вариантах все то же самое, только в названиях методов, после "get" ставится "UTC" (getUTCMonth())
Установка компонетов даты:
	setFullYear(year [, month, date])
	setMonth(month [, date])
	setDate(date)
	setHours(hours [, min, sec, ms])
	setMinutes(min [, sec, ms])
	setSeconds(sec [, ms])
	setMilliseconds(ms)
	setTime(ms) - устанавливает всю дату по миллисекундам
	Все методу, кроме setTime() обладают UTC вариантом
	Date автоматически исправляет дату. 32 марта станет 1 апреля. Можно просто прибавлять количество дней к текущему значению
Date в числовом контексте преобразуется в количество миллисекунд. Эти значения можно подвергать арифметическим операциям
Бенчмаркинг:
	performance.now() - возаратит время от момента выгрузки предыдущей страницы из памяти, до места в коде, где этот метод вызван
	console.time(метка) - включить внутренний хронометр браузера. Метка предназначена для идентификации замера
	console.timeEnd(метка) - выключить внутренний хронометр браузера и вывести результат
Форматированный вывод дат:
	toString(), toTimeString(), toDateString() - возвращает стандартное строчное представление, зависящее от браузера. Имеют UTC аналоги
Разбор строки, Date.parse:
	Формат ISO 8601 Extended: YYYY-MM-DDTHH:mm:ss:sssZ:
		YYYY - год
		MM - месяц
		T - обычный символ. Используется как разделитель
		HH:ss:sss - часы, секунды, миллисекунды соответственно
		Z - временная зона в формате +-hh:mm
	Date.parse(str) - разбирает строку в вышеуказанном формате и возвращает количество мс. Иначе возвращает NaN
Date.now() - вернет текущую дату в миллисекундах
----[[Scope]] для new Function
При создании функции через new Function, ее внутреннее свойство [[Scope]] будет указывать всегда на window, а значит такие функции не могут использовать замыкание
Минификатор переименовывает все локальные переменные на более которкие имена



------------------------Замыкания, область видимости----------------------------
----Глобальный объект
Все глобальные функции и переменные являются свойствами глобального объекта window
Во время инициализации скрипта, функции, объявленные как Function Declaration, создаются сразу работающими, а var-переменные = undefined
Тела конструкций (и блоки инициализации счечиков в циклах) if, while, for, switch и т.п. не влияют на область видимости.
----Замыкания функции
Замыкание - это все внешние переменные, которые доступны функции.
Все переменные внутри функции = это свойства специального внутреннего объекта LexicalEnvironment, который создается при ее запуске.
После выполнения функции, LexicalEnvironment удаляется из памяти.
При обращении к переменной, остутствующей в текущем LexicalEnvironment, интерпритатор ищет ее объявление во внешнем окружении.
В каждом окружении есть свойство-ссылка [[Scope]], которое ссылается на родительское окружение.
[[Scope]] закрыто от прямого доступа.
[[Scope]] никогда не меняется, всюду храня ссылку на окружение в котором она была создана
Функции в JavaScript являются объектом, поэтому можно создавать свойства и у них
	f.test = 5;
	Это свойство так же будет привязано к функции. Отличие от переменной внешнего окружения лишь в том. что свойство можно изменить из внешнего кода, где доступен объект функции:
		f();
		f.test = 7;
----[[Scope]] для new Function
Функции, создаваемые через new Function, имеют значением [[Scope]] не внешний объект переменных, а window
Следствие – такие функции не могут использовать замыкание. Но это хорошо, так как бережёт от ошибок проектирования, да и при сжатии JavaScript проблем не будет. Если же внешние переменные реально нужны – их можно передать в качестве параметров.
----Модули через замыкания
Модуль - подключаемый в html-странице скрипт, в котором весь код заключен в одну функцию.
Сделано так для того, чтобы изолировать его содержимое от "внешнего мира" и избежать конфликта имен
(function() {
	...code...
})() - с помощью FE создается функция и сразу вызывается
Во вне, значения экспортируются двумя способами:
	1) return <var_name>;
	2) window.<var_name> = <value>;
----Управление памятью в JavaScript
Удаление неиспользуемых объектов происходит сборщиком мусора
Критерий выбора объекта для удаления основывается на условии недостижимости кода - когда нет ни одной ссылки на объект
----Устаревшая конструкция with
with(obj) {
	...code...
} - внутри блока в качестве области видимости используется объект obj. Не создает собственной области видимости
Интерпритатор сначала ищет область видимости внутри блока и только потом поиск продолжает во вне
С use strict не работает
Отказались от данной конструкции потому что минификаторы плохо ее обрабатывают и она делает выполнение кода более ресурсоемким
Вместо данной конструкции лучше использовать временную переменную
	var s = elem.style;
	s.top = "10px";
	s.left = "0";


-----------------------------Методы объектов и контекст вызова-----------------------------------
----Методы объектов, this















--------------------Стандартные функции JS-------------------------
result = prompt(title, default) - выводит модальное окно, с тектсом title и текстовым полем, заполненным изначально default. Возвращает введенное пользователем значение или null, в случае отмены ввода.
result = confirm(question) - выводит модальное окно с вопросом question и возвращает true, в случае нажатия OK, иначе false
>>>>>>> 14db96d1f038d7f326463e2133af81aedcc70552
