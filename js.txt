*************************************************Часть 1*************************************************

-------------------------Введение--------------------------------
Спецификафия языка называется ECMAScript
babel.js - транслятор, который транслирует JS-код, в код более старого стандарта

----Справочники и спецификации
	Mozilla Developer Network - https://developer.mozilla.org/
	MSDN - http://msdn.microsoft.com/ //полезна при разработке под IE
	Safari Developer Library - https://developer.apple.com/library/safari/navigation/index.html
	https://kangax.github.io/compat-table – таблица с обзором поддержки спецификации ECMAScript различными платформами.
	ECMAScript спецификация - http://www.ecma-international.org/publications/standards/Ecma-262.htm


----------------------Основы JavaScript---------------------------
Скрипты можно вставить в любое место html с помощью тега <script>
<meta charset="utf-8"> - тег, для корректного отображения текста в браузере

Современная разметка для <script>
	Атрибут type="text/javascript" - был обязателен в HTML4
	Атрибут language=... - по умолчанию язык - JavaScript

----Подключенные скрипты. Порядок исполнения
Браузер скачает скрипт только первый раз, а затем закеширует его
По умолчанию браузер сначала должен выполнить скрипт, а затем продолжить отображать страницу - такое поведение называется "синхронным"
	<script src="..." async> - скрипт будет загружаться, параллельно с отображением страницы. Когда скрипт будет загружен, он выполнится. Имеет приоритет перед defer. IE9-  не поддерживается.
	<script src="..." defer> - То же самое, что и async, но относительный порядок скриптов будет сохранен и скрипт сработает только когда весь документ будет обработан браузером

В имени переменной не долдно быть дефиса
Имя переменной, состоящее из нескольких слов, пишетсяВотТак.
Лучше хранить в переменной что-то одно, а для нового значения объявить новую

----Операторы
typeof x - оператор вернет тип переменной "x"
'1' + 1 = строка '11'. Остальные арифметические операторы всегда приводят операнды к числу
Унарный плюс приведет операнд к числу: +'1' = число 1
Оператор присваивания, еще и возвращает (подобно функции) то значение, которое присвоил переменной
	с = 3 - (а = 2 + 3); //в "с" запишется -2, а в "а" 5
	alert(a);
Оператор "заптая" - a = (5 + 3, 3 * 6). Каждое выражение вычисляется и отбрасывается, а последнее возращается

----Сравнение
Для корректного сравнения строк, они должны быть в одинаковом регистре
При сравнении значений разных типов, применяется ЧИСЛОВОЕ преобразование.
null и undefined равны друг другу и не равны больше ничему
Числовые преобразования:
	null -> 0
	undefined -> NaN

----Логические операторы
Несколько ИЛИ слева направо. При первом true, вся дальнейшая часть конструкции опускается. Возвращается то значение, на котором остановилось вычисление, не преобразованное к логическому типу.
Аналогично с логическим И, только он запинается на ЛЖИ
У логического И приоритет выше чем у ИЛИ, но Короткий Цикл вычислений все равно начинается с слева направо.
	alert( null || 2 && 3 || 4 ); // 3
		то же что и alert( null || (2 && 3) || 4 ), т.е. сначала проверится null, потом проверится 2 && 3 (а не только 2)

----Преобразование типов
строковое преобразование:
	alert() преобразовывает к строке
	String(val) - преобразование явным образом
	Так же оператор "+", у которого один из аргументов строка, преобразует и второй к строке
Численное преобразование:
	При сравнении данных различных типов (кроме операторов строгого стравнения)
	Number(val) - явное преобразование
	Преобразование унарным плюсом
	Численное преобразование типов: //undefined и null при сравнении "==", не приводятся к NaN и 0, а считаются равными
		+undefined //NaN
		+null //0
			null >= 0 //true
			null > 0 и null < 0 //false
		*Для избежания путанницы, лучше не давать специальным значениям учавствовать в сранении*
		+true //1
		+false //0
		+"string" //Пробельные символы по краям обрезаются. Если остается пустая строка, то получаем 0, если не пустая, то из нее считывается число. При ошибке получаем NaN
Логическое преобразование:
	!!value или Boolean(value) - явное логическое преобразование
	Преобразование типов:
		0, '', undefined, NaN, null -> false
		Все остальное, в т.ч. объекты -> true
if выполняет логическое преобразование

----Метки break/continue
break метка / continue метка - выйти из цикла. Ставится перед циклом, из которого необходимо выйти
	outer: //метка
	for(var i=0; i<100; i++){
		for(var j=0; j<100; j++){
			if(j = 98) break outer;
		}
	}
	alert('End of cycle');
	В данном коде произойдет выход из внешнего цикла (перед которым стоит метка) и управление передастся alert(). В случае с continue, вместо выхода, произойдет переход на следующую итерацию внешнего цикла.

----Конструкция switch
Если в кейсе нету брейка, то продолжится выполнение всех нижестоящих кейсов, без проверки условий.
Оператор switch делает строгую проверку (===).

----Функции
Если внутри функции объявить переменную (var) с таким же именем, как у внешней переменной, то внутрянняя переопределит внутри внешнюю переменную
Function Declaration создаются интерпретатором до выполнения кода
В режиме use strict Function Declaration видны только внутри блока кода, в котором объявлены
Еще один способ создания функций. Используется очень редко:
	var sum = new Function('a, b', 'return a+b') //1ый аргумент - параметры, 2й - тело
Значение, на котором заканчивается рекурсия, называют "базисом рекурсии".
Контекст функции - это служебная информация, которая включает в себя локальные переменные и место в цепочке команд, на котором произошел вызов функции.
При вложенных вызовах, контексты хранятся в специальной внутренней структуре данных - стеке контекстов. Для вложенной функции создается новый контекст, а контекст внешней записывается в стек. Когда выполнение вложенной функции завершено, ее контекст удаляется, из стека достается контекст внешней функции и ее выполнение возобновляется.
Именованные функциональные выражения (NFE):
	var f = function sayHi(...){ //имя sayHi доступно только ВНУТРИ самой функции.
		sayHi = 'text' //ошибка. Перезаписать это имя невозможно
	}
	Данное имя используется только для рекурсии
	Если Function Declaration обрамить в круглые скобки, то оно превратится в NFE
		var func = (function f(){...});



------------------------Качество кода------------------------------
----Отладка
debugger; - команда, заставившая отладчик остановиться на ней, как на брейкпойнте

----Советы по стилю кода
Между параметрами пробел
Пробел перед открывающей фигурной скобкой
Пробел после for
Пробелы вокруг операторов
Пустая строка между логическими блоками
else без перевода строки
Пробелы вокруг вложенного вызова функции
Одна функция = одно действие
В начале сложного скрипта архитектурный коментарий (или справочный перед функцией) в формате JSDoc


------------Автоматические тесты при помощи chai и mocha------------
BDD (Behavion Driven Development) = тесты + документация + примеры использования
Разработка функции pow(x, n):
	Сначала пишем спецификацию
		describe("pow", function() {
			it("Возводит в n-ю степень", function() {
				assert.equal(pow(2, 3), 8);
			});
		});

		describe(название, function() { ... }) - задает что именно мы описываем. Используется для группировки "рабочих лошадок" - блоков it.
		it(название, function() { ... }) - в названии человеческим языком описывается что должна делать функция, далее следует тест, который проверяет это.
		Код внутри it, если реализация верна, должен выполняться без ошибок.
		assert.equal(value1, value2) - сравнивает два значения.
	Поток разработки:
		1. Пишется спецификация, описывающая базовый функционал
		2. Делается начальная реализация
		3. Для проверки соответсвия спецификации используем фреймворк (в нашем случае Mocha) который запускает тесты it и выводит ошибки. При ошибках вносятся исправления
		4. Спецификафия расширяется, в нее добавляются возможности, которые, возможно, не поддерживаются реализацией.
		5. Идем в пункт 2 и расширяем реализацию. И так до конца.
	Mocha - содержит общие функции для тестирования, включая describe и it.
	Chai - содержит разнообразные функции для проверок (assert.equal())
	Sinon - для эмуляции и подмены функций "заглушками".

Запуск тестов инициируется командой mocha.run();
Результат тестирования будет выводиться в элемент <div id="mocha"></div>
Если в одном it несколько assert-ов и если один из них обнаружит ошибку, то он сразу же завершает выполнение блока it
Можно создавать отдельные подгруппы тестов, с помощью вложенных describe блоков
before(functions) / after(functions) - можно внутри describe создать блоки функций, которые будут выполнены, соответственно до и после it тестов
beforeEach(functions) / afterEach(functions) - аналогично предыдущим, но функции будут выполнены после каждого it теста
assert(выражение) - выдает ошибку, если выражение, при приведении к логическому типу, не true
assert.strictEqual(value1, value2) - проверка строгого равенства
assert.notEqual(value1, value2), assert.notStrictEqual(value1, value2) - проверка неравенства и строгого неравенства соответственно
assert.isTrue(value) - если value === t
assert.isFalse(value) - если value === false
assert.isNaN(value) - true если value === NaN



------------------------Структуры Данных----------------------------
string.length - длина строки
str.toUpperCase() - возвращает строку в верхнем регистре

----Числа
Можно записывать числа в 16-ричной системе счисления, предварив число "0х"
num.toString(система счисления) - получить число в 16-чной системе, в виде строки. Основание системы может быть от 2 до 36
<number>e<quantity of zeroes> - "научный" формат записи числа
isNaN(num) - true, если num === NaN
isFinite(num) - true, если num не равно NaN/+-Infinity
parseInt(num)/parseFloat(num) - посимвольное преобразование строки в целые/дробные числа, пока это возможно. В случае ошибки, возвращается то, что получилось, иначе сразу NaN
Math.floor(num) - округляет вниз
Math.ceil(num) - округляет вверх
Math.round(num) - до ближайшего целого
~~num - двойное побитовое НЕ, обрезает дробную часть, делая число целым
	~~12.3 == 12
Подойдет так же ИСКЛЮЧАЮЩЕЕ ИЛИ с нулем
	12.3 ^ 0 == 12
num.toFixed(precission) - округляет num до точности precission. Возвращает результат в виде строки
num.toLoacleString() - форматированный вывод числа

----Строки
\uNNNN - символ в кодировке юникод, представленный кодом NNNN
str.indexOf(substr[, start_position]) - возвращает позицию искомой подстроки или -1
	if(~str.indexOf(...)) - оператор '~n' эквивалентен -(n + 1). Т.е. если подстрока не найдена и возвращен -1, он автоматически превращается в 0 (-(-1 + 1)), что интерпретируется if'ом как false
Взятие подстроки:
	str.substring(start [, end]) - возвращиет подстроку со start по end (не включительно). Если end нету, то идет до конца строки. Отрицательные аргументы интерпретируются как равные 0. Слишком большие усекаются до длины строки. Если start > end, то аргументы меняются местами
	str.substr(start, [, length]) - аналогичен предыдущему, только lenght обозначает количество возвращаемых сиволов
	str.slice(start [, end]) - аналогичен substring(). При отрицательных аргументах отсчет идет с конца строки. Если end > start, возвращается пустая строка.
String.fromCharCode(code) - получить символ, по его коду Unicode
str.charCodeAt(pos) - возвращает код символа на позиции pos
str.localeCompare(str2) - корректное сравнение строк разных языков

----Объекты
Создание объекта:
	o = new Object(); или o = {};
Удалить свойство:
	delete obj.property;
Проверка на существование свойства:
	if("propertyName" in object_name)
object_name["property"] - доступ к свойству объекта через квадратные скобки
Объекты могут быть вложенными
Перебор свойств:
	for(var key in obj){ //если key числовая строка, то такие свойства, при переборе, сортируются как числа.
		console.log(obj[key]) //доступ через квадратные скобки
	}

----Массивы
Удаление/Добавление элементов:
	arr.pop() - удаляет последний элемент из масива
	arr.push(elem) - добавляет элемент в конец массива. Возвращает добавленный элемент
	arr.fill(start, end) - заполнить массив элементами со значениями от start до end, с шагом 1;
	arr.shift() - удаляет первый элемент массива
	arr.unshift(elem) - добавляет элемент в начало массива
	Можно так же удалять элемент оператором delete
	arr.length = 0 - очистить массив
	arr.splice(index [, deleteCount, elem1, ..., elemnN]) - удалить deleteCount элементов, начиная с номера index, а затем вставить на их место elem1, ..., elemN. Возвращает массив из удаленных элементов.
		Если index < 0 - отсчет с конца строки
		Если deleteCount < 0, или другое недопустимое значение - считается равным 0
	arr.concat(value1, ... valueN) - присоединяет к концу массива переданные элементы. Можно так же передать массив. Возвращает результат, не изменяя arr.
Взятие подмассивов:
	str.split(s [, qty]) - разбивает строку по разделителю s на массив. qty - ограничение на количество элементов вмассиве. Возвразает результат.
	arr.join(str) - создает из массива строку, разделяя элементы str. Возвращает результат.
	Если номер отрицательный, то отсчет начинается с конца
	all.slice(start, end) - копирует участок массива, со start по end (не включительно). Если end не указан, то копирование будет до конца массива. Отрицательные индексы - отсчет с конца. Вообще без аргументов - скопируется весь массив
Сортировка:
	arr.sort(fn) - сортировка элементов массива. По умолчанию сортирует, преобразовывая элементы к строке.
		fn - функция, принимающая 2 аргумента - сравниваемые элементы. Если функция возвращает положительное значение, то элементы меняются местами.
	arr.reverse() - меняет порядок элементов на обратный
arr.indexOf(elem [, fromIndex]) - возвращает индекс элемента elem или -1, начиная поиск с позиции fromIndex. Для поиска используется строгое стравнение
arr.lastIndexOf(elem [, fromIndex]) - аналогично предыдущему, только начинает поиск с конца.
Object.keys(obj) - возвращает массив ключей объекта
Перебирающие методы:
	arr.forEach(callback, context) - для каждого элемента вызывается функция callback(item, i, arr)
		item - текущий элемент массива
		i - его индекс
		arr - массив, который перебирается
	arr.filter(callback) - создает новый массив с теми элементами, для которых callback(item, i, arr) вернет true
	arr.map(callback) - создает новый массив, с возвращенными результатами callback(item, i, arr), после работы с каждым элементом
	arr.every(callback) - возвращает true, если callback(item, i, arr) вернул true для каждого элемента в массиве
	arr.some(callback) - возвращает true, если callback(item, i, arr) вернул true хотябы для одного элемента в массиве
	arr.reduce(callback [, initialValue]) - применяет callback(previousValue, currentItem, index, arr) к каждому элементу массива, сохраняя промежуточный результат вычислений
		previousValue - последний результат работы метода. Он же "промежуточный результат"
		currentItem - текущий элемента массива, элементы перебираются по очереди, слева направо
		index - номер текущего элемента
		arr - массив который перебираются
		initialValue - начальное значение промежуточного результата. Если этот аргумент не передан, то оно равно первому элементу массива, а перебор осуществляется со второго
	arr.reduceRight() - все аналогично arr.reduce(), но перебор справаналево
Псевдомассив arguments - объект с числовыми ключами и имеющий свойство length. Его значения отвязаны от параметров и не влюяют друг на друга.
Когда очень много параметров, можно в качестве аргумента, передать в функцию объект, свойства которого будут хранить необходимые значения

----Дата и время
Создание даты:
	new Date() - создать объект Date, с текущей датой и временем
	new Date(milliseconds) - создает объект в котором milliseconds миллисекунд, которые считаются прошедшими с 01.01.1970
	new Date(datestring) - Если единственный аргумент - строка, то надо использовать Date.parse для чтения даты из нее
	new Date(year, month, date, hours, minutes, seconds, ms) -  создать дату
		первые 2 аргумента обязательны
		year должен состоять из 4х цифр
		отсутствующие параметры, начиная с hours, считаются равными 0, а date единице
		Номер месяца начинается с 0
		Номер дня в месяце начинается с единицы
Получение компонентов даты:
	getFullYear() - получить год (из 4 цифр)
	getMonth() - получить месяц (от 0 до 11)
	getDate() - получить число дня месяца (от 1 до 31)
	getHours(), getMinutes(), getSeconds(), getMilliseconds() - получить соответствующие компоненты
	getDay() - получить номер дня недели, начиная с воскресения (от 0 до 6)
	getTime() - возвращает количество миллисекунд с 01.01.1970
	getTimezoneOffset() - возвращает разницу между текущей и UTC зонами в минутах
	Все методы возвращают значения для местной временной зоны
	В UTC вариантах все то же самое, только в названиях методов, после "get" ставится "UTC" (getUTCMonth())
Установка компонетов даты:
	setFullYear(year [, month, date])
	setMonth(month [, date])
	setDate(date)
	setHours(hours [, min, sec, ms])
	setMinutes(min [, sec, ms])
	setSeconds(sec [, ms])
	setMilliseconds(ms)
	setTime(ms) - устанавливает всю дату по миллисекундам
	Все методу, кроме setTime() обладают UTC вариантом
	Date автоматически исправляет дату. 32 марта станет 1 апреля. Можно просто прибавлять количество дней к текущему значению
Date в числовом контексте преобразуется в количество миллисекунд. Эти значения можно подвергать арифметическим операциям
Бенчмаркинг:
	performance.now() - возаратит время от момента выгрузки предыдущей страницы из памяти, до места в коде, где этот метод вызван
	console.time(метка) - включить внутренний хронометр браузера. Метка предназначена для идентификации замера
	console.timeEnd(метка) - выключить внутренний хронометр браузера и вывести результат
Форматированный вывод дат:
	toString(), toTimeString(), toDateString() - возвращает стандартное строчное представление, зависящее от браузера. Имеют UTC аналоги
	date.toLocaleString(locale, {options}) - возможны другие варианты использования. Показано использование только для форматированного вывода даты.
		locale = "ru";
		options = {
			weekday: "narrow"/"short"/"long",
			era: "narrow"/"short"/"long",
			year: "numeric"/"2-digit",
			month: "numeric"/"2-digit",
			day: "numeric"/"2-digit",
			hour: "numeric"/"2-digit",
			minute: "numeric"/"2-digit",
			second: "numeric"/"2-digit",
			timeZoneName: "short"/"long"
		}
Разбор строки, Date.parse:
	Формат ISO 8601 Extended: YYYY-MM-DDTHH:mm:ss:sssZ:
		YYYY - год
		MM - месяц
		T - обычный символ. Используется как разделитель
		HH:ss:sss - часы, секунды, миллисекунды соответственно
		Z - временная зона в формате +-hh:mm
	Date.parse(str) - разбирает строку в вышеуказанном формате и возвращает количество мс. Иначе возвращает NaN
Date.now() - вернет текущую дату в миллисекундах
----[[Scope]] для new Function
При создании функции через new Function, ее внутреннее свойство [[Scope]] будет указывать всегда на window, а значит такие функции не могут использовать замыкание
Минификатор переименовывает все локальные переменные на более которкие имена



------------------------Замыкания, область видимости----------------------------
----Глобальный объект
Все глобальные функции и переменные являются свойствами глобального объекта window
Во время инициализации скрипта, функции, объявленные как Function Declaration, создаются сразу работающими, а var-переменные = undefined
Тела конструкций (и блоки инициализации счечиков в циклах) if, while, for, switch и т.п. не влияют на область видимости.
----Замыкания функции
Замыкание - это все внешние переменные, которые доступны функции.
Все переменные внутри функции = это свойства специального внутреннего объекта LexicalEnvironment, который создается при ее запуске.
После выполнения функции, LexicalEnvironment удаляется из памяти.
При обращении к переменной, остутствующей в текущем LexicalEnvironment, интерпритатор ищет ее объявление во внешнем окружении.
В каждом окружении есть свойство-ссылка [[Scope]], которое ссылается на родительское окружение.
[[Scope]] закрыто от прямого доступа.
[[Scope]] функции никогда не меняется, всюду храня ссылку на окружение в котором она была создана
Функции в JavaScript являются объектом, поэтому можно создавать свойства и у них
	f.test = 5;
	Это свойство так же будет привязано к функции. Отличие от переменной внешнего окружения лишь в том. что свойство можно изменить из внешнего кода, где доступен объект функции:
		f();
		f.test = 7;
----[[Scope]] для new Function
Функции, создаваемые через new Function, имеют значением [[Scope]] не внешний объект переменных, а window
Следствие – такие функции не могут использовать замыкание. Но это хорошо, так как бережёт от ошибок проектирования, да и при сжатии JavaScript проблем не будет. Если же внешние переменные реально нужны – их можно передать в качестве параметров.
----Модули через замыкания
Модуль - подключаемый в html-странице скрипт, в котором весь код заключен в одну функцию.
Сделано так для того, чтобы изолировать его содержимое от "внешнего мира" и избежать конфликта имен
(function() {
	...code...
})() - с помощью FE создается функция и сразу вызывается
Во вне, значения экспортируются двумя способами:
	1) return <var_name>;
	2) window.<var_name> = <value>;
----Управление памятью в JavaScript
Удаление неиспользуемых объектов происходит сборщиком мусора
Критерий выбора объекта для удаления основывается на условии недостижимости кода - когда нет ни одной ссылки на объект
----Устаревшая конструкция with
with(obj) {
	...code...
} - внутри блока в качестве области видимости используется объект obj. Не создает собственной области видимости
Интерпритатор сначала ищет область видимости внутри блока и только потом поиск продолжает во вне
С use strict не работает
Отказались от данной конструкции потому что минификаторы плохо ее обрабатывают и она делает выполнение кода более ресурсоемким
Вместо данной конструкции лучше использовать временную переменную
	var s = elem.style;
	s.top = "10px";
	s.left = "0";


-----------------------------Методы объектов и контекст вызова-----------------------------------
----Методы объектов, this
Для доступа к данным текущего объекта, используется ключевое слово this хранящее ссылку на него
Значение this называется контекстом вызова
Значение this определяется во время выполнения кода
	function f() {
		alert(this.name);
	}
	var one = {name: "Vasya"};
	var two = {name: "Petya"};
	one.f = f; //Значени this будет разным
	two.g = f;
	one.f(); //"Vasya"
	two.g(); //"Petya"
Чтобы контекст передался, нужно вызвать функцию через точку.
Если код функции возвращается каким-либо другим оператором, кроме точки, то контекст изначального объекта теряется.
Возвращать ссылку this на объект может только его собственный МЕТОД. Если попытаться обратиться к СВОЙСТВУ, хранящему this, то контекст теряется
Функция получает контекст только родительского объекта. Иными словами, this внутри функции ссылается только на родительский объект
Объект получает контекст самого первого предка (в браузере это window). Другими словами this в объекте на любом уровне вложенности равен window
Если объявить переменную, внутри функции, через var, то она станет свойством LexicalEnvironment, который удаляется после выполнения функции.
Если же переменную объявить как свойство самой функции (как объкта), то ее значение будет закреплено за ней.

----Преобразование объектов: toString(), valueOf()
Объект преобразовывается в примитив:
	Строковое преобразование - если объект выводится через alert(obj);
		Стандартное представление пользовательского объекта в виде строки "[object Object]"
		Если в объекте присутствует метод toString, то он используется для преобразования
			var obj = {
				name: "Vasya",
				toString: function() {
					return "User " + this.name;
				}
			}
			alert(obj); // "User Vasya"
			Большинство объектов имеют внутреннюю реализацию toString
	Численное преобразование - при арифметических операциях, сравнении с примитивом;
		Для численного преобразования объекта используется метод valueOf, а если его нет, то toString
		У большинства объектов нет valueOf
		Проверка равенства между объектом и примитивом вызывает численное преобразование объекта
	Логическое преобразование - при if(obj) и других логических операциях
		Любой объект в логическом преобразовании true, даже пустой массив [] или объект {}
	Методы toString и valueOf обязаны возвращать примитивный тип, иначе они будут проигнорированы
У объектов Date, метод valueOf возвращает количество миллисекунд, а toString строку с датой. Однако оператор "+" использует у них метод toString, хотя должен valueOf.
Если фигурные скобки {} идут не в выражении, то они считаются блоком кода

----Создание объектов через new
При создании объекта через new, вызывается функция-конструктор.
	function Animal(arg) { //конструкторы принято называть с большой буквы
		this.a = arg;
		this.b = arg + 2;
	}
	var tiger = new Animal(1);

	this получает ссылку на создаваемый объект
	создаются свойства и методы
	возвращается this
Если в конструкторе есть return
	При вызове return <object>, будет возвращён <object>, а не this.
	При вызове return с примитивным значением, оно будет отброшено.
В конструкторе можно объявлять локальные переменные и вспомогательные функции. В объект попадет только то, что определяется через this

----Дескрипторы, геттеры и сеттеры свойств
Основной метод для управления свойствами – Object.defineProperty.
	Object.defineProperty(obj, "prop", descriptor)
		obj - имя объекта
		"prop" - имя свойсвта в двойных кавычках
		descriptor - объект имеющий следующие свойства
			value - значение свойства. По умолчанию undefined
			writable - можно ли менять значение свойтсва. По умолчанию false
			configurable - можно ли удалять свойтсва (при помощи оператора delete) или изменять при помощи новых вызовов defineProerty. По умолчанию false
			enumerable - будет ли перечисляться свойство циклом for...in и войдет ли в массив, возвращаемый Object.keys(). По умолчанию false
			get - функция, которая возвращает значение свойства. По умолчанию undefined
				Object.defineProerty(o, "value", {
					get: function() { //можно объявить как свойство дескриптора
						return "Hello";
					}
				}); // Теперь при обращении o.value, при чем без скобок, будет вызываться код функции get()
			set - функции, для установки значения свойства. По умолчанию undefined
					set: function(val) {
						this.value = val;
					}
				}); //Работа функции set
	Запрещено одновременно указывать value или writable совместно с get/set
Можно так же создать get/set прямо в определении объекта
	var o = {
		name: "Vasya",
		surname: "Pupkin",
		
		get fullName() { //или объявить в самом объекте, прописав соответствующее ключевое слово, вместо function
			return this.name + " " + this.surname;
		}
		set fullName(value) {
			var split = value.split(" ");
			this.name = split[0];
			this.surname = split[1];
		}
	}
Другие методы работы со свойствами
	Object.defineProperties(obj, descriptors) - позволяет объявить несколько свойств сразу
		Object.defineProperties(user, { //объект свойства которого названы как свойства в изменяемом объекте. Тут в них записывается объект с дескриптором
			propertyName: {
				...descriptor...
			},
			secondProperty: {
				...descriptor...
			},
			...
		})
Object.keys(obj) - возвращает только enumerable свойства
object.getOwnPropertyNames(obj) - возвращает все свойства
Object.getOwnPropertyDescriptor(obj, propName) - возвращает дескриптор указанного свойства
Object.preventExtensions(obj) - запретить добавление новых свойств в объект
object.seal(obj) - запрещает добавление и удаление свойств, все текущие свойства делает configurable: false
Object.freeze(obj) - всем свойствам делает writable: false, configurable: false
Object.isExtensible(obj) - возвращает false, если добавление свойствв объект было запрешено вызовом preventEtensions
Object.isSealed(obj) - true, если у свойств configurable: false
Object.isFrozen(obj) - true, если у свойств configurable: false, writable: false

----Статические и фабричные методы
Статические методы - это функции, которые являются свойствами конструктора
	function Article(){
		Article.count++; //статическое свойство
	}
	Article.showCount = function() {
		alert(this.count); //this тут равен Article
	}
Фабричные методы - статический метод, который осуществляет определенную реализацию объекта
	function User() {
		this.sayHi = function() {
			alert(this.name);
		};
	}

	User.createAnon = function() {
		var user = new User();
		user.name = "Anon";
		return user;
	};

	User.createFromData = function(userData) {
		var user = new User();
		user.name = userData.name;
		user.age = userData.age;
		return user;
	};

	var guest = new User();
	guest.sayHi(); //Anon

	var knowUser = User.createFromData({name: "Vasya", age: 25});
	knowUser.sayHi() //Vasya
Полиморфные конструкторы лучше использовать когда не знаешь какие параметры будут переданы

----Явное указание через this: "call", "apply"
Метод call
	func.call(context, arg1, arg2, ...) - вызывается функция func, в контексте context и аргументами arg1, arg2, ...
Метод apply
	func.apply(context, [arg1, arg2, ...]) - то же что и call, но вместо списка принимает массив аргументов
func.apply/или call/.(this, args) - this будет равен func

----Привязка контекста и карринг: "bind"
func.bind(Context [, arg1 arg2, ...]) - возвращает код функции (обертку вокруг нее), привязанной к контексту Context. Если указаны аргументы arg1, arg2, ... то они будут добавлены перед аргументами в вызовах возвращенной функции, т.е. как бы "фиксируем" аргументы.
Карринг - создание новой функции, путем фиксирования аргументов старой
	function mul(a, b) {
		return a * b;
	}
	var double = mul.bind(null, 2) //контектс null (он нам не нужен), второй аргумент (множитель) фиксируем 2
	duoble(3); //умножит на 2
double является "частичной функцией" от mul

----Функции-обертки, декораторы
Декоратор - функция, которая возвращает оберку вокруг целевой функции.
	function isAdmin(){...} //проверка наличия прав администратора
	function save() {...} //сохранить результаты дейтсвий
	function checkPermissionsAdmin(f) {
		return function() {
			if( isAdmin() ) {
				return f.apply(this, arguments);
			}
			alert("Нет прав доступа");
		}
	}

	save = checkPermissionsAdmin(save); //теперь, при вызове save, всегда будет происходить проверка прав администратора


------------------------Некоторые другие возможности----------------------------
----Типы данных: [[Class]], instanceof и утки
Во всех встроенных объектах есть специальное внутреннее свойство [[Class]], которое хранит информацию о его типе или конструкторе. Явно получить его нельзя.
Свойство toString стандартного объекта Object выводит [[Class]] в формате "[object значение]".
	{}.toString.call(new Date); //"[object Date]";
Можно использовать и с примитивами
	{}.toString.call(123); //"[object Number]"
Array.isArray(arr) - возвратит true, если arr массив. Иначе false
user instanceof User - оператор вернет true, если объект user был создан конструктором User
Утиная типизация - можно проверить что массив является таковым и без Array.isArray(). Например, если у массива есть типичный для него метод 	splice.
	if(arr.splice) {} //Конечно, такую проверку можно обойти, но в этом есть смысл утиной типизации. Т.е. будем тогда работать с этим как с массивом.
	//"Если нечто выглядит как утка, плавает как утка, то, вероятнее всего, это утка (не важно что это на самом деле)"
	Иными словами, duck tying - это проверка реализации объектом определенного интерфейса

----Формат JSON, метод toJSON
Это промежуточный формат, для передачи таких данных в виде стоки, как:
	 - JavaScript-объекты
	 - Массивы
	 - Строки в двойных кавычках
	 - Число
	 - Логическое значение true/false
	 - null
Строки в JSON-объектах должны быть в двойных кавычках
В формате JSON не поддерживаются комментарии
Методы для работы с JSON
	JSON.parse(str, reviewer) - читает объект из JSON-строки
		reviewer - функция function(key, value)
			key - ключ в объекте
			value - его значение
			Пример:
				//Если объект имеет несколько уровней вложенности, то reviewer проходится и по ним
				var str = '{"title":"Конференция","date":"2014-11-30T12:00:00.000Z"}';

				var event = JSON.parse(str, function(key, value) {
				  //если ключ с именем date (подразумеваем что он хранит дату), то создаем объект с датой
				  if (key == 'date') return new Date(value);
				  return value;
				});
	JSON.stringify(value, replacer, space) - преобразует («сериализует») значение в JSON-строку.
		value - объект, подлежащий сериализации
		replacer - массив свойств, подлежащих сериализации (ключи в двойных кавычках). Либо можно передать function(key, value), которая возвращает сериализованное value или undefined, если его не нужно включать в результат. replacer-функция работает рекурсивно.
		space - если передано число, то уровни вложенности объекта отмечаются указанным числом пробелов, если строка - вставляется эта строка.

При сериализации объекта, вызывается его встроенный метода toJSON (например, сериализация даты). Если такой метод отсутствует, то JSON строка будет содержать перечисление свойств и их значений (без методов).
Можно создать свой метод toJSON, тогда в строку попадет то, что указано в return

----setTimeout и setInterval
var timerId = setTimeout(func, delay[, arg1, arg2, ...]) - возвращает числовой идентификатор таймера, который можно использовать для отмены дейтсвия
	func - функция или строка кода для исполнения. Строку кода использовать не рекомендуется
	delay - задержка в мс.
	arg1, arg2, ... - аргументы, которые нужно передать функции.
clearTimeout(timerId) - удалить таймер
var timerId = setInterval(func, delay[, arg1, arg2, ...]) - смысл аргументов аналогичен setTimeout, только func запускается циклически. Время выполнения func не учитывается.
clearInterval(timerId) - удалить интервал
Рекурсивный setTimeout
	var timerId = setTimeout(function tick() {
		alert("tick!");
		timerId = setTimeout(tick, 2000);
	}, 2000)
	Более гибкий способ отсроченного вызова, т.к. каждый раз можно время интервала задавать разное.
	Время выполнения func учитывается, т.к. следующий отсроченный вызов происходит только после выполнения текущего.
Пример 1:
	setTimeout(function() {
		alert( i );
	}, 100);

	hardWork() //выполняется дольше 100мс
	В данном примере, пока setTimeout держит паузу (и ничего еще не вызвано), запускается hardWork. Пока hardWork выполняется, уже подошлп очередь запуска функции setTimeout. Как только hardWork выполнился, сразу вызывается функция в setTimeout.
Пример 2:
	var timer = setInterval(function() {
	  i++;
	}, 10);

	setTimeout(function() {
	  clearInterval(timer);
	  alert( i ); // (*)
	}, 50);

	var i;

	function f() {
	  // точное время выполнения не играет роли
	  // здесь оно заведомо больше 100 мс
	  for (i = 0; i < 1e8; i++) f[i % 2] = i;
	}

	f();

	Пока setInterval ждет паузу, щапустится f. Пока выполняется f, дойдет очередь до вызовов setInterval, но интерпретатор в это время же занят f. После выполнения f, будет только один раз вызван setInterval и сразу же setTimeout, очередь которого уже тоже подошла. Т.е. накопления вызовов не происходит.

----Запуск кода из строки: eval
eval(code) - выполнит код, переданный в виде строки. Выполнение произоудет в собственной eval обасти видимости. Возвращает последнее выполненное выражение.
eval используется редко, т.к. работа скрипта, содержащего его вызов, после сжатия становится непредсказуемой
Альтернатива eval - это new Function. Она не имеет замыкания и не сможет воздействовать на внешние переменные, но может получить их копии, переданные по параметрам

----Перехват ошибок, "try..catch"
Три основных свойства объекта ошибки:
	name - тип ошибки
	message - текстовое сообщение о деталях ошибки
	stack - строка с информацией о последовательности вызовов, которая привела к ошибке
new Error(message) - конструктор нового объекта ошибки
throw <объект> - передать объект ошибки в catch-блок
Проброс исключения
	Ошибку, тип которов catch не знает, он не должен обрабатывать
	Оператор throw, внутри catch пробрасывает объект с ошибкой наружу. Там он может быть пойман другим catch-блоком ("более внешним") или "повалит" скрипт.
finally-блок - необязательный блок, после try...catch, который выполнится в любом случае
Если выход из try происходит посредством return, то сначала выполнится finally-блок, а потом обработается возвращенные return'ом данные. Например, если код был внутри функции, то сначала выполнится finally, а затем return'ом будет передано управление во внешний код.
Если ошибка произошла вне try...catch или выпала из catch наружу, то в браузере есть метод window.onerror, который, в таком случае, обработает эту ошибку. Нужно лишь определить его заранее
	window.onerror = function(message, url, lineNumber) {...}
		message - сообщение об ошибке
		url - текущий урл
		lineNumber - место в коде, откуда выпала ошибка




------------------------ООП в функциональном стиле----------------------------
----Введение
Конструкторы называют еще Классами
По приёмам объектно-ориентированной разработки пишут книги, к примеру:
	"Объектно-ориентированный анализ и проектирование с примерами приложений." Гради Буч и др..
	"Приемы объектно-ориентированного проектирования. Паттерны проектирования." Э. Гамма, Р. Хелм, Р. Джонсон, Дж. Влиссидес.

----Внутренний и внешний интерфейс
Один из важнейших принципов ООП - отделение внутреннего интерфейса от внешнего
В JS, приватные свойства - это локальные переменные конструктора.
Публичные - свойства, объявленные через this
Можно привязать к функции контекст, с помощью bind, а можно сохранить его значение во вспомогательную переменную в замыкании, и посредством нее, в функции уже обращаться ко свойствам конкретного контектса.
Отделение внутреннего интерфейса от внешнего, называется "инкапсуляция"

----Геттеры и сеттеры
Называются, обычно, getСвойство и setСвойство - это публичные методы, для получения и установки значений приватных свойств.
Так же, делают и единый метод, отвечающий за запись и за чтение. Называют его одноименно с обрабатываемым свойством. При вызове с параметрами, такой метод устанавливает свойство, а без них - возвращает.

----Функциональное наследование
Один из способов реализации оного - использование наложения конструкторов
	function Machine() {
		var enabled = false;

		this.enable = function() {
			enabled = true;
		}

		this.disable = function() {
			enabled = false;
		}
	}

	function CoffeeMachine() {
		Machine.call(this); // (*)
		...
	}

	(*) - Вызывается с передачей контектса текущего объекта и записывает в него (в контекст, а следовательно в объект) какие-нибудь свойства. Однако локальные переменные и свойства для Machine, будут скрыты в дочернем классе (конструкторе).
Чтобы обозначить внутреннее свойство родителя, его имя начинают с нижнего подчеркивания "_", который условно обозначает что свойство предназначено только для чтения. Такие свойства называют защищенными
Расширение родительского метода
	function Child() {
		Parent.call(this);

		var parentMethod = this.method; //Копируем родительский метод в переменную
		this.menthod = function() { //в дочернем расширяемом методе
			parentMethod.call(this);	 //вызываем родительский метод с передачей текущего this
			/new instructions/ //А после него, дополнительные инструкции
		}
	}




------------------------ООП в прототипном стиле----------------------------
----Прототип proto
__proto__ - специальная ссылка на объект, в котором будут искаться свойства, отсутствующие в данном объекте. Указывается явно.
	var animal = {
		eats: true
	};

	var rabbit = {
		jump: true
	};

	rabbit.__proto__ = animal;

	alert(rabbit.jump);
	alert(rabbit.eats); //По proto, будет искать свойство eats в animal
Прототип - объект, на которое указывает __proto__. Несколько прототипов присвоить одному объекту нельзя.
Прототип используется только при чтении свойств. Запись или удаление (н.п. rabbit.eats = false) будет работать напрямую, с данным объектом
Цикл for...in не различает между свойствами объекта и его прототипа. Переберет свойства, непосредственно перебераемого объекта, и всех его прототипов.
obj.hasOwnProperty("propName") - возвращает true, если свойство принадлежит самому объекту, а не его прототипу. Иначе false
Чтобы использовать объект как простую коллекцию, рекомендуется сделать так:
	var obj = Object.create(null);
	obj.data = "someData";
	/.../
	Создать объект, у которого proto = null, а потом добавлять к нему свойства.
	Таким образом в созданном объекте не бутет прототипа (__proto__ = Object), а значит не будет встроенных методов, а только те, которые мы присвоили.
Вспомогательные методы:
	Object.getPrototypeOf(obj) - возвращает __proto__ переданного объекта
	Object.setPrototypeOf(obj, proto) - устанавливает значение __proto__ для объекта obj
	Object.create(proto, descriptors) - создает пустой объект с __proto__, равным первому агрументу и свойствами, определенными в дескрипторах

----Свойство F.prototype и создание объектов через new
Чтобы объекту автоматически присваивался прототип, при создании через конструктор, свойсту prototype последнего, присваивается значение для __proto__ создаваемого объекта
	//есть конструктор Rabbit и объект animal, который должен быть прототипом объектов, создаваемых черерез Rabbit.
	Rabbit.prototype = animal;
	var rabbit = new Rabbit(); //rabbit.__proto__ = animal
Если в prototype записан примитив, оно будет проигнорировано
У каждой функции есть свойство prototype по умолчанию. Оно содержит объект вида:
	function Rabbit();
	Rabbit.prototype = {
		constuctor: Rabbit;
	}
	//можно его использовать, для создания объекта с тем же конструктором, которым был создан данный
	var rabbit = new Rabbit();
	var rabbit2 = new rabbit.constuctor() //значение свойства constuctor нет в rabbit, потому оно будет искаться в __proto__, которое было задано в момент создания rabbit и равно значению prototype конструктора
Итого
	prototype - свойство конструктора, значение которого будет записано в __proto__ создаваемых им объектов
	__proto__ - свойство, ссылающееся, обычно, на родетельский класс (конструктор)

Итого:
	Функциональный стиль ООП - когда наследование осуществляется путем вызова родительского конструктора в контексте дочернего


----Встроенные классы в JavaScript
При создании объекта, его свойство __proto__ равно Object
Все встроенные методы, новый объект получает из Object.prototype, по __proto__. Object.prototype = Object;
Лучше вызывать встроенные методы через prototype, в нужном контексте, чем через объект
	Array.prototype.call(argumetns) //нет необходимости в создании объекта
	вместо
	[].join.call(arguments)
При вызове метода примитива, создается временный объект (н.п. для строки new String), после выполнения метода он уничтожается.
Свойство prototype во встроенных классах также можно изменять. Однако так делать не очень хорошо с архетитектурной точки зрения

----Свои классы на прототипах
Новый класс в функциональном стиле (все методы в конструкторе)
	function Animal() {
		/this.props/
		/this.methods/
	}
Новый класс в прототипном стиле (все методы в прототипе конструктора)
	function Animal() {
		/this.props/
	}
	Animal.prototype.method1 = function() {...};
	Animal.prototype.method2 = function() {...};
	...
Достоинства:
	Функциональный метод записывает в каждый экземпляр и методы, тогда как прототипный - только свойства. Прототипный потому экономнее по памяти
Недостатки:
	В прототипном стиле нельзя использовать локальные переменные как приватные свойства конструктора. Потому, приходится записывать такое свойство через this, условно обозначив его как защищиенное
		function Animal(name) {
			this._name = name;
		}
		Animal.prototype.method = function() {
			/тут уже работаем с this._name/
		}

----Наследование классов в JavaScript
Для прототипного наследования классов (они же конструкторы), нужно prototype, явно задать ссылку __proto__, указывающую prototype на класса-родителя
	function Animal() {...};
	function Rabbit() {...}
	Rabbit.prototype.__proto__ = Animal.prototype
Однако в некоторых старых браузерах не поддерживается явный доступ к __proto__, потому лучше использовать Object.create()
	Rabbit.prototype = Object.create(Animal.prototype); //однако потеряем constuctor
	Rabbit.prototype.constuctor = Rabbit; //явно сохраняем конструктор
	//и добавляем уже свои методы
	Rabbit.prototype.method = function() {...}
В страых руководствах рекомендуется делать наследование так:
	Rabbit.prototype = new Animal();
Однако сейчас уже так делать не рекомендуется, т.к. при этом будет создан новый объект
Чтобы переопределить метод в прототипном стиле, нужно просто объявить одноименный метод в prototype наследника
Чтобы расширить метод радилеля, то нужно в одноименном методе наследника вызвать, с указанием контекста метод из prototype родителя
	Rabbit.prototype.run = function() {
		Animal.prototype.run.apply(this, arguments);
		/расширяющие инструкции/
	}

----Проверка класса: "instanceof"
instanceof - оператор, позволяющий проверить принадлежность объекта конструктору, с учетом прототипного наследования (если конструктор объекта наследует от проверяемого конструктора)
	var a = [];
	alert(a instanceof Array); //true
	alert(a instanceof Object); //true
Проверка происходит через сравнение прототипов
Алгоритм работы obj instanceof Constructor
1. Получить obj.__proto__
2. Сравнить obj.__proto__ с Constructor.prototype
3. Если не совпадает, тогда заменить obj на obj.__proto__ и повторить проверку на шаге 2 до тех пор, пока либо не найдется совпадение (результат true), либо цепочка прототипов не закончится (результат false).
Если объект создан в iframe и передан в родительское окно, то instanceof не сможет проверить его в родительском окне

----Свои ошибки, наследование от Error
Свой объект ошибки
	function PropertyError(property) { //своя ошибка
	  Error.call(this, property); //Наследуем свойства стандартного конструктора ошибок
	  
	  this.name = "PropertyError"; //переопределяем некоторые стандартные свойства
	  this.property = property;
	  this.message = "Ошибка в свойстве " + property;

	  if (Error.captureStackTrace) { //в V8 есть расширение, позволяющее получить стэк вызовов, приведшик к данной ошибке
	    Error.captureStackTrace(this, PropertyError);
	  } else { //Если такого расширения нет, то записываем стэк в свойство, из тут же сгенерированного объекта ошибки
	    this.stack = (new Error()).stack; //Это нужно, т.к. у нашего навого объекта, по умолчанию свойства stack не будет
	  }

	}

	PropertyError.prototype = Object.create(Error.prototype)
	Error.call(this, property); - вообще, этот вызов не обязателен в данной ситуации. Единственное что он устанавливает специальное внутреннее свойство [[ErrorData]], которое выводится в toString и позволяет увидеть что это ошибка.

Error.captureStackTrace(this [, PropertyError]) - записывает в контекст this (текущий объект), стэк вызовов. Второй аргумент, говорит о том, что при генерации стека, нужно на этой функции остановиться (и не включать ее в стек).
Чтобы наследовать от ошибок Error, нужно самостоятельно позаботиться об инициализации свойств name, stack и message

----Примеси
В JS невозможно наследовать от >1 объекта
Примесь - класс или объект, реализующий какое-либо четко-выделенное поведение. Используется для уточнения поведения других классов. Не предназначен для самостоятельного использования.
Использование
	function Mixin() {
		method1: function() {...},
		method2: function(args) {...}
	}

	function Class() {...}

	for (var key in object) Class.prototype[key] = Mixin[key]; //копируем методы из примеси в класс

Методы примеси активно используют this, и предназначены для запуска внутри контекста
Пример примеси:
	var eventHandlers = {
		"event": function() {}, //обработчик
		...
	}




------------------------Современные возможности ES-2015----------------------------
----Переменные: let и const
let
	Область видимости - блок
	let переменная видна только после объявления
	При повторном объявлении ошибка
	В цикле, для каждой итерации будет создаваться своя отдельная переменная. Замыкания вложенных в цикл функций получат разные переменные.
const
	Нельзя переопределять
	В остальном - то же что и let

----Деструктуризация
Особый синтаксис присваивания, когда можно присвоить объект или массив сразу нескольким переменным.
	var [a, b] = [1, 2]; //a будет равно 1, а b - 2
Лишние элементы массива можно отбросить, поставив запятые
	var [, , a] = [1, 2, 3];
	alert(a); // 3
Оператор "spread" (троеточие) запишет в элемент с ним, все остальное содержимое инициализирующего массива. Должен стоять последним в списке слева
	var [a, b, ...c] = [1, 2, 3, 4, 5];
	alert(a); // 1
	alert(b); // 2
	alert(c); // массив [3, 4, 5]
Если в инициализируемом массиве больше значений, чем в инициализирующем, то у первого "лишние" значения будут равны undefined
Значения по умолчанию - после переменных поставить = и значение
	var [a, b, c = 3, d = 4] = [1, 2];
	alert(c); // 3
	alert(d); // 4
Деструктуризация объектов: слева - список переменных, справа - существующий объект (может быть объявлен и ранее)
	var {var1, var2} = {var1: 1, var2: 2}; //переменные должны иметь одинаковые со свойствами объекта имена
	alert(var1); // 1
	alert(var2); // 2
Если нужно присвоить свойсто объекта переменной с другим именем, то нужно указать соответствие через двоеточие
	var {prop1: a, prop2: b} = {prop1: 1, prop2: 2};
	alert(a); // 1
Можно сочетать двоеточие и равенство
	var {prop1: a, prop2: b, prop3: c = 3} = {prop1: 1, prop2: 2};
	alert(c); // 3
Оператора "spread" в деструктуризации объектов аналогичен с массивами
Если в объекте или массие есть вложенные объекты или массивы, то можно сохранить структуру так
	var {prop1: a, prop2: {aa, bb}} = {prop1: 1, prop2: {aa: 11, bb: 22}}; //при этом prop2 == undefined, аa а и bb будут иметь значения

----Функции
Парамметры по умолчанию
	function f(a = 1, b = 2) {...}
	При передаче любого значения, кроме undefined, параметр считается переданным и значение по умолчанию не используется
Оператор "spread" (троеточие) вместо arguments
	function f(a, b, ...rest) {} //...rest - настоящий массив (не псевдо) и в него попадут все остальные переданные аргументы
	Оператор spread должен быть в конце списка параметров
spread для передачи массива аргументов как списка
	var numbers = [1, 2, 3, 4, 5];
	let max = Math.max(...numbers);
Деструктуризация в параметрах
	Если функция получает объект, то она может сразу же разбить его на переменные
	function f({title, number}) {...} //можно использовать и более сложную деструктуризацию, согласно всем правилам оной

	var obj = {
		title: "name",
		number: 5
	};

	f(obj);
	Чтобы можно было вызвать функцию f вообще без аргументов, объявить ей параметр по умолчанию так
		function f({title="title", number="0"} = {}) {...} //подразумевается что передан пустой объект, который будет заменет на объект по умолчанию
Имя "name"
	В свойстве функции name хранится ее имя в виде строки
	При создании анонимной фунции, с записью в переменную, свойство name будет равно имени переменной
Функции в блоке
	Function Declaration сделанное в блоке кода, видно только в этом блоке
Функции через =>
	let f = (a, b) => a + b; // аналогично function(a, b) {return a + b;}
	Если тело функции сложное, то оно оборачивается в скобки {...}, однако ее результат уже не будет возвращен автоматически. Уже тут нужно применять return
	Удобны в качестве коллбеков
	Не имеют своего this, внутри такой функции он тот же что и снаружи. Потому их нельзя использовать в качестве конструктора.
	Функции-стрелки не имеют собственного arguments

----Строки
Доступен новый вид кавычек `str <перевод строки> ing` - строка будет выведена со всеми переводами строки
	В такие кавычки можно вставлять выражения при помощи ${...}. Такая вставка называется интерполяцией
Функции шаблонизации
	function(strings, ...values) {...}
	func`my string ${a} + ${b}`; //вызов функции перед `строкой`, передаст элементы этой строки в эту функцию как аргументы
		func - имя вызываемой функции
		В обратных кавычках строка как список аргументов. Все что вне ${}, считается строкой и будет записано в первый аргумент, а остальные значения получит второй аргумент.
		Можно объявить список параметров и явно, суть в том, что все строковые значения будут записываться только в первый.
		Оба аргумента представляют собой массивы.
		В первом аргументе, строковые элементы разделены ${}-элементами.
	У первого параметра есть свойство raw (strings.raw), в котором все спец символы записаны "как есть". Это дает возможность обрабатывать их "по-своему".
"Суррогатная пара" - когда два юникодных символа (по 2 байта), образуют неюникодный символ (которому требуется 4 байта).
Методы для работы с суррогатными парами
	String.fromCodePoint - аналог String.fromCharCode
	String.codePointAt - аналог String.charCodeAt
String.charCodeAt считает суррогатную пару двумя символами, а String.codePointAt рассматривает ее правильно - как единый символ
String.fromCodePoint(code) - создает строку из длинного кода code. String.fromCharCode(code) берет только первые два байта из переданого кода, а остальные отбрасывает
Давно есть поддержка юникод-символов, путем ввода \uNNNN, где NNNN - четырехзначный шестнадцатеричный код. Остальные символы в коде будут отброшены.
Если символ имеет >4 значный код, то его нужно обрамить в фигурные скобки {}
Unicode-нормализация - если в строке стоит нормальный символ, а потом юникод-символ, то нормализация сливает их в один
	"S\u0307\u0323" - сначала "S", а потом символы "точка сверху" и "точка снизу". Получим "Ṩ";
	Если верхнюю и нижнюю точки поменять местами в юникод-представлении, то символ визуально не поменяется никак. Для того чтобы в таких случаях приводить юникод-символы к единому представлению и существует Unicode-нормализация.
	Реализует ее метод string.normalize()
		"S\u0307\u0323".normalize() == "S\u0323\u0307".normalize(); //true
Полезные методы
	str1.includes(str2) - true, если str1 содержит в себе str2, иначе false
	str1.endsWith(str2) - true, если str1 заканчивается подстрокой str2, иначе false
	str1.startsWith(str2) - аналогично предыдущему, только рассматривается начало
	str.repeat(times) - повторяет строку str times раз

----Объекты и прототипы
Короткое свойство - при объявлении объекта достаточно указать только имя свойства, а значение будет взято из переменной с аналогичным именем
	var name = "Vasya";
	var surname = "Pupkin";

	var obj = {
		name,
		surname
	};

	alert(obj.name); //"Vasya"
Вычисляемое имя свойства - вместо имени свойства можно использовать переменную со строкой или даже выражение из нескольких переменных
	var a = "Vasya";
	var b = "Pupkin";
	var o = {
		[a + b]: "Hello"
	};
Добавлен метод для установки прототипа
	Object.setPrototypeOf(obj, newProto)
"Конкатенация" объектов - добавлен метод Object.assign(target, src1, src2, ...)
	Добавляет свойства src-объектов в target-объект. При этом, существующие свойства будут перезаписаны последующими свойствами с таким же именем
Object.is(value1, value2) - сравнивает value1 и value2. Во многом аналогичен работе оператора строгого равенства "===", с небольщими отличиями
	Object.is(+0, -0); //false
	+0 === -0; //true
	Object.is(NaN, NaN); //true
	NaN === NaN; //false
Методы объекта - методы, привязанные к конкретному объекту
	var o = {
		sayHi() { // объявление метода объекта
			...
		},
		get getProp() {...},
		set setProp(value) {...}
	};
	Такие методы имеют специальное внутреннее свойство [[HomeObject]], ссылающееся на родительский объект.
Ключевое слово super
	super.parentMethod(); //позволяет внутри метода объекта обратиться к свойствам его прототипа
	super обращается по ссылке [[HomeObject]].__proto__. Поэтому оно работает только внутри методов

----Классы
Новое объявление класса (конструктор + методы)
	class ClassName [extends ParentClass] {
		constructor(args) {...},
		/methods/
	}
	Функция constructor запускается при создании new ClassName
Особенности
	ClassName нельзя вызвать без new - будет ошибка
	Объявление через class ведет себя как let-объявление
	Все методы класса имеют дескриптор enumerable=false
Class Expression - объявление класса "инлайн", аналогично FE
	let User = class {
		sayHi() {alert("Hi!");}
	};

	new User().sayHi()
Named Class Expression - во время Class Expression, классу, как и в NFE, можно дать имя и оно будет дступно только внутри класса.
В классах можно, как и в объектах, объявлять геттеры и сеттеры через get/set и вычисляемые имена свойств [...]
Для объявления статических совйств класса используется ключевое слово static
	class User{
		constructor() {},
		static name: "Vasya",
	}
Наследование
	class Child extends Parent {
	  ...
	}
Методы родителя в Child доступны через super
При наследовании формируется стандартная цепочка прототипов
Если у потомка нет конструктора, то используется родительский.
Если у потомка есть конструктор, то чтобы в нем вызвать родительский, используется super() с аргументами для родителя.
Конструктор родителя можно вызвать только из конструктора потомка.
Нужно вызывать super() до обращения к this, иначе ошибка

----Тип данных Symbol
Примитив. Служит для создания уникальных идентификаторов.
Объявление
	let sym = Symbol("name"); //без new
	typeof sym; //symbol
	sym.toString(); //Symbol(name)
У Symbol() есть необязательный параметр "имя символа".
Symbol("name") == Symbol("name"); //false
Глобальные символы
Symbol.for("name") - для чтения (или создания, при отсутствии) глобального символа по имени. Вернет символ с данным именем.
Symbol.keyFor(sym ) - позволяет получить имя переданного глобального символа в виде строки
Символы можно использовать для названий свойств объекта
	var isAdmin = Symbol("isAdmin");
	var obj = {
		[isAdmin]: true
	}
	Таким образом, свойство isAdmin будет недоступно для итерации и если обратиться к нему по названию obj.isAdmin - такого свойствв не существует
Object.getOwnPropertySymbols(obj) - возвращает все символы объекта obj.

----Итераторы
Это объект, который можно перебрать в цикле for...of
	Массив arr: for(let value of arr) {alert(value);}
Строка также является итерируемым объектом
Чтобы сделать возможным перебор объекта в for...of, нужно создать в нем специальное свойство Symbol.iterator.
	Им является метод, при вызове которого, перебираемый объект будет возвращать другой объект (итератор), с методом next(), который и будет осуществлять перебор и проверять на его окончание. Пример
		var range = {
			from: 1,
			to: 5
		};

		range[Symbol.iterator] = function() {
			let current = this.from;
			let last = this.to;
			return {
				next: function() {
					if(current <= last)
						return {
							done: false,
							value: current++ //очередное значение
						}
					else
						return {
							done: true
						}
				}
			}
		};
		for (let num of range) {alert(num);}
for...of в начале вызывает [Symbol.iterator], а затем вызывает next() до получения done == true. Пока в процессе перебора, свойство value, возвращаемого на каждой итерации объекта присваивается в переменную num
Если применить к итерируемому объекту оператор spread, то автоматически будет вызван цикл for...of и все полученные в процессе перебора значения, будут возвращены в виде списка.

----Set, Map, WeakSet и WeakMap
Map - коллекция для хранения пар "ключ-значение".
И ключ и значение могут быть любого типа (даже объектами или NaN) и хранятся как есть, без преобразования типов
Использование
	var map = new Map();
	map.set(key, value) //установить новую пару
	map.get(key) //получить свойство по ключу
	map.size //общее количество пар

	метод set можно чейнить:
	map.set(...).set(...) и т.д.
При создании, map можно сразу инициализировать списком значений
	var map = new Map([
		[key1, value1],
		[key2, value2],
		...
	])
	Аргументом Map должен быть итерируемый объект, не обязательно массив
map.delete(key) - удалит запись по ключу key. Вернет true, если такая запись была. Иначе false
map.clear() - полностью очистить коллекцию
map.has(key) - true, если ключ key есть. Иначе false.
Методы для итерации
	map.keys() - вернет итерируемый объект (который можно перебрать в for...of) с ключами
		for (var key of map.keys()) {...}
	map.values() - итерируемый объект со значениями
	map.entries() - итерируемый объект с записями [key, value]. Используется по умолчанию, если перебрать map в for...of
	map.forEach(callback) - метод аналогичен встроенному в массивы
Set - коллекция для хранения пар ключ-значение, которые не повторяются. Запись дубликата не происходит.
Методы
	set.add(item) - добавляет item в коллекцию. Возвращает set (можно чейнить)
	set.delete(item) - аналогично методу в Map
	set.has(item) - аналогично методу в Map
	set.clear() - очистить коллекцию
Перебор осуществляется forEach или for...of, аналогично Map. Но у Set, callback для forEach, имеет три аргумента, первые два, из которых, всегда совпадают (value, value, set)
WeakSet/WeakMap - особый вид Set/Map, у которых сборщик мусора может удалять элементы.
	- Только объекты в качестве ключей
	- Нет свойства size
	- Нет метода clear()
	- Нельзя перебрать элементы forEach
WeakMap/WeakSet работают только на чтение и запись. Об удалении заботится сборщик мусора

----Promise
Это специальный объект, содержащий одно из 3х состояний:
	pending - "ожидание"
	fulfilled - "выполено успешно"
	rejected - "выполнено с ошибкой"
На объекты promise можно навесить такие колбеки:
	onFulfilled - срабатывает когда promise в состоянии fulfilled
	onRejected - когда в состоянии rejected
Порядок использования:
	1. Код, в который выполняется асинхронно, создает объект promise и передает его внещнему коду
	2. Во внешнем коде на этот promise навешиваются обработчики (onFulfilled и onRejected)
	3. По завершении своего выполнения, асинхронный код переводит этот promise в состояние fulfilled (успешно) или rejected (была ошибка)
Создание Promise:
	var promise = new Promise(function(resolve, reject)) {
		//Эта функция будет вызвана автоматически
		//Тут можно выполнять асинхронный код
		//Когда код выполнится, будет вызван
			//resolve(result) если все хорошо. result будет передан назначенному обработчику как аргумент
			//rejected(error) при ошибке. error будет передана соответствующему общаботчику
	}
Навешивание обработчиков:
	Универсальный метод:
		promise.then(onFulfilled, onRejected); //можно навесить и один обработчик
			onFulfilled - функция. Будет вызвана с результатом при resolve
			onRejected - с ошибкой, при rejected
	Только для ошибок:
	promise.catch(onRejected); //аналогичен promise.then(null, onRejected)
Если промис уже был вызван с resolve или reject, то далее он не может изменить свое состояние. Любые дальнейшие вызовы resolve/reject, в функции, переданной конструктору, будут проигнорированы.
Промисификация - когда, к примеру, функция возвращает обертку кода, в виде промиса.
Цепочки промисов
	Чтобы цепочка промисов могла выполняться, каждый then должен возвращать промис, вызывающий свои resolve/reject, чтобы следующий then мог навесить на предыдущий then, обработчик.
	Результат, в зависимости resolve/reject, будет обработан соответсвующим обработчиком.
	Если возвращается примитив, то then возвращает промис в состоянии resolved(примитив).
Перехват ошибок
	Если в выполнен throw <значение>, то then вернет промис в состоянии rejected(значение);
	Если в then выполнился throw error, то эта ошибка не "повалит" скрипт, а просто передастся в следующий обработчик ошибок.
	Для перехвата ошибок в цепочке, нужно назначить второй аргумент then или воспользоваться альтернативным методом catch(onRejected).
	catch можно поставить последним "звеном" в цепочке. Он будет перехватывать ошибки, возницающие на любом этапе последовательности.
	Обычно, catch используется для перехвата критических ошибок.
Промисы в деталях
	У объекта new Promise(executor), при создании, есть 4 внутренних свойства
		PromiseState - состояние в начале, "pending"
		PromiseResult - результат. При создании не содержит значения (undefined)
		PromiseFulfillReactions - список обработчиков успешного выполнения
		PromiseRejectReactions - список обработчиков ошибок
	Порядок работы
		Когда вызывается обработчик resolve/reject, то PromiseState становится "resolved" или "rejected", соответсвенно.
		Все функции из соответствующего списка (PromiseFulfillReactions/PromiseRejectReactions), перемещаются в специальную системную очередь PromiseJobs. Эта очередь автоматически выполняется когда интерпретатору "нечего делать" (асинхронно, наподобие setTimeout). Исключение составляет, когда обработчик возвращает новый промис, тогда дальнейшее выполнение ожидает его результата и обработчики вызываются уже с ним.
		Если PromiseState == "pending", то then/catch добавляют обработчики в соответствующие списки, иначе обработчики добавляются сразу в очередь на выполнение (PromiseJobs).
	Если какой-либо из обработчиков не указан
		не указан reject - добавляется вместо него Thrower:
			arg => throw arg
		не указан reject - добавляется Identity:
			arg => arg
	Если назначить несколько обработчиков на промис отдельно, без использования чейнинга, то они все выполнятся поочередно, с одним и тем же результатом промиса, без взаимодействия друг с другом
	Параллельное выполнение
		Promise.all(iterable) - получает массив (или др. итерируемый объект) промисов и ждет пока все они выполнятся (одновременно), а потом возвращает массив их результатов. Если какой-то промис завершился ошибкой, то результатом будет эта ошибка, остальные промисы игнорируются.
		Promise.race(iterable) - аналогично Promise.all, только результатом будет первый, успешно выполнившийся промис.
		Promise.resolve(value) - создает успешно выполнившийся промис, с результатом value
		Promise.reject(error) - аналогично Promise.resolve, создает завершенный промис, но уже с ошибкой error.

----Генераторы
Функции, которые могут приостановить выполнение, вернуть промежуточный результат, а потом возобновить его позже, в произвольный момент времени. Сам код функции не выполняется, она возвращает специальный объект, который и называется "генератором"
Синтаксис
	function* gen() { //или function *gen() {
		yield 1; 
		yield 2;
		return 3;
	}
	generator = gen();

Чтобы начать выполнение самого кода, нужно вызвать метод next() генератора.
	generator.next(); //{value: 1, done: false}
При достижении слова yield, выполнение приостанавливается, и возвращается промежуточный результат.
Повторный вызов generator.next() возобновит выполнение и вернет следующий результат.
	generator.next(); //{value: 2, done: false}
При достижении return, выполнение генератора окончательно завершается.
	generator.next(); //{value:3, done: true}
Все последующие вызовы generator.next() будут возвращать один окончательный результат.
Генератор является итерируемым объектом и его можно перебрать в цикле for...of. Однако значени return в цикле обработано не будет, т.к. значение c done: true, цикл игнорирует.
Композиция генераторов
	Это возврат и сразу же выполнение генератора в теле другой функции-генератора. Таким образом, внешняя функция возвращает промежуточный результат выполнения внутренних генераторов, как если бы их код был бы просто вставлен внутрь внешнего. При этом, переменные вложенного не попадают во внешний. Попадают только yield результаты.
	function* gen(start, end) {
		for(let i = start; i <= end; i++) {
			yield i;
		}
	}

	function* genSec() {
		yield* gen(1, 3);
		yield* gen(7, 9);
		yield* gen(10, 12);
	}

	Специальная форма yield* делегирует выполнение вложенному генератору. 
Оператор yield может принимать значение из вне
	let result = yield value;
	- вернет value во внешний код
	- код может обработать значение, а затем вызвать next с аргументом: generator.next(arg)
	- генератор продолжит выполнение, а аргумент arg будет возвращен оператором yield и записан в result
Помимо значения, в генератор можно передать еще и ошибку
	generator.throw(err);
	Внутри, на строке yield, возникнет исключение, которое можно внутри же, обработать в try...catch блоке
	Если ошибка не перехвачена в генераторе, то она "выпадает" во внешний код, там где инициирован вызов generator.throw.
Плоский асинхронный код
	Общий принцип:
		- Генератор yield'ит не обычные значения, а промисы
		- Есть специальная "функция-чернорабочий" (самостоятельно написанная) execute(generator), которая запускает генератор, последовательными вызовами next получает из него промисы, когда очередной промис выполнится - возвращает в генератор его результат в следующем вызове next.
		- Последнее значение генератора (done:true) execute уже обрабатывает как окончательный результат - например,
		  возвращает через промис куда-то еще, во внешний код или использует иначе.
Библиотека "co"
	Получает генератор и выполняет его
		co(function*() {
			let result = yield new Promise(
				resolve => setTimeout(resolve, 1000, 1);
			);
			alert(result);
		}).then(alert); //через секунду 1
	Нужно отлавливать ошибки через catch
		co(...).catch(e);
	Значения, которые может обрабатывать co
		- Промис
		- Функция-генератор. Сначала выполнится, а затем выполнится полученный генератор
		- Функция с аргументом вида function(callback), которая будет запущена и, в случае ошибки, будет выполнен callback(err), а в случае удачного результата - callback(null, result). После чего, результат будет передан в генератор. (Устаревшее. Актуальны промисы).
		- Массив или объект из вышеперечисленных значений. Все будут выполнены параллельно, а результат, в той же структуре, будет выдан наружу.

----Модули
Модуль - это файл с кодом. В таком файле, переменные и функции, предназначенные для экспорта, помечаются ключевым словом export. Используются системами сборки, которые находят в файлах слова import/export и заменяют их на свои внутренние JavaScript вызовы.
export
	Использование
		export let a = 5;
		или несколько значений:
		export {...список}
	Ключевое слово as задает псевдоним, под которым будет доступна данная переменная снаружи
		export(one as first, two as second)
	Для экспорта обязательно нужно имя
Можно подключать так же, экспортированные значения, с помощью слова import
	import {one, two} from "./nums";
	"./nums" - путь к файлу модуля
	Импортировать можно и под другим именем
		import {one as first, two as second} from "./nums";
	Можно импортировать все экспортируемые значения в виде объекта
		import * as obj; //теперь они являются свойствами объекта obj
На пракике, один модуль = одна сущность (функция или объект)
Если перед сущностью указать сочетание слов export default, то его можно импортировать без фигурных скобок
	export default class User {...}
	.........
	import User from "./user";

----Proxy
Это особый объект, задача которого - перехватывать обращения к другому объекту и, при необходимости, модифицировать их.
	let proxy = new Proxy(target, handler);
	target - объект, обращения к которому надо перехватить
	handler - объект с функциями-перехватчиками для target
Если для операции нет ловушек, то она выполняется напрямую над target.
get/set - ловушки для чтения/записи в объект
	get(target, property, receiver) - срабатывает при чтении свойства из прокси.
		target - целевой объект, переданный первым аргументом Proxy
		property - имя свойства
		receiver - объект, к которому было применено присваивание. Обычно сам Proxy, или прототипно наследующий от него.
	set(target, property, value, receiver) - при записи свойства. Смысл аргументов тот же. Вернет true, при успешной записи свойства, иначе false (с ошибкой TypeError).
		value - значение свойства.
has(target, property, receiver) - ловушка "has" срабатывает в операторе in и в др. случаях, когда проверяется наличие свойства. Синтаксис аналогичен get.
deleteProperty - синтаксис аналогичен get/set. Срабатывает при операции delete. Должна вернуть true, если удаление выполнено успешно.
enumerate(target) - перехватывает операции for...in и for...of по объекту. Возвращает итератор для свойств.
apply(target, thisArgument, argumentsList) - ловушка для вызова функции, если таковой является target.
	target - исходный объект
	thisArgument - контекст this для вызова
	argumentsList - аргументы для вызова в виде массива
construct(target, argumentsList) - перехватывает вызовы объекта при помощи new.
Прочие ловушки:
	getPrototypeOf - перехватывает обращение к методу getPrototypeOf
	setPrototypeOf - аналогично предыдущему
	isExtensible - перехватывате обращения к методу isExtensible
	preventEtensions - перехватывает обращения к методу preventEtensions
	getOwnPropertyDescriptor - перехватывает обращения к одноименному методу
	defineProperty - аналогично предыдущим
	ownKeys - перехватывает обращения к методу getOwnPropertyNames





********************************************Часть 2******************************************************
------------------------Документ и объекты страницы----------------------------
----Окружение: DOM, BOM и JS
window - с одной стороны, является глобальным объектом в JavaScript, с другой - содержит свойства и методы для управления окном (вкладкой) браузера. Включает в себя объектные модели: DOM, BOM, глобальные объекты JavaScript.
Объектная модель документа (DOM)
	document - глобальный объект. Дает возможность взаимодействовать с содержимым страницы.
Объектная модель браузера
	Это набор объектов для работы со всем, кроме документа
	Объект navigator содержит информацию о браузере и ОС
		navigator.userAgent - о браузере.
		navigator.platform - об ОС.
	Также функции alert, confirm, prompt

----Дерево DOM
Представления документа, в виде дерева объектов, доступных для измененния через JS.
По этой модели, документ - это иерархия.
HTML-тег - узел дерева с типом "элемент". Вложенные теги - дочерние узлы.
Для представления текста - узлы с типом "текст". Содержит только строку и не может иметь потомков.
Форматирование html-разметки, включающее в себя отступы и переносы строк - так же создают текстовые узлы.
	Исключение: пробелы до <head> игнорируются. Содержимое после <body> тоже не создает узла, а переносится внутрь, в конец <body>
Автоисправление
	Браузер автоматически исправляет html, для показа и создает соответствующие узлы в DOM. Закрывает и добавляет нужные теги.
Коментарий тоже создает узел с типом "коментарий".
Все что есть в HTML, есть и в DOM. После <!DOCTYPE html>
Всего есть 12 типов узлов, но на практике будем работать с 4мя:
	document - точка входа в DOM
	элемент - основные строительные блоки
	текстсовые узлы - содержат текст
	коментарии - с ними так же можно работать в JS.
document.documentElement - получить узел HTML
document.body - получить узел body

----Работа с DOM из консоли
Если выбрать элемент в инспекторе, то в консоли можно будет запускать с ним команды на JS.
В консоли, последний выбранный элемент будет доступен по имени $0, предыдущий выбранный - по имени $1 и т.д.
Элемент из переменной можно посмотреть и во вкладке Elements:
	1. Вывести элемент в консоль, НП с помощью console.log
	2. Кликнуть ПКМ по элементу и выбрать "Reveal in Elements panel".
$$("div.my") - ищет все элементы в DOM, по данному CSS селектору
$("div.my") - ищет первый элемент по селектору

----Навигация по DOM-элементам
Доступ к любому HTML узлу начинается с объекта document
	document.documentElement - <html>
	document.body - <body>
	document.head - <head>
Псевдомассив childNodes хранит все дочерние элементы (текстовые узлы и коментарии в т.ч.), на 1 ступень ниже по иерархии, выбранного элемента:
	document.body.childNodes //все дочерние элементы в <body>
	Содержащиеся в нем элементы только для чтения.
	Перебирать псевдомассив циклом for...in не рекомендуется, т.к. он перебирает и служебные свойства.
firstChild и lastChild - обеспечивают доступ к первому и последнему дочернему узлу. Только для чтения.
parentNode - получить родительский узел.
previousSibling/nextSibling - получить предыдущий/следующий соседний узел.
Получение узлов-элементов (соответствуют только тегам)
	children - все дочерние элементы
	previousElementSibling/nextElementSibling - предыдущий/следующий соседний элемент
	firstElementChild/lastElementChild - первый/последний
	parentElement - родительский элемент.
Особые ссылки для таблиц
	table.rows - коллекци строк tr таблицы
	table.caption/tHead/tFoot - ссылки на элементы таблицы CAPTION, THEAD, TFOOT
	table.tBodies - коллекция элементов TBODY
	tbody.rows - коллекция строк tr секции
	tr.cells - коллекция ячеек td/th строки
	tr.sectionRowIndex - номер строки в текущей секции THEAD/TBODY
	td.cellIndex - номер ячейки в строке.

----Поиск: getElement*, querySelector* и не только
Если у элемента задан атрибут id, то доступ к нему можно получить просто из переменной, с таким же именем, как значение id
	<div id="content"></div>
	<script>alert(content)</script>
	Однако такой подход не совсем верный, т.к. создает глобальные переменные. Существует только для обратной совместимости.
Правильно получать доступ к элементу следующим вызовом
	document.getElementById("значение id");
	id должен быть уникальным в документе, иначе поведение метода неопределенно
elem.getElementsByTagName(tag) - вернет все элементы, которые внутри elem с тегом tag, в виде списка. Можно получить всех потомков, передав "*", вместо имени тега.
document.getElementsByName(name) - вернет списох элементов, у которых атрибут name имеет переданное значение.
elem.getElementsByClassName(className) - возвращает список элементов которым присвоен класс className.
elem.querySelectorAll(css) - возвращает все элементы внутри elem, удовлетворяющие css-селектору. Список в порядке вложенности.
elem.querySelector(css) - аналогично querySelectorAll, но возвращает только первый найденный элемент.
elem.matches(css) - проверяет, удовлетворяет ли elem селектору css. Возвращает true либо false.
elem.closest(css) - ищет ближайший сверху по иерархии элемент, который удовлетворяет селектору css. Когда находит - останавливает поиск и возвращает его. Сам elem тоже включается в поиск.

----Внутреннее устройство поисковых методов
Браузер поддерживает у себя внутреннее свойство id -> элемент, поэтому getElementById работает очень быстро.
elem.querySelector* - перебирает внутренние элементы в elem и проверяет их на соответствие селектору. Перебор осуществляется быстро т.к. производится движком браузера, а не JS-кодом. Часто, при поиске по id ("#id"), браузеры оптимизируют поиск, вызывая getElementById. Последние результаты сохраняются в кеше, до тех пор, пока не изменится документ.
Результат getElementsBy* изменяется при изменении документа. Результатом является колекция типа NodeList или HTMLCollection. Сам запрос выполняется при обращении к ее элементам или длине.

----Свойства узлов: тип, тег и содержимое
Иерархия классов DOM:
	Node {
		Text,
		Comment,
		Element {
			SVGElement,
			HTMLElement {
				HTMLInputElement, //для <input>
				HTMLBodyElement, //для <body>
				HTMLEAnchorlement //для <a>
				и т.д.
			}
		}
	}
Чтобы узнать класс узла, нужно привести его к строке
	alert(document.body); //[object HTMLBodyElement]
console.log выводит элементы в виде, удобном для исследования html-структуры
console.dir выводит элементы в виде JavaScript-объекта, удобно для анализа его свойств.
Тип nodeType
	Тип узла содержится в его свойстве nodeType
	Каждый тип представляет собой соответсвующий номер. Описание всех номеров есть в спецификации.
	ELEMENT_NODE == 1;
	TEXT_NODE == 3;
	COMMENt_NODE == 8;
Свойства nodeName и tagName - содержат имя тега узла.
	tagName есть только у узлов ELEMENT
	nodeName есть у типа NODE
Свойтсво innerHTML - позволяет получить/записать html-содержимое элемента
	Тонкости:
		Добавление innerHTML+= осуществляет перезапись. То же самое что и innerHTML = innerHTML + ... При этом, все существующие картинки будут загружены заново.
		<script></script> вставленный через innerHTML не выполнится
Свойство outerHTML выведет содержимое элемента целиком (вместе с его тегом и внутренним форматированием)
	Изменить его нельзя. Изменение outerHTML не изменяет прежний узел, а создает новый. Изменения не отражаются на изменяемом элементе в документе, но новосозданный узел можно получить из DOM.
Свойство innerHTML есть только у узлов типа Element.
Содержимое узлов других типов, доступно на чтение и запись через свойство data.
Свойство textContent содержит только текст (включая переводы строк и пробелы) внутри элементов, за вычетом тегов.
Теги, записанные через textContent, браузер не будет обрабатывать как теги. Они будут обычным текстом.
Свойство innerText возвращает текст элемента в том виде, в каком он отображается в браузере (без структуры DOM). При записи работает так же как textContent.
Свойство hidden - true или false. Определяет видимость элемента.
У элементов определенных типов, есть и свои специфичные свойства:
	value для input, select, textarea
	id
	href
	... и другие... (см спецификацию или вывести в консоль через console.dir)

----Современный DOM: полифиллы
Полифилл - это библиотека, которая добавляет браузеру поддержку современных возможностей.
Обычно она состоит из 2-х частей:
	1. Проверка, есть ли поддержка (на равенство undefined)
	2. Если поддержки нет, то эмуляция свойства.
Если в поле ввода задан неподдерживаемых тип (атрибут type) то input.type == text - это значение по умолчанию.
HTMLElement является общим родительским классом для всех html-элементов.
Для добавления нужной возможности, берется правильный класс и модифицируется его prototype
Свойство можно добавить через Object.defineProperty.

----Атрибуты и DOM-свойства
Когда браузер генерирует DOM, большинство стандартных html-атрибутов, становятся свойствами соответствующих объектов.
В DOM-объекты можно добавлять свои свойства.
Атрибуты
	elem.hasAttribute(name) - проверяет наличие атрибута.
	elem.getAttribute(name) - получает значение атрибута.
	elem.setAttribute(name, value) - устанавливает значение атрибута.
	elem.removeAttribute(name) - удаляет атрибут.
	elem.attributes - содержит все атрибуты элемента в виде псевтомассива, типа Attr.
Атрибуты, в отличие от DOM-свойств, всегда:
	Являются строками
	Нечувствительны к регистру
	Видны в innerHTML
При получении значения атрибута href через getAttribute, получим значение, что записано в html. Если попытаться получить доступ через свойство, то получим полную ссылку.
	a.href = "/";
	a.getAttribute("href") // '/'
	alert(a.href); //"site.com/"
Свойство checked имеет логические значения true/false
Атрибут checked может иметь любое значение. Важен лишь факт его наличия.
Чаще, свойство объекта зависит от атрибута, но не наоборот (изменение свойства не всегда влечет за собой изменение атрибута)
elem.className - значение атрибута class в виде строки.
elem.classList - псевдомассив, содержащий список классов (значения атрибута class).
	elem.classList.contains("class") - возвращает true/false, если присвоен класс class
	elem.classList.add/remove("class") - добавляет/удаляет класс class
	elem.classList.toggle("class") - если class есть, то удаляет его, если нет - добавляет.
htmlFor - значение атрибута for (<label for="...">)
Атрибут является стандартным (и для него создается свойство), только если оно описано в стандарте для конкретного элемента.
Свойство dataset и data-атрибуты
	Можно привязать к элементу данные, записав их в атрибуте, начинающемся на data-
	К data-атрибутам можно обратиться через специальное свойство dataset
		<div id="elem" data-about="Elephant" data-user-location="street">...</div>
		<script>
			alert(elem.dataset.about); //"Elephant"
			alert(elem.dataset.userLocation); //"street". Дефис в user-location превратился в большую букву (userLocation)
		</script>

----Методы contains и compareDocumentPosition
parent.contains(child) - возвращает true, если parent содержит child или parent == child
nodeA.compareDocumentPosition(nodeB) - возвращает побитовую маску (число), значение которой означает следующее
	Биты	Число	Значение
	000000	0		nodeA и nodeB - один и тот же узел
	000001	1		Узлы в разных документах или один из них не в документе
	000010	2		nodeB предшествует nodeA (в порядке обхода документа)
	000100	4		nodeA предшествует nodeB
	001000	8		nodeB содержит nodeA
	010000	16		nodeA содержит nodeB
	100000	32		Зарезервировано для браузера
	Могут быть сочетания битов, к примеру, когда узел содержит элемент и одновременно является его пердшественником (раньше встречается при обходе элемета), будет сочетание масок 000100 = 4 (предшествует) и 010000 = 16 (содержит) - итоговая маска будет равна 010100 = 20.
Проверить на содержание узлом nodeA узла nodeB, можно с помощью побитового оператора
	nodeA.compareDocumentPosition(nodeB) & 16

----Добавление и удаление узлов
Создание элемента
	document.createElement(tag) - создать элемент с тегом tag. Возвращает объект созданного элемента.
	document.createTextNode(text) - создать текстовый узел с текстом text. Возвращает объект созданного элемента.
	При таком создании получаем объект, но он не связан со страницей еще и не виден на ней.
Добавление элементов на страницу
	parentElem.appendChild(childElem) - добавляет childElem в конец parentElem.
	parentElem.insertBefore(childElem, nextSibling) - вставить элемент childElem внутрь parentElem, перед nextSibling.
	Если nextSibling указать как null, то insertBefore сработает как appendChild
Все методы вставки, возвращают вставленный узел.
Все методы вставки удаляют узел со старого места, если мы захотим вставить его где-то в другом месте.
Копирование узлов
	elem.cloneNode(true) - создать "глубокую" копию узла со всеми атрибутами. Если в аргумент передать false, то копия будет без дочерних элементов.
Удаление узлов
	parentElem.removeChild(childElem) - удалить childElem из детей parentElem
	parentElem.replaceChild(childElem, insertElem) - удалить childElem из детей parentElem и вставить на его место insertElem.
	Оба метода возвращают удаленный узел.
	elem.remove() - метод удаляет элмент elem, в контексте которого вызван.

----Мультивставка: insertAdjacentHTML и DocumentFragment
Множественная вставка элементов в DOM будет медленнее чем создать такую структуру полностью в коде, а потом один раз вставить.
elem.insertAdjacentHTML(where, html) - вставить html в виде строки в любое место, относительно elem
	where: 
		"beforeBegin" - вставить html перед elem
		"afterBegin" - внутрь elem, в самое начало
		"beforeEnd" - внутрь elem, в конец
		"afterEnd" - после elem.
elem.insertAdjacentElement(where, newElem) - вставляет newElem
elem.insertAdjacentText(where, text) - создает текстовый узел из строки text и вставляет его
Document Fragment
	Это DOM-объект, который похож на DOM-узел, но им не является.
	Синтсаксис
		var docFragment = new document.createDocumentFragment(); //создание
		docFragment.appendChild(node); //в него можно добавлять узлы
		docFragment.cloneNode(true); //его можно клонировать
	У него нет обычных свойств (innerHTML, tagName и т.п.) т.к. это не узел
	Его особенность в том, что в него можно добавить много элементов, а потом вставить его в документ. При этом сам объект удаляется, а в документ будут вставлены его "дети".
append/prepend, before/after, replaceWith
	node.append(...nodes) - вставить nodes в конец node
	node.prepend(...nodes) - nodes в начало node
	node.after(...nodes) - вставить nodes после node
	node.before(...nodes) - nodes перед node
	node.replaceWith(...nodes) - nodes вместо node
		nodes - DOM-узлы или строки. Строки будут вставлены как текстовые узлы

----Метод document.write(str)
Старый метод. Имеет ограничения. Используется редко.
Метод работает только пока html-страница грузится. Он дописывает html-код из строки str в текущее (место вызова) место в документе.
Когда документ загрузился и DOM построен, то он (документ) считается "закрытым". Если, в этом случае, вызвать document.write, то это вызовет перезапись документа на str.
	<body> //будет выведено 1 2 3
		1
		<script>document.write(2);</script>
		3
	</body>
	Однако, загрузка такого скрипта, блокирует отрисовку всей страницы.
Также существует метод document.writelb(str), который после str еще добавляет символ "\n"
document.write - это самый быстрый способ добавить текст, сгенерированный скриптом, на страницу.

----Стили, getComputedStyle
elem.style - возвращает объект, который дает доступ к стилям элемента на чтение и запись. Равно только тому значению, которое присвоено атрибуту style у самого тега.
Свойства этого объекта названы так же, как и свойства css. Свойства, состоящие из нескольких слов, называются вотТак.
Свойство float называется cssFloat.
Свойства с префиксами начинаются с большой буквы. (правило "дефис в css = большая буква в js").
elem.style.width = "" - сбросить установленный стиль. При сбросе style, стиль будет взят из css.
Обычно присваивают классы. elem.style нужен там, где не имеем дело с классами.
style.cssText - свойство позволяет задать стили в виде строки. Неподдерживаемые свойства, браузер игнорирует.
	При установке этого свойства, все предыдущие elem.style свойства удаляются.
window.getComputedStyle(element[, pseudo]) - возвращает объект со свойствами. Эти свойства равны используемым в данный момент стилям, взятым как из атрибута style, так и из css-файла.
	elem - элемент, стили которого нам нужно узнать
	[, pseudo] - узказывается, если нужны стили псевдоэлемента. Например ::before.
Существует:
	compuded-значения (н/п width: auto, margin: calc(...), font-size: 125% и т.п.)
	resolved-значения (с конкретными единицами).
window.getComputedStyle возвращает resolved значения.
Для чтения стиля, getComputedStyle требует указания полного названия свойства (нп marginTop вместо margin). 
window.getComputedStyle не имеет доступа к стилям посещенных ссылок (:visited)

----Размеры и прокрутка элементов
Когда у элемента с overflow (css) появляется полоса прокрутки, она отодвигает его, вместе с содержимым и отступами, влево.
Метрики
	Ряд свойств у элемента, содержащие внешние и внутренние размеры. Все измеряются в пикселах и пишутся без единиц измерения.
	offsetParent - ссылка на элемент, относительно которого позиционируется данный элемент.
	offsetLeft/Top - задают смещение (левого верхнего угла) относительно offsetParent.
	offsetWidth/Height - содержат внешние размеры элемента (включая border, padding).
	Для невидимых элементов, метрики равны нулю, offsetParent = null
	clientTop/Left - толщина рамок (в зависимости от браузера, может включать в себя и полосу прокрутки)
	clientWidth/Height - размеры элемента внутри рамок, вместе с padding. 
		clientWidth не включает в себя ширину полосы прокрутки.
	scrollWidth/Height - полная высота и ширина элемента, включая область прокрутки (за рамками видимой области)
	scrollTop/Left - высота/ширина уже прокученной, на данный момент, области, которая находится за рамками видимой. Эти свойства можно изменить и браузер выполнит прокрутку элемента.
Для получения реальных размеров, стоит использовать clientWidth/Height

----Размеры и прокрутка страницы
clientWidth/Height для document.documentElement - это размеры видимой области окна. Аналогично и scrollWidth/Height
window.innerHeight - высота окна, включая горизонтальный скроллбар
Если прокрутка у document.documentElement то есть, то нет - корректно определить высоту окна можно
	var scrollHeight = Math.max(
		document.body.scrollHeight, document.documentElement.scrollHeight,
		document.body.clientHeight, document.documentElement.clientHeight,
		document.body.offsetHeight, document.documentElement.offsetHeight
	);
window.pageYOffset - прокручено сверху
window.pageXOffset - прокручено слева
	Доступны только для чтения
Изменение прокрутки страницы
	window.scrollBy(x, y) - прокрутить страницу на x пикселей влево и на y пикселей вниз
	window.scrollTo(x, y) - установить видимую область на (x, y) координаты страницы
	elem.scrollIntoView(top) - прокручивает страницу до момента, когда elem окажется вверху видимой области, если top == true или внизу, если top == false.
Запрет прокрутки
	Страница "замрет" в текущем положении, если добавить ей document.body.style.overflow = "hidden".
	При этом полоса прокрутки исчезнет и ширина страницы увеличится. Исправить это можно, вычислив ширину полосы прокрутки и, когда она исчезнет, добавить такой же padding.

----Координаты в окне
elem.getBoundingClientRect() - возвращает объект с координатами верхнего левого угла (относительно левого верхнего угла видимой области окна) "воображаемого прямоугольника", который охватывает elem. Свойства возвращаемого объекта (все хранят число пикселей, без явного указания единиц):
	top - Y-координата верхней границы элемента
	left - X-координата левой границы
	right - Х-координата правой границы
	bottom - Y-координата нижней границы
Контент страницы содержится в прямоугольниках. Блочный элемент - один прямоугольник. Строчный элемент - все строки содержатся в прямоугольниках равной высоты, но разной длины. Чтобы получить все прямоугольники - метод elem.getClientRects().
document.elementFromPoint(x, y) - возвращает элемент, который находится на координатах x,y, относительно окна. Для координат за пределами окна возвращает null.

---Координаты в документе
Система координат страницы начинается в левом верхнем углу именно страницы
Стандартной функции для получения коодринат элемента, относительно страницы, нет. Но ее можно легко написать самим
	function getPageCoords(elem) {
		var winBox = elem.getBoundingClientRect();

		return {
			top: winBox.top + pageYOffset; //координаты в текущем окне + сколько прокручено
			left: winBox.left + pageXOffset;
		}
	}
Координаты относительно окна
	Размеры экрана хранятся в глобальной переменной screen
		screen.width;
		screen.height;
		//есть ряд других свойств, описанных в документации
	Координаты левого верхнего угла окна
		window.screenX;
		window.screenY;



------------------------Основы работы с обытиями----------------------------
----Введение в браузерные события
События мыши
	click - клик по элементу ЛКМ
	contextmenu - клик по элементу ПКМ
	dblclick - двойной клик по элементу
	mouseover - при наведении на элемент мышью
	mousedown/mouseup - при нажатии/отжатии кнопки мышью
	mousemove - при движении мыши над элементом
	wheel - вращение колесика мыши
События на элементах управления
	submit - посетитель отправил форму <form>
	focus - посетитель фокусируется на элементе
	select - выбор элемента списка. Генерируется на меню.
Клавиатурные события
	keydown - событие нажатия клавиши
	keyup - событие отпускания клавиши
События документа
	DOMContentLoaded - HTML полностью загружен и обработан, DOM документа построен и доступен.
События CSS
	transitioned - CSS-анимация завершена.
И т.д. ... см. спецификацию.
Назначение обработчиков событий
	Обработчик - функция, срабатывающая когда событие произошло.
	Назначение посредством атрибута в теге
		on<событие> = "код" - атрибут пишется прямо в теге
		Сложную операцию имеет смысл описать в функции, а в атрибуте вызывать эту функцию.
	Назначение с помощью свойства DOM-элемента
		elem.on<событие> = function() {...}
		Внутри обработчика события, this ссылается на текущий элемент
	Назначение при помощи методов
		elem.addEventListener(event, handler[, phase]) - назначить обработчик на elem. Можно назначить несколько обработчиков.
			event - имя события (н.п. "click")addEvent
			handler - ссылка на функцию, которая станет обработчиком
			phase - "фаза", на которой обработчик должен сработать.
				true - на стадии перехвата.
				false - на стадии всплытия.
		elem.removeEventListener(event, handler[, phase]) - удаление обработчика. Нужно передать те же аргументы, что и при назначении.
		
----Порядок обработки событий
Может возникать несколько событий одновременно
Главный поток
	В одном окне (вкладке) может быть тольк один главный поток, который занимается JavaScript, отрисовкой, построением DOM.
	Блокируется при выводе модальных окон
	Web Workers
		Существует спецификация Web	Workers, позволяющая запускать дополнительные JS-процессы. Они могут обмениваться сообщениями с данным потоком. Не имеют доступа к DOM и потому полезны при вычислениях, чтобы распределить нагрузку на несколько ядер процессора.
Очередь событий
	Когда главный поток занят каким-то процессом и в это время происходит какое-либо событие - оно попадает в очередь. Обрабатывается в порядке попадания в очередь
Вложенные (синхронные) события
	Когда собыие инициируется кодом, оно обрабатывается, как правило, синхронно, т.е. вне очереди.
	Например, событие onfocus, можно вызвать явно, методом
		elem.focus() //сфокусируется на элементе и вызовет обработчик
Чтобы сделать обработку onfocus асинхронной, нужно поместить ее в setTimeout, через 0мс (пройдет минимальный тик таймера).

----Объект события
elem.onclick = function(event) {...}
	event.type - тип события (н.п. "click")
	event.currentTarget - элемент, на котором сработал обработчик. Как правило, равен this
	event.clientX/clientY - координаты курсора в момент клика, относительно окна
	event.pageX/pageY - кооддинаты курсора, относительно документа
	есть ряд других свойств, в зависимости от типа события

----Всплытие и перехват
Всплытие - когда при наступлении события, обработчики сначала срабатывают на самом вложенном элементе, затем на его родителе и т.д. То есть события "всплывают" от внутреннего элемента к внешнему.
Самый глубокий элемент, вызвавший событие, доступен как event.target и называется ЦЕЛЕВЫМ или ИСХОДНЫМ.
	event.target - целевой элемент
	this - текущий элемент, до которого дошло событие и на нем выполняется обработчик
event.stopPropagation() - прекращение всплытия события
event.stopImmediatePropagation() - прекращение всплытия и остановка всех обработчиков на текущем месте.
Погружение
	Есть 3 стадии погружения
		1. Событие сначала идет сверху вниз - "стадия перехвата"
		2. Событие достигло целевого элемента - "стадия цели"
		3. После, событие начинает всплывать, задействуя по пути обработчики - "стадия всплытия"
	Номер текущей стадии доступен из event.eventPhFase.
	Обработчики, добавленные через свойство элемента on..., ничего не знают о стадии перехвата.
Чтобы поймать событие на стадии перехвата, нужно использовать третий аргумент addEventListener
	true - событие будет перехвачено на стадии перехвата
	false - событие перехвачено не будет
Бывают события (н.п. focus) которые не всплывают, и перехватить их возможно только на стадии перехвата

----Делегирование событий
Прием разработки, суть которого в том, что когда у нас есть много элементов, обрабатывающихся похожим образом, мы вместо того чтобы ставить обработчик на каждый из них отдельно, ставим обработчик на их общего предка. Из него можно получить целевой элемент event.target.
Можно в скрипте определить объект с методами для разных событий. В data-* атрибуте сохранить произвольное название действия. Присвоить обработчику функцию, которая будет вызывать нужный метод объекта, в зависимости от значения data-* атрибута.

----Прием проектирования "поведение"
Состоит из двух частей:
	1. Элементу ставится атрибут (data-*), описывающий его поведение
	2. При помощи делегирования, ставится обработчик на документ, который ловит все клики и, если элемент имеет нужный атрибут, производит нужное действие.
Можно для каждого атрибута добавлять отдельный обработчик.

----Действия браузера по умолчанию
Это, н.п. переход по урлу, при клике на ссылку и т.п.
Чтобы отменить такие действия
	event.preventDefault();
Если обработчик назначен через on<событие>, можно вернуть false из обработчика
	elem.onclick = function() {return false;}

----Генерация событий на элементах
var event = new Event(тип события[, флаги]) - создание нового события.
	тип события - может быть как своим, так и встроенным
	флаги - объект типа {bubbles: true/false, cancelable: true/false}
		bubbles - всплывает ли событие
		cancelable - можно ли отменить действие по умолчанию
		По умолчанию оба свойства false
Затем, чтобы инициировать событие, запускается elem.dispatchEvent(event). Такое событие действует как событие по умолчанию. Если обработчик вызвал prevetDefaul, то dispatchEvent вернет false;
event.isTrusted - true, если событие вызвано пользователем. Иначе (инициировано программно), равно false.
При программной инициации события, оному можно присвоить и прочие, специфические для него свойства (например, координаты клика мыши), после создания объекта.
	var event = new Event("click", {bubbles: true, cancable: true});
	event.clientX = 100;
	event.clientY = 100;
Помимо общего конструктора Event, есть наследующие конструкторы
	UIEvent
	FocusEvent
	MouseEvent
	WheelEvent
	KeyboardEvent
	CompositionEvent
	В обектах, создаваемых этими конструкторами, можно указать более специфиеские свойства для каждого конкретного типа события.
Для генерации своих событий есть конструктор CustomEvent. Технически, он идентичен Event, но у второго аргумента-объекта есть дополнительное свойство detail, в котором указывается инфа для передачи в событие.
Далее, к этому свойству можно будет обратиться в обработчике, через объект события (event.detail). Вызывается через new.
Старое API для поддержки IE9+
	var event = document.createEvent(eventInterface);
		eventInterface - тип события (MouseEvent, FocusEvent). В документации есть подробный список всех событий
		event. Можно использовать самый общий интерфейс "Event".
	Далее, событие нужно инициализировать:
		event.initEvent(type, bubbles, cancelable).
	Далее, обычным образом, генерируется срабатывание события с поощью dispatchEvent


------------------------События в деталях----------------------------
----Мышь: клики, кнопка, координаты
elem.onclick - повесить обработчик на ЛКМ
elem.oncontextmenu - повесить обработчик на ПКМ
event.which - какая кнопка мыши была нажата
	1 - ЛКМ
	2 - Средняя КМ
	3 - ПКМ
event.shiftKey - true/false, если был зажат shift
event.altKey - аналогично
event.ctrlKey - аналогично
event.metaKey - был зажат Command (для Mac)

----Мышь: отмена выделения, невыделяемые элементы
Чтобы при двойном клике не происходило выделение текста, параллельно с выполнением нашего обработчика, нужно отменить обработку события mousedown (в IE selectstart) по умолчанию (прописать им return false или event.preventDefault()).
При отмене выделения на родителе, все потомки станут невыделяемыми
Есть так же нестандартное CSS свойство user-select. Работает, с префиксом везде, кроме IE9-
	-webkit-user-select: none;
	-moz-user-select: none;
	-ms-user-select: none;
Во всех IE работает атрибут unselectable="on". Не наследуется.
Чтобы запретить копирование текста, необходимо предотвратить выполнение события "copy"
	Атрибут oncopy или через addEventListener: "return false;" или "event.preventDefault();"

----Мышь: движение mouseover/out, mouseenter/leave
Для события mouseover
	event.target - элемент, на который пришла мышь (на котором возникло событие)
	event.relatedTarget - элемент, с которого пришла мышь
Для события mouseout
	event.target - элемент, с которого ушла мышь (на котором возникло событие)
	event.relatedTarget - элемент, на который перешла мышь
relatedTarget может быть равен null, если мышь пришла/ушла из-за/за пределов окна.
mouseover/out срабатывают так быстро, на сколько это позволяет внутренняя система взаимодействия с мышью браузера. При большой скорости движения указателя, на некоторых элементах данные события могут не сработать.
При переходе на потомка, на родителе срабатывает mouseout. При этом, курсор все еще находится внутри родительской области, потому сработают следующие события
	mouseout на родителе
	mouseover на потомке
	mouseover на родителе, т.к. оно всплывет с потомка.
mouseenter/mouseleave - аналогичны mouseover/out, с двумя отличиями
	- не учитываются переходы внутри элемента
	- mouseenter/mouseleave не всплывают

----Мышь: Drag'n'Drop
Алгоритм Drag'n'Drop
	1. Отследить нажати кнопки мыши на элементе, с помощью события mousedown
	2. При нажатии - подготовить элемент к перетаскиванию (задать position: absolute;)
	3. Отслеживания движения мыши через mousemove и перемещение переносимого элемента на новые координаты, путем
	   изменения top/left и position: absolute.
	4. При отпускании кнопки (mouseup), остановить перемещение элемента и выполнить все окончательные двействия.
Браузер имеет собственный Drag'n'Drop. Для избежания конфликтов, его необходимо отключить
	ondragstart="return false;"
В 3 пункте, mousemove необходимо отслеживать на всем document, т.к. при быстром перетаскивании мыши, она может опередить частоту срабатывания события (следовательно и изменения координат элемената) и оказаться не над элементом.
Для захвата мяча за ту точку, в которой, над ним, произошло mousedown, нужно вычесть из координат клика, относительно окна, кордтинаты клика, относительно верхнего левого угла мяча.

----Мышь: Drag'n'Drop более глубоко

----Мышь: колесико событие wheel
Отличие колесика от прокрутки в том, что прокрутка генерирует событие "scroll" над любым прокручиваемым элементом. Приходит когда элемент был прокручен.
wheel генерируется над любым элементом, при движении колесика, до того как элемент будет прокручен.
wheel.deltaY - количество прокрученных пикселей по вертикали. Есть так же deltaX, deltaZ, для других направлений.


----Прокрутка: событие scroll
Событие могут генерировать только прокручиваемые элементы.
Генерируется при любой прокрутке (не только мышкой)
Прокрученние прокрученного пространства с помощью свойств window.pageYOffset или document.scrollTop

----Клавиатура: keyup, keydown, keypress
keyup/keydown происходят при отпускании и нажатии клавиши и позволяют получить код клавиши из свойства keyCode
Скан-код клавиши всегда равен коду соответствующей заглавной английской буквы/цифры.
	Для остальных клавиш - код соответствующего символа пунктуации
keypress происходит сразу после keydown, если нажата символьная клавиша (после появления символа)
	Событие keypress позволяет получить код именно символа.
	Код хранится в совйствах charCode и which
	Поддерживается свойства для специальных клавиш: shiftKey, ctrlKey, altKey, metaKey
В IE, keyCode дает код символа, а не клавиши.
Предотвращение обработки keydown/keypress
	onkeydown="return false", аналогично и с keypress
Можно отменять обработку любых событий, если присвоить им обработчики, которые возвращают false
При keydown/keypress, клавиша еще не обработана браузером, потому обработка клавиш всегда будет опаздывать на одно нажатие. Для исправление этого, можно обрабатывать событие по наступлении keyup или запланировать его setTimeout(..., 0);
При зажатии клавиши, происходит автоповтор собыитий keydown+keypress, свойство объекта-события repeat = true
Поскольку в разных браузерах, на разных ОС, события keypress и keyup могут генерироваться или нет, полагаться стоит только на keydown.

----Загрузка документа: DOMContentLoaded, load, beforeunload, unload
DOMContentLoaded - браузер полностью загрузил HTML и построил DOM-дерево. Можно обрабаывать их в JS.
	
	Проиcходит на document.
	Обработчик вешается только через addEventListener.
		document.addEventListener("DOMContentLoaded", f);
	Если в документе есть теги script (без async и defer), то браузер сначала должен выполнить их, а затем продолжить строить DOM. DOMContentLoaded будет ожидать выполнения таких скриптов.
Если после стиля идет тег со скриптом, то скрипт должет дождаться, пока не загрузится стиль.

window.onload - браузер загрузил все ресурсы и страницу.
beforeunload, unload - уход со страницы. Можно проверить, сохранил ли посетитель изменения, уверен ли он в том что хочет покинуть страницу и т.д. 
	onunload не может отменить переход на другую страницу или закрытие текущей.
	onbeforeunload - должен вернуть строку, которая будет показана в диалоговом окне, наподобие confirm.
		window.onbeforeunload = function() {
			return "Leave site?";
		}

----Загрузка скриптов, картинок, фреймов: onload, onerror
Для отслеживания загрузки различных ресурсов (картинок, скриптов, ифреймов и т.д.) есть два события:
	onload - если загрузка успешна
	onerror - при загрузке произошла ошибка
Для iframe, событие onload срабатывает и при ошибке.


------------------------Формы, элементы управления----------------------------
----Навигация и свойства элементов формы
document.forms[name/index] - получить форму по имени или индексу, в документе
	name - значение атрибута name, в теге формы
	index - порядковый номер формы в документе
form.elements[name/index] - псевдомассив с элементами формы. Смысл аргументов аналогичен document.forms. Не зависит от уровня вложенности.
	Может ьыть несколько элементов с одинаковым именем - тогда elements[name] будет являться коллекцией этих элементов
Свойство elements так же есть и у элемента fieldset
	form.elements["<fieldset_name>"].elements[...]
element.form - получить родительскую форму элемента element.
Для элементов input и textarea, значение хранится и устанавливается через свойство value.
	Для них, лучше не пользоваться свойстом innerHTML
Текущее "отмеченное" состояние для checkbox и radio, хранится в свойстве checked.
select.value - присвоенное значение установит выбор на соответствующий option, value которого равно присвоенному.
select.selectedIndex - установить выбор на элемент списка, с соответствующем порядковым индексом. Отрицательные и другие недопустимые значения очищиют выбор.
select.options[index] - элементы списка.
Есть короткий синтаксис создания элементов списка:
	var option = new Option(text, value, defaultSelected, selected)
		text - содержимое тега
		value - значение, которое будет отправлено на сервер
		defaultSelected, selected - если true, то элемент выбран
У option есть несколько свойств
	option.selected - выбрана ли опция
	option.text - содержимое тега
	option.index - индекс в списке

----Фокусировка: focus/blur
Событие focus - когда элемент получает фокус
Событие blur - когда элемент теряет фокус
Методы elem.blur/elem.focus удаляют/добавляют фокус на элементе
В обработчике blur, метод event.preventDefault() не сработает, т.к. blur наступает после потери фокуса элементом
Атрибут autofocus позволяет автоматически фокусироваться на элементе.
focus/blur не всплывают.
focusin/focusout - то же что focus/blur, только они всплывают. Они не поддерживаются в Firefox.
document.activeElement - текущий элемент, на котором фокус.

----Изменение: change, input, cut, copy, paste
Событие change - происходит, когда изменения в элементе зафиксированы. Например - потеря фокуса на input или нажатие Enter, после ввода.
	Для select, input type="checkbox", оно срабатывает сразу после клика.
Событие input - срабатывает сразу после изменения значения текстового элемента.
Событие propertychange - альтернатива change и input для IE10-. Реагирует на изменение свойств элемента.
События cut/copy/paste - происходят при вырезании/копировании/вставке значения.

----Формы: отправка, событие и метод submit
Событие submit - возникает при отправке формы. Одновременно с оным, генерируется событие click.
Метод form.submit() - для отправки формы из JavaScript


------------------------Создание графических компонентов----------------------------
Виджет - объект, что-то делающий на странице. НП встроенные виджеты - select, input и др.
Он имеет публичные и внутренние методы. К примеру, методы, создающие разметку, на основании данных, переданных его конструктору (options) при создании, навешиает обработчики действий пользователя и т.д.
Обычно, для получения элемента в виджете, не используются id. Обработчики назначаются путем делегирования.
Желательно использовать "ленивую" загрузку компонентов виджета, при необходимости оных.
Обработчик не делает все сам, а вызывает соответствующие метод(ы)
Например, виджет Menu:
	function Menu (options) {
		var elem;

		function getElem() { //return container
			if(!elem) render();
			return elem;
		}

		function render() { //create container with list and add click handler
			elem = document.createElement("div");
			elem.className = "menu";

			var titleElem = document.createElement("span");
			elem.appendChild(titleElem);
			titleElem.className = "title";
			titleElem.textContent = options.title;

			elem.onmousedown = function() {
				return false;
			}

			elem.onclick = function(event) {
				if( event.target.closest(".title") ) {
					toggle();
				}
			}

		}

		function renderItems() { //create ul-list, fill and add to the container
			var items = option.items || [];
			var list = document.createElement("ul");
			items.forEach(function(item) {
				var li = document.createElement("li");
				li.textContent = item;
				list.appendChild(li);
			});
			elem.appendChild(list);
		}

		function open() { //find or create ul-list content and add "open" class to the container
			if(!elem.querySelector("ul"))
				renderItems();
			elem.classList.add("open");
		}

		function close() {
			elem.classList.remove("open");
		}

		function toggle() {
			if(elem.classList.contains("open")) close();
			else open();
		}

		this.getElem = getElem;
		this.toggle = toggle;
		this.open = open;
		this.close = close;
	}

----Верстка графических компонентов
При создании графических компонетов, сначала продумывается их HTML/CSS структура.
Семантическая верстка
	При семантической верстке, разметка и название CSS классов должны отражать не тип оформления, а смысл элемента (кнопка, меню) и его состояние (открыто, отключено, в процессе и т.д.)
Префиксы компонента у классов
	Чтобы избежать конфликтов имен, к названиям классов внутри виджета добавляется префикс с названием класса корневого элемента. Например:
		<div class="dialog">
			<h2 class="dialog__title">...</h2>
			<div class="dialog__content">...</div>
			<div class="dialog__close">Close button</div>
		</div>
	Стили должны вешаться на класс, а не на тег
БЭМ
	Описанное выше правило именования элементов, является частью концепции "БЭМ", разработанной в Яндексе.
	Она предлагает способ организации HTML/CSS/JS в виде независимых блоков, которые можно перемещать по файловой системе и между проектами.

----Шаблонизатор LoDash
Фреймворк, позволяющий динамически генерировать DOM. Основывается на вставках "шаблонов" в документе - строк специального формата, внутри которых выполняется JS код и результат его выполнения подставляется на место шаблонов.
Наподобие phtml-шаблонов в Magento.
Шаблоны заключаются в тег <script>.

---Коллбэки и события на компонентах
Коллбэк - функция, которую мы куда-то передаем извне и ожидаем что она будет вызвана при наступлении события.
События генерируются на корневом элементе, а внешний код ставит обработчики при помощи addEventListener.


















--------------------Стандартные функции JS-------------------------
result = prompt(title, default) - выводит модальное окно, с тектсом title и текстовым полем, заполненным изначально default. Возвращает введенное пользователем значение или null, в случае отмены ввода.
result = confirm(question) - выводит модальное окно с вопросом question и возвращает true, в случае нажатия OK, иначе false

---Рисование фигур на canvas
Methods: https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D

canvas поддерживает рисование только прямоугольника.
Рисование более сложных фигур осуществляется соединением линиями набора точек. Линии называются контурами (paths).
Для 2д контекста:
	ctx.fillRect(x, y, w, h) - нарисовать заполненный прямоугольник
	ctx.strokeRect(x, y, w, h) - нарисовать прямоугольный контур
	ctx.clearRect(x, y, w, h) - очистить прямоугольную область на холсте.
		x, y - координаты верхнего левого угла прямоугольника
		w, h - высота и ширина прямоугольника

Создание контуров осуществляется в несколько шагов:
	1. Спроектировать контур
		ctx.beginPath() - создать новый путь с началом в точке 0,0 на коо, опуская все подпути.
		ctx.moveTo(x, y) - переместить начальную точку текущего подпути нв x,y координаты. Можно это рассматривать как отрыв пера от бумаги и перемещение его в другое место холста.

	2. Используя команды рисования, нарисовать контур
		команды рисования (https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D)
		ctx.lineTo(x, y) - провести линию от текущей точки к точке x,y

	3. Затем закрыть контур
		ctx.closePath() - метод пробует замкнуть фигуру, рисуя линию от текущей точки до начальной.

	4. Созданный контур можно обвести или залить, для его отображения
		ctx.stroke() - рисует фигуру с внешней обводкой.
		ctx.fill() - рисует фигуру с внутренней заливкой. Автоматически замыкает фигуру.

Для рисования дуг и окружностей используются
	ctx.arc(x, y, radius, startAngle, endAngle, antiClockwise)
		x, y - координаты центра окружности, относительно холста
		startAngle - начало угла поворота, в радианах
		endAngle - конец угла поворота в радианах (Math,PI*2 - 360градусов)
		antiClockwise - если true, то окружность рисуется против часовой стрелки

Объект Path2D
	Docs: https://developer.mozilla.org/ru/docs/Web/API/Path2D/Path2D
	Его API, позволяет рисовать пути с большей производительностью и лаконичностью кода, благодаря кешированию оных и возможности записи команд.
	Имеет в себе все path-методы из обычного canvas API