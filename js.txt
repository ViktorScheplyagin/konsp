*************************************************Часть 1**********************************************************

-------------------------Введение--------------------------------
Спецификафия языка называется ECMAScript
babejs - транслятор, который транслирует JS-код, в код более старого стандарта

----Справочники и спецификации
	Mozilla Developer Network - https://developer.mozilla.org/
	MSDN - http://msdn.microsoft.com/ //полезна при разработке под IE
	Safari Developer Library - https://developer.apple.com/library/safari/navigation/index.html
	https://kangax.github.io/compat-table – таблица с обзором поддержки спецификации ECMAScript различными платформами.
	ECMAScript спецификация - http://www.ecma-international.org/publications/standards/Ecma-262.htm


----------------------Основы JavaScript---------------------------
Скрипты можно вставить в любое место html с помощью тега <script>
<meta charset="utf-8"> - тег, для корректного отображения текста в браузере

Современная разметка для <script>
	Атрибут type="text/javascript" - был обязателен в HTML4
	Атрибут language=... - по умолчанию язык - JavaScript

----Подключенные скрипты. Порядок исполнения
Браузер скачает скрипт только первый раз, а затем закеширует его
По умолчанию браузер сначала должен выполнить скрипт, а затем продолжить отображать страницу - такое поведение называется "синхронным"
	<script src="..." async> - скрипт будет загружаться, параллельно с отображением страницы. Когда скрипт будет загружен, он выполнится. Имеет приоритет перед defer. IE9 не поддерживается.
	<script src="..." defer> - То же самое, что и async, но относительный порядок скриптов будет сохранен и скрипт сработает только когда весь документ будет обработан браузером

В имени переменной не долдно быть дефиса
Имя переменной, состоящее из нескольких слов, пишетсяВотТак.
Лучше хранить в переменной что-то одно, а для нового значения объявить новую

----Операторы
typeof x - оператор вернет тип переменной "x"
'1' + 1 = строка '11'. Остальные арифметические операторы всегда приводят операнды к числу
Унарный плюс приведет операнд к числу: +'1' = число 1
Оператор присваивания, еще и возвращает (подобно функции) то значение, которое присвоил переменной
	с = 3 - (а = 2 + 3); //в "с" запишется -2, а в "а" 5
	alert(a);
Оператор "заптая" - a = (5 + 3, 3 * 6). Каждое выражение вычисляется и отбрасывается, а последнее возращается

----Сравнение
Для корректного сравнения строк, они должны быть в одинаковом регистре
При сравнении значений разных типов, применяется ЧИСЛОВОЕ преобразование.
null и undefined равны друд другу и не равны больше ничему
Числовые преобразования:
	null -> 0
	undefined -> NaN

----Логические операторы
Несколько ИЛИ слева направо. При первом true, вся дальнейшая часть конструкции опускается. Возвращается то значение, на котором остановилось вычисление, не преобразованное к логическому типу.
Аналогично с логическим И, только он запинается на ЛЖИ
У логического И приоритет выше чем у ИЛИ, но Короткий Цикл вычислений все равно начинается с слева направо.
	alert( null || 2 && 3 || 4 ); // 3
		то же что и alert( null || (2 && 3) || 4 ), т.е. сначала проверится null, потом проверится 2 && 3 (а не только 2)

----Преобразование типов
строковое преобразование:
	alert() преобразовывает к строке
	String(val) - преобразование явным образом
	Так же оператор "+", у которого один из аргументов строка, преобразует и второй к строке
Численное преобразование:
	При сравнении данных различных типов (кроме операторов строгого стравнения)
	Number(val) - явное преобразование
	Преобразование унарным плюсом
	Численное преобразование типов: //undefined и null при сравнении "==", не приводятся к NaN и 0, а считаются равными
		+undefined //NaN
		+null //0
			null >= 0 //true
			null > 0 и null < 0 //false
		*Для избежания путанницы, лучше не давать специальным значениям учавствовать в сранении*
		+true //1
		+false //0
		+"string" //Пробельные символы по краям обрезаются. Если остается пустая строка, то получаем 0, если не пустая, то из нее считывается число. При ошибке получаем NaN
Логическое преобразование:
	!!value или Boolean(value) - явное логическое преобразование
	Преобразование типов:
		0, '', undefined, NaN, null -> false
		Все остальное, в т.ч. объекты -> true
if выполняет логическое преобразование

----Метки break/continue
break метка / continue метка - выйти из цикла. Ставится перед циклом, из которого необходимо выйти
	outer: //метка
	for(var i=0; i<100; i++){
		for(var j=0; j<100; j++){
			if(j = 98) break outer;
		}
	}
	alert('End of cycle');
	В данном коде произойдет выход из внешнего цикла (перед которым стоит метка) и управление передастся alert(). В случае с continue, вместо выхода, произойдет переход на следующую итерацию внешнего цикла.

----Конструкция switch
Если в кейсе нету брейка, то продолжится выполнение всех нижестоящих кейсов, без проверки условий.
Оператор switch делает строгую проверку (===).

----Функции
Если внутри функции объявить переменную (var) с таким же именем, как у внешней переменной, то внутрянняя переопределит внутри внешнюю переменную
Function Declaration создаются интерпретатором до выполнения кода
В режиме use strict Function Declaration видны только внутри блока кода, в котором объявлены
Еще один способ создания функций. Используется очень редко:
	var sum = new Function('a, b', 'return a+b') //1ый аргумент - параметры, 2й - тело
Значение, на котором заканчивается рекурсия, называют "базисом рекурсии".
Контекст функции - это служебная информация, которая включает в себя локальные переменные и место в цепочке команд, на котором произошел вызов функции.
При вложенных вызовах, контексты хранятся в специальной внутренней структуре данных - стеке контекстов. Для вложенной функции создается новый контекст, а контекст внешней записывается в стек. Когда выполнение вложенной функции завершено, ее контекст удаляется, из стека достается контекст внешней функции и ее выполнение возобновляется.
Именованные функциональные выражения (NFE):
	var f = function sayHi(...){ //имя sayHi доступно только ВНУТРИ самой функции.
		sayHi = 'text' //ошибка. Перезаписать это имя невозможно
	}
	Данное имя используется только для рекурсии
	Если Function Declaration обрамить в круглые скобки, то оно превратится в NFE
		var func = (function f(){...});




------------------------Качество кода------------------------------
----Отладка
debugger; - команда, заставившая отладчик остановиться на ней, как на брейкпойнте

----Советы по стилю кода
Между параметрами пробел
Пробел перед открывающей фигурной скобкой
Пробел после for
Пробелы вокруг операторов
Пустая строка между логическими блоками
else без перевода строки
Пробелы вокруг вложенного вызова функции
Одна функция = одно действие
В начале сложного скрипта архитектурный коментарий (или справочный перед функцией) в формате JSDoc


------------Автоматические тесты при помощи chai и mocha------------
BDD (Behavion Driven Development) = тесты + документация + примеры использования
Разработка функции pow(x, n):
	Сначала пишем спецификацию
		describe("pow", function() {
			it("Возводит в n-ю степень", function() {
				assert.equal(pow(2, 3), 8);
			});
		});

		describe(название, function() { ... }) - задает что именно мы описываем. Используется для группировки "рабочих лошадок" - блоков it.
		it(название, function() { ... }) - в названии человеческим языком описывается что должна делать функция, далее следует тест, который проверяет это.
		Код внутри it, если реализация верна, должен выполняться без ошибок.
		assert.equal(value1, value2) - сравнивает два значения.
	Поток разработки:
		1. Пишется спецификация, описывающая базовый функционал
		2. Делается начальная реализация
		3. Для проверки соответсвия спецификации используем фреймворк (в нашем случае Mocha) который запускает тесты it и выводит ошибки. При ошибках вносятся исправления
		4. Спецификафия расширяется, в нее добавляются возможности, которые, возможно, не поддерживаются реализацией.
		5. Идем в пункт 2 и расширяем реализацию. И так до конца.
	Mocha - содержит общие функции для тестирования, включая describe и it.
	Chai - содержит разнообразные функции для проверок (assert.equal())
	Sinon - для эмуляции и подмены функций "заглушками".

Запуск тестов инициируется командой mocha.run();
Результат тестирования будет выводиться в элемент <div id="mocha"></div>
Если в одном it несколько assert-ов и если один из них обнаружит ошибку, то он сразу же завершает выполнение блока it
Можно создавать отдельные подгруппы тестов, с помощью вложенных describe блоков
before(functions) / after(functions) - можно внутри describe создать блоки функций, которые будут выполнены, соответственно до и после it тестов
beforeEach(functions) / afterEach(functions) - аналогично предыдущим, но функции будут выполнены после каждого it теста
assert(выражение) - выдает ошибку, если выражение, при приведении к логическому типу, не true
assert.strictEqual(value1, value2) - проверка строгого равенства
assert.notEqual(value1, value2), assert.notStrictEqual(value1, value2) - проверка неравенства и строгого неравенства соответственно
assert.isTrue(value) - если value === t
assert.isFalse(value) - если value === false
assert.isNaN(value) - true если value === NaN



------------------------Структуры Данных----------------------------
string.length - длина строки
str.toUpperCase() - возвращает строку в верхнем регистре
num.toFixed(n) - округляет число num до n знаков после запятой, при необходимости, дополняя нулями. Возвращает результат в виде строки.

----Числа
Можно записывать числа в 16-ричной системе счисления, предварив число "0х"
num.toString(система счисления) - получить число в 16-чной системе, в виде строки. Основание системы может быть от 2 до 36
<number>e<quantity of zeroes> - "научный" формат записи числа
isNaN(num) - true, если num === NaN
isFinite(num) - true, если num не равно NaN/+-Infinity
parseInt(num)/parseFloat(num) - посимвольное преобразование строки в целые/дробные числа, пока это возможно. В случае ошибки, возвращается то, что получилось, иначе сразу NaN
Math.floor(num) - округляет вниз
Math.ceil(num) - округляет вверх
Math.round(num) - до ближайшего целого
~~num - двойное побитовое НЕ, обрезает дробную часть, делая число целым
	~~12.3 == 12
Подойдет так же ИСКЛЮЧАЮЩЕЕ ИЛИ с нулем
	12.3 ^ 0 == 12
num.toFixed(precission) - округляет num до точности precission. Возвращает результат в виде строки
num.toLoacleString() - форматированный вывод числа

----Строки
\uNNNN - символ в кодировке юникод, представленный кодом NNNN
str.indexOf(substr[, start_position]) - возвращает позицию искомой подстроки или -1
	if(~str.indexOf(...)) - оператор '~' эквивалентен -(n + 1). Т.е. ? если подстрока не найдена и возвращен -1, он автоматически превращается в 0 (-(-1 + 1)), что интерпретируется if'ом как false
Взятие подстроки:
	str.substring(start [, end]) - возвращиет подстроку со start по end (не включительно). Если end нету, то идет до конца строки. Отрицательные аргументы интерпретируются как равные 0. Слишком большие усекаются до длины строки. Если start > end, то аргументы меняются местами
	str.substr(start, [, length]) - аналогичен предыдущему, только lenght обозначает количество возвращаемых сиволов
	str.slice(start [, end]) - аналогичен substring(). При отрицательных аргументах отсчет идет с конца строки. При выходе за пределы строки, возвращается пустая строка.
String.fromCharCode(code) - получить символ, по его коду Unicode
str.charCodeAt(pos) - возвращает код символа на позиции pos
str.localeCompare(str2) - корректное сравнение строк разных языков

----Объекты
Создание объекта:
	o = new Object(); или o = {};
Удалить свойство:
	delete obj.property;
Проверка на существование свойства:
	if("propertyName" in object_name)
obj.["property"] - доступ к свойству объекта через квадратные скобки
Объекты могут быть вложенными
Перебор свойств:
	for(var key in obj){ //если key числовая строка, то такие свойства, при переборе, сортируются как числа.
		console.log(obj[key]) //доступ через квадратные скобки
	}

----Массивы
Удаление/Добавление элементов:
	arr.pop() - удаляет последний элемент из масива
	arr.push(elem) - добавляет элемент в конец массива. Возвращает добавленный элемент
	arr.shift() - удаляет первый элемент массива
	arr.unshift(elem) - добавляет элемент в начало массива
	Можно так же удалять элемент оператором delete
	arr.length = 0 - очистить массив
	arr.splice(index [, deleteCount, elem1, ..., elemnN]) - удалить deleteCount элементов, начиная с номера index, а затем вставить на их место elem1, ..., elemN. Возвращает массив из удаленных элементов. 
	arr.concat(value1, ... valueN) - присоединяет к концу массива переданные элементы. Можно так же передать массив.
Взятие подмассивов:
	str.split(s [, qty]) - разбивает строку по разделителю s на массив. qty - ограничение на количество элементов вмассиве.
	arr.join(str) - создает из массива строку, разделяя элементы str
	Если номер отрицательный, то отсчет начинается с конца
	all.slice(start, end) - копирует участок массива, со start по end (не включительно). Если end не указан, то копирование будет до конца массива. Отрицательные индексы - отсчет с конца. Вообще без аргументов - скопируется весь массив
Сортировка:
	arr.sort(fn) - сортировка элементов массива. По умолчанию сортирует, преобразовывая элементы к строке.
		fn - функция, принимающая 2 аргумента - сравниваемые элементы. Если функция возвращает положительное значение, то элементы меняются местами.
	arr.reverse() - меняет порядок элементов на обратный
arr.indexOf(elem [, fromIndex]) - возвращает индекс элемента elem или -1, начиная поиск с позиции fromIndex. Для поиска используется строгое стравнение
arr.lastIndexOf(elem [, fromIndex]) - аналогично предыдущему, только начинает поиск с конца.
Object.keys(obj) - возвращает массив ключей объекта
Перебирающие методы:
	arr.forEach(callback, context) - для каждого элемента вызывается функция callback(item, i, arr)
		item - текущий элемент массива
		i - его индекс
		arr - массив, который перебирается
	arr.filter(callback) - создает новый массив с теми элементами, для которых callback(item, i, arr) вернет true
	arr.map(callback) - создает новый массив, с возвращенными результатами callback(item, i, arr), после работы с каждым элементом
	arr.every(callback) - возвращает true, если callback(item, i, arr) вернул true для каждого элемента в массиве
	arr.some(callback) - возвращает true, если callback(item, i, arr) вернул true хотябы для одного элемента в массиве
	arr.reduce(callback [, initialValue]) - применяет callback(previousValue, currentItem, index, arr) к каждому элементу массива, сохраняя промежуточный результат вычислений
		previousValue - последний результат работы метода. Он же "промежуточный результат"
		currentItem - текущий элемента массива, элементы перебираются по очереди, слева направо
		index - номер текущего элемента
		arr - массив который перебираются
		initialValue - начальное значение промежуточного результата. Если этот аргумент не передан, то оно равно первому элементу массива, а перебор осуществляется со второго
	arr.reduceRight() - все аналогично arr.reduce(), но перебор справаналево
Псевдомассив arguments - объект с числовыми ключами и имеющий свойство length. Его значения отвязаны от параметров и не влюяют друг на друга.
Когда очень много параметров, можно в качестве аргумента, передать в функцию объект, свойства которого будут хранить необходимые значения

----Дата и время
Создание даты:
	new Date() - создать объект Date, с текущей датой и временем
	new Date(milliseconds) - создает объект в котором milliseconds миллисекунд, которые считаются прошедшими с 01.01.1970
	new Date(datestring) - Если единственный аргумент - строка, то надо использовать Date.parse для чтения даты из нее
	new Date(year, month, date, hours, minutes, seconds, ms) -  создать дату
		первые 2 аргумента обязательны
		year должен состоять из 4х цифр
		отсутствующие параметры, начиная с hours, считаются равными 0, а date единице
		Номер месяца начинается с 0
		Номер дня в месяце начинается с единицы
Получение компонентов даты:
	getFullYear() - получить год (из 4 цифр)
	getMonth() - получить месяц (от 0 до 11)
	getDate() - получить число дня месяца (от 1 до 31)
	getHours(), getMinutes(), getSeconds(), getMilliseconds() - получить соответствующие компоненты
	getDay() - получить номер дня недели, начиная с воскресения (от 0 до 6)
	getTime() - возвращает количество миллисекунд с 01.01.1970
	getTimezoneOffset() - возвращает разницу между текущей и UTC зонами в минутах
	Все методы возвращают значения для местной временной зоны
	В UTC вариантах все то же самое, только в названиях методов, после "get" ставится "UTC" (getUTCMonth())
Установка компонетов даты:
	setFullYear(year [, month, date])
	setMonth(month [, date])
	setDate(date)
	setHours(hours [, min, sec, ms])
	setMinutes(min [, sec, ms])
	setSeconds(sec [, ms])
	setMilliseconds(ms)
	setTime(ms) - устанавливает всю дату по миллисекундам
	Все методу, кроме setTime() обладают UTC вариантом
	Date автоматически исправляет дату. 32 марта станет 1 апреля. Можно просто прибавлять количество дней к текущему значению
Date в числовом контексте преобразуется в количество миллисекунд. Эти значения можно подвергать арифметическим операциям
Бенчмаркинг:
	performance.now() - возаратит время от момента выгрузки предыдущей страницы из памяти, до места в коде, где этот метод вызван
	console.time(метка) - включить внутренний хронометр браузера. Метка предназначена для идентификации замера
	console.timeEnd(метка) - выключить внутренний хронометр браузера и вывести результат
Форматированный вывод дат:
	toString(), toTimeString(), toDateString() - возвращает стандартное строчное представление, зависящее от браузера. Имеют UTC аналоги
	date.toLocaleString(locale, {options}) - возможны другие варианты использования. Показано использование только для форматированного вывода даты.
		locale = "ru";
		options = {
			weekday: "narrow"/"short"/"long",
			era: "narrow"/"short"/"long",
			year: "numeric"/"2-digit",
			month: "numeric"/"2-digit",
			day: "numeric"/"2-digit",
			hour: "numeric"/"2-digit",
			minute: "numeric"/"2-digit",
			second: "numeric"/"2-digit",
			timeZoneName: "short"/"long"
		}
Разбор строки, Date.parse:
	Формат ISO 8601 Extended: YYYY-MM-DDTHH:mm:ss:sssZ:
		YYYY - год
		MM - месяц
		T - обычный символ. Используется как разделитель
		HH:ss:sss - часы, секунды, миллисекунды соответственно
		Z - временная зона в формате +-hh:mm
	Date.parse(str) - разбирает строку в вышеуказанном формате и возвращает количество мс. Иначе возвращает NaN
Date.now() - вернет текущую дату в миллисекундах
----[[Scope]] для new Function
При создании функции через new Function, ее внутреннее свойство [[Scope]] будет указывать всегда на window, а значит такие функции не могут использовать замыкание
Минификатор переименовывает все локальные переменные на более которкие имена



------------------------Замыкания, область видимости----------------------------
----Глобальный объект
Все глобальные функции и переменные являются свойствами глобального объекта window
Во время инициализации скрипта, функции, объявленные как Function Declaration, создаются сразу работающими, а var-переменные = undefined
Тела конструкций (и блоки инициализации счечиков в циклах) if, while, for, switch и т.п. не влияют на область видимости.
----Замыкания функции
Замыкание - это все внешние переменные, которые доступны функции.
Все переменные внутри функции = это свойства специального внутреннего объекта LexicalEnvironment, который создается при ее запуске.
После выполнения функции, LexicalEnvironment удаляется из памяти.
При обращении к переменной, остутствующей в текущем LexicalEnvironment, интерпритатор ищет ее объявление во внешнем окружении.
В каждом окружении есть свойство-ссылка [[Scope]], которое ссылается на родительское окружение.
[[Scope]] закрыто от прямого доступа.
[[Scope]] никогда не меняется, всюду храня ссылку на окружение в котором она была создана
Функции в JavaScript являются объектом, поэтому можно создавать свойства и у них
	f.test = 5;
	Это свойство так же будет привязано к функции. Отличие от переменной внешнего окружения лишь в том. что свойство можно изменить из внешнего кода, где доступен объект функции:
		f();
		f.test = 7;
----[[Scope]] для new Function
Функции, создаваемые через new Function, имеют значением [[Scope]] не внешний объект переменных, а window
Следствие – такие функции не могут использовать замыкание. Но это хорошо, так как бережёт от ошибок проектирования, да и при сжатии JavaScript проблем не будет. Если же внешние переменные реально нужны – их можно передать в качестве параметров.
----Модули через замыкания
Модуль - подключаемый в html-странице скрипт, в котором весь код заключен в одну функцию.
Сделано так для того, чтобы изолировать его содержимое от "внешнего мира" и избежать конфликта имен
(function() {
	...code...
})() - с помощью FE создается функция и сразу вызывается
Во вне, значения экспортируются двумя способами:
	1) return <var_name>;
	2) window.<var_name> = <value>;
----Управление памятью в JavaScript
Удаление неиспользуемых объектов происходит сборщиком мусора
Критерий выбора объекта для удаления основывается на условии недостижимости кода - когда нет ни одной ссылки на объект
----Устаревшая конструкция with
with(obj) {
	...code...
} - внутри блока в качестве области видимости используется объект obj. Не создает собственной области видимости
Интерпритатор сначала ищет область видимости внутри блока и только потом поиск продолжает во вне
С use strict не работает
Отказались от данной конструкции потому что минификаторы плохо ее обрабатывают и она делает выполнение кода более ресурсоемким
Вместо данной конструкции лучше использовать временную переменную
	var s = elem.style;
	s.top = "10px";
	s.left = "0";


-----------------------------Методы объектов и контекст вызова-----------------------------------
----Методы объектов, this
Для доступа к данным текущего объекта, используется ключевое слово this хранящее ссылку на него
Значение this называется контекстом вызова
Значение this определяется во время выполнения кода
	function f() {
		alert(this.name);
	}
	var one = {name: "Vasya"};
	var two = {name: "Petya"};
	one.f = f; //Значени this будет разным
	two.g = f;
	one.f(); //"Vasya"
	two.g(); //"Petya"
Чтобы контекст передался, нужно вызвать функцию через точку.
Если код функции возвращается каким-либо другим оператором, кроме точки, то контекст изначального объекта теряется.
Возвращать ссылку this на объект может только его собственный МЕТОД. Если попытаться обратиться к СВОЙСТВУ, хранящему this, то контекст теряется
Функция получает контекст только родительского объекта. Иными словами, this внутри функции ссылается только на родительский объект
Объект получает контекст самого первого предка (в браузере это window). Другими словами this в объекте на любом уровне вложенности равен window
Если объявить переменную, внутри функции, через var, то она станет свойством LexicalEnvironment, который удаляется после выполнения функции.
Если же переменную объявить как свойство самой функции (как объкта), то ее значение будет закреплено за ней.

----Преобразование объектов: toString(), valueOf()
Объект преобразовывается в примитив:
	Строковое преобразование - если объект выводится через alert(obj);
		Стандартное представление пользовательского объекта в виде строки "[object Object]"
		Если в объекте присутствует метод toString, то он используется для преобразования
			var obj = {
				name: "Vasya",
				toString:function() {
					return "User " + this.name;
				}
			}
			alert(obj); // "User Vasya"
			Большинство объектов имеют внутреннюю реализацию toString
	Численное преобразование - при арифметических операциях, сравнении с примитивом;
		Для численного преобразования объекта используется метод valueOf, а если его нет, то toString
		У большинства объектов нет valueOf
		Проверка равенства между объектом и примитивом вызывает численное преобразование объекта
	Логическое преобразование - при if(obj) и других логических операциях
		Любой объект в логическом преобразовании true, даже пустой массив [] или объект {}
	Методы toString и valueOf обязаны возвращать примитивный тип, иначе они будут проигнорированы
У объектов Date, метод valueOf возвращает количество миллисекунд, а toString строку с датой. Однако оператор "+" использует у них метод toString, хотя должен valueOf.
Если фигурные скобки {} идут не в выражении, то они считаются блоком кода

----Создание объектов через new
При создании объекта через new, вызывается функция-конструктор.
	function Animal(arg) { //конструкторы принято называть с большой буквы
		this.a = arg;
		this.b = arg + 2;
	}
	var tiger = new Animal(1);

	this получает ссылку на создаваемый объект
	создаются свойства и методы
	возвращается this
Если в конструкторе есть return
	При вызове return с объектом, будет возвращён он, а не this.
	При вызове return с примитивным значением, оно будет отброшено.
В конструкторе можно объявлять локальные переменные и вспомогательные функции. В объект попадет только то, что определяется через this

----Дескрипторы, геттеры и сеттеры свойств
Основной метод для управления свойствами – Object.defineProperty.
	Object.defineProperty(obj, "prop", descriptor)
		obj - имя объекта
		"prop" - имя свойсвта в двойных кавычках
		descriptor - объект имеющий следующие свойства
			value - значение свойства. По умолчанию undefined
			writable - можно ли менять значение свойтсва. По умолчанию false
			configurable - можно ли удалять свойтсва (при помощи оператора delete) или изменять при помощи новых вызовов defineProerty. По умолчанию false
			enumerable - будет ли перечисляться свойство циклом for..in и войдет ли в массив, возвращаемый Object.keys(). По умолчанию false
			get - функция, которая возвращает значение свойства. По умолчанию undefined
				Object.defineProerty(o, "value", {
					get: function() { //можно объявить как свойство дескриптора
						return "Hello";
					}
				}); // Теперь при обращении o.value, при чем без скобок, будет вызываться код функции get()
			set - функции, для установки значения свойства. По умолчанию undefined
					set: function(val) {
						this.value = val;
					}
				}); //Работа функции set
	Запрещено одновременно указывать value или writable совместно с get/set
Можно так же создать get/set прямо в определении объекта
	var o = {
		name: "Vasya",
		surname: "Pupkin",
		
		get fullName() { //или объявить в самом объекте, прописав соответствующее ключевое слово, вместо function
			return this.name + " " + this.surname;
		}
		set fullName(value) {
			var split = value.split(" ");
			this.name = split[0];
			this.surname = split[1];
		}
	}
Другие методы работы со свойствами
	Object.defineProperties(obj, descriptors) - позволяет объявить несколько объектов сразу
		Object.defineProperties(user, { //объект свойства которого названы как свойства в изменяемом объекте. Тут в них записывается объект с дескриптором
			propertyName: {
				...descriptor...
			},
			secondProperty: {
				...descriptor...
			},
			...
		})
Object.keys(obj) - возвращает только enumerable свойства
object.getOwnPropertyNames(obj) - возвращает все свойства
Object.getOwnPropertyDescriptor(obj propName) - возвращает дескриптор указанного свойства
Object.preventExtensions(obj) - запретить добавление новых свойств в объект
object.seal(obj) - запрещает добавление и удаление свойств, все текущие свойства делает configurable: false
Object.freeze(obj) - всем свойствам делает writable: false, configurable: false
Object.isExtensible(obj) - возвращает false, если добавление свойствв объект было запрешено вызовом preventEtensions
Object.isSealed(obj) - true, если у свойств configurable: false
Object.isFrozen(obj) - true, если у свойств configurable: false, writable: false

----Статические и фабричные методы
Статические методы - это функции, которые являются свойствами конструктора
	function Article(){
		Article.count++; //статическое свойство
	}
	Article.showCount() {
		alert(this.count); //this тут равен Article
	}
Фабричные методы - методы конструктора, каждый из которых определенным образом реализует создание объекта
	function User() {
		this.sayHi = function() {
			alert(this.name);
		};
	}

	User.createAnon = function() {
		var user = new User();
		user.name = "Anon";
		return user;
	};

	User.createFromData = function(userData) {
		var user = new User();
		user.name = userData.name;
		user.age = userData.age;
		return user;
	};

	var guest = new User();
	guest.sayHi(); //Anon

	var knowUser = User.createFromData({name: "Vasya", age: 25});
	knowUser.sayHi() //Vasya
Полиморфные конструкторы лучше использовать когда не знаешь какие параметры будут переданы

----Явное указание через this: "call", "apply"
Метод call
	func.call(context, arg1, arg2, ...) - вызывается функция func, в контексте context и аргументами arg1, arg2, ...
Метод apply
	func.apply(context, [arg1, arg2, ...]) - то же что и call, но вместо списка принимает массив аргументов
func.apply/или call/.(this, args) - this будет равен func

----Привязка контекста и карринг: "bind"
func.bind(Context [, arg1 arg2, ...]) - возвращает код функции, привязанной к контексту Context. Если указаны аргументы arg1, arg2, ... то они будут добавлены перед аргументами в вызовах возвращенной функции, т.е. как бы "фиксируем" аргументы.
Карринг - создание новой функции, путем фиксирования аргументов старой
	function mul(a, b) {
		return a * b;
	}
	var double = mul.bind(null, 2) //контектс null (он нам не нужен), второй аргумент (множитель) фиксируем 2
	duoble(3); //умножит на 2
double является "частичной функцией" от mul

----Функции-обертки, декораторы
Декоратор - функция, которая возвращает оберку вокруг целевой функции.
	function isAdmin(){...} //проверка наличия прав администратора
	function save() {...} //сохранить результаты дейтсвий
	function checkPermissionsAdmin(f) {
		return function() {
			if( isAdmin() ) {
				return f.apply(this, arguments);
			}
			alert("Нет прав доступа");
		}
	}

	save = checkPermissionsAdmin(save); //теперь, при вызове save, всегда будет происходить проверка прав администратора


------------------------Некоторые другие возможности----------------------------
----Типы данных: [[Class]], instanceof и утки
Во всех встроенных объектах есть специальное внутреннее свойство [[Class]], которое хранит информацию о его типе или конструкторе. Явно получить его нельзя.
Свойство toString стандартного объекта Object выводит [[Class]] в формате "[object значение]".
	{}.toString.call(new Date); //"[object Date]";
Можно использовать и с примитивами
	{}/toString.call(123); //"[object Number]"
Array.isArray(arr) - возвратит true, если arr массив. Иначе false
user instanceof User - оператор вернет true, если объект user был создан конструктором User
Утиная типизация - можно проверить что массив является таковым и без Array.isArray(). Например, если у массива есть типичный для него метод 	splice.
	if(arr.splice) {} //Конечно, такую проверку можно обойти, но в этом есть смысл утиной типизации. Т.е. будем тогда работать с этим как с массивом.
	//"Если нечто выглядит как утка, плавает как утка, то, вероятнее всего, это утка (не важно что это на самом деле)"
	Иными словами, duck tying - это проверка реализации объектом определенного интерфейса

----Формат JSON, метод toJSON
Это промежуточный формат, для передачи данных в виде стоки.
	 - JavaScript-объекты
	 - Массивы
	 - Строки в двойных кавычках
	 - Число
	 - Логическое значение true/false
	 - null
Строки в JSON-объектах должны быть в двойных кавычках
В формате JSON не поддерживаются комментарии
Методы для работы с JSON
	JSON.parse(str, reviewer) - читает объект из JSON-строки
		reviewer - функция function(key,value)
			key - ключ в объекте
			value - его значение
			Пример:
				//Если объект имеет несколько уровней вложенности, то reviewer проходится и по ним
				var str = '{"title":"Конференция","date":"2014-11-30T12:00:00.000Z"}';

				var event = JSON.parse(str, function(key, value) {
				  //если ключ с именем date (подразумеваем что он хранит дату), то создаем объект с датой
				  if (key == 'date') return new Date(value);
				  return value;
				});
	JSON.stringify(value, replacer, space) - преобразует («сериализует») значение в JSON-строку.
		value - объект, подлежащий сериализации
		replacer - массив свойств, подлежащих сериализации (ключи в двойных кавычках). Либо можно передать function(key, value), которая возвращает сериализованное value или undefined, если его не нужно включать в результат. replacer-функция работает рекурсивно.
		space - если передано число, то уровни вложенности объекта отмечаются указанным числом пробелов, если строка - вставляется эта строка.

При сериализации объекта, вызывается его встроенный метода toJSON (например, сериализация даты). Если такой метод отсутствует, то JSON строка будет содержать перечисление свойств и их значений (без методов).
Можно создать свой метод toJSON, тогда в строку попадет то, что указано в return

----setTimeout и setInterval
var timerId = setTimeout(func, delay[, arg1, arg2, ...]) - возвращает числовой идентификатор таймера, который можно использовать для отмены дейтсвия
	func - функция или строка кода для исполнения. Строку кода использовать не рекомендуется
	delay - задержка в мс.
	arg1, arg2, ... - аргументы, которые нужно передать функции.
clearTimeout(timerId) - удалить таймер
var timerId = setInterval(func, delay[, arg1, arg2, ...]) - смысл аргументов аналогичен setTimeout, только func запускается циклически. Время выполнения func не учитывается.
clearInterval(timerId) - удалить интервал
Рекурсивный setTimeout
	var timerId = setTimeout(function tick() {
		alert("tick!");
		timerId = setTimeout(tick, 2000);
	}, 2000)
	Более гибкий способ отсроченного вызова, т.к. каждый раз можно время интервала задавать разное.
	Время выполнения func учитывается, т.к. следующий отсроченный вызов происходит только после выполнения текущего.
Пример 1:
	setTimeout(function() {
		alert( i );
	}, 100);

	hardWork() //выполняется дольше 100мс
	В данном примере, пока setTimeout держит паузу (и ничего еще не вызвано), запускается hardWork. Пока hardWork выполняется, уже подошлп очередь запуска функции setTimeout. Как только hardWork выполнился, сразу вызывается функция в setTimeout.
Пример 2:
	var timer = setInterval(function() {
	  i++;
	}, 10);

	setTimeout(function() {
	  clearInterval(timer);
	  alert( i ); // (*)
	}, 50);

	var i;

	function f() {
	  // точное время выполнения не играет роли
	  // здесь оно заведомо больше 100 мс
	  for (i = 0; i < 1e8; i++) f[i % 2] = i;
	}

	f();

	Пока setInterval ждет паузу, щапустится f. Пока выполняется f, дойдет очередь до вызовов setInterval, но интерпретатор в это время же занят f. После выполнения f, будет только один раз вызван setInterval и сразу же setTimeout, очередь которого уже тоже подошла. Т.е. накопления вызовов не происходит.






















--------------------Стандартные функции JS-------------------------
result = prompt(title, default) - выводит модальное окно, с тектсом title и текстовым полем, заполненным изначально default. Возвращает введенное пользователем значение или null, в случае отмены ввода.
result = confirm(question) - выводит модальное окно с вопросом question и возвращает true, в случае нажатия OK, иначе false
