*************************************************Часть 1**********************************************************

-------------------------Введение--------------------------------
Спецификафия языка называется ECMAScript
babejs - транслятор, который транслирует JS-код, в код более старого стандарта

----Справочники и спецификации
	Mozilla Developer Network - https://developer.mozilla.org/
	MSDN - http://msdn.microsoft.com/ //полезна при разработке под IE
	Safari Developer Library - https://developer.apple.com/library/safari/navigation/index.html
	https://kangax.github.io/compat-table – таблица с обзором поддержки спецификации ECMAScript различными платформами.
	ECMAScript спецификация - http://www.ecma-international.org/publications/standards/Ecma-262.htm


----------------------Основы JavaScript---------------------------
Скрипты можно вставить в любое место html с помощью тега <script>
<meta charset="utf-8"> - тег, для корректного отображения текста в браузере

Современная разметка для <script>
	Атрибут type="text/javascript" - был обязателен в HTML4
	Атрибут language=... - по умолчанию язык - JavaScript

----Подключенные скрипты. Порядок исполнения
Браузер скачает скрипт только первый раз, а затем закеширует его
По умолчанию браузер сначала должен выполнить скрипт, а затем продолжить отображать страницу - такое поведение называется "синхронным"
	<script src="..." async> - скрипт будет загружаться, параллельно с отображением страницы. Когда скрипт будет загружен, он выполнится. Имеет приоритет перед defer. IE9 не поддерживается.
	<script src="..." defer> - То же самое, что и async, но относительный порядок скриптов будет сохранен и скрипт сработает только когда весь документ будет обработан браузером

В имени переменной не долдно быть дефиса
Имя переменной, состоящее из нескольких слов, пишетсяВотТак.
Лучше хранить в переменной что-то одно, а для нового значения объявить новую

----Операторы
typeof x - оператор вернет тип переменной "x"
'1' + 1 = строка '11'. Остальные арифметические операторы всегда приводят операнды к числу
Унарный плюс приведет операнд к числу: +'1' = число 1
Оператор присваивания, еще и возвращает (подобно функции) то значение, которое присвоил переменной
	с = 3 - (а = 2 + 3); //в "с" запишется -2, а в "а" 5
	alert(a);
Оператор "заптая" - a = (5 + 3, 3 * 6). Каждое выражение вычисляется и отбрасывается, а последнее возращается

----Сравнение
Для корректного сравнения строк, они должны быть в одинаковом регистре
При сравнении значений разных типов, применяется ЧИСЛОВОЕ преобразование.
null и undefined равны друд другу и не равны больше ничему
Числовые преобразования:
	null -> 0
	undefined -> NaN

----Логические операторы
Несколько ИЛИ слева направо. При первом true, вся дальнейшая часть конструкции опускается. Возвращается то значение, на котором остановилось вычисление, не преобразованное к логическому типу.
Аналогично с логическим И, только он запинается на ЛЖИ
У логического И приоритет выше чем у ИЛИ, но Короткий Цикл вычислений все равно начинается с слева направо.
	alert( null || 2 && 3 || 4 ); // 3
		то же что и alert( null || (2 && 3) || 4 ), т.е. сначала проверится null, потом проверится 2 && 3 (а не только 2)

----Преобразование типов
строковое преобразование:
	alert() преобразовывает к строке
	String(val) - преобразование явным образом
	Так же оператор "+", у которого один из аргументов строка, преобразует и второй к строке
Численное преобразование:
	При сравнении данных различных типов (кроме операторов строгого стравнения)
	Number(val) - явное преобразование
	Преобразование унарным плюсом
	Численное преобразование типов: //undefined и null при сравнении "==", не приводятся к NaN и 0, а считаются равными
		+undefined //NaN
		+null //0
			null >= 0 //true
			null > 0 и null < 0 //false
		*Для избежания путанницы, лучше не давать специальным значениям учавствовать в сранении*
		+true //1
		+false //0
		+"string" //Пробельные символы по краям обрезаются. Если остается пустая строка, то получаем 0, если не пустая, то из нее считывается число. При ошибке получаем NaN
Логическое преобразование:
	!!value или Boolean(value) - явное логическое преобразование
	Преобразование типов:
		0, '', undefined, NaN, null -> false
		Все остальное, в т.ч. объекты -> true
if выполняет логическое преобразование

----Метки break/continue
break метка / continue метка - выйти из цикла. Ставится перед циклом, из которого необходимо выйти
	outer: //метка
	for(var i=0; i<100; i++){
		for(var j=0; j<100; j++){
			if(j = 98) break outer;
		}
	}
	alert('End of cycle');
	В данном коде произойдет выход из внешнего цикла (перед которым стоит метка) и управление передастся alert(). В случае с continue, вместо выхода, произойдет переход на следующую итерацию внешнего цикла.

----Конструкция switch
Если в кейсе нету брейка, то продолжится выполнение всех нижестоящих кейсов, без проверки условий.
Оператор switch делает строгую проверку (===).

----Функции
Если внутри функции объявить переменную (var) с таким же именем, как у внешней переменной, то внутрянняя переопределит внутри внешнюю переменную
Function Declaration создаются интерпретатором до выполнения кода
В режиме use strict Function Declaration видны только внутри блока кода, в котором объявлены
Еще один способ создания функций. Используется очень редко:
	var sum = new Function('a, b', 'return a+b') //1ый аргумент - параметры, 2й - тело
Значение, на котором заканчивается рекурсия, называют "базисом рекурсии".
Контекст функции - это служебная информация, которая включает в себя локальные переменные и место в цепочке команд, на котором произошел вызов функции.
При вложенных вызовах, контексты хранятся в специальной внутренней структуре данных - стеке контекстов. Для вложенной функции создается новый контекст, а контекст внешней записывается в стек. Когда выполнение вложенной функции завершено, ее контекст удаляется, из стека достается контекст внешней функции и ее выполнение возобновляется.
Именованные функциональные выражения (NFE):
	var f = function sayHi(...){ //имя sayHi доступно только ВНУТРИ самой функции.
		sayHi = 'text' //ошибка. Перезаписать это имя невозможно
	}
	Данное имя используется только для рекурсии
	Если Function Declaration обрамить в круглые скобки, то оно превратится в NFE
		var func = (function f(){...});




------------------------Качество кода------------------------------
----Отладка
debugger; - команда, заставившая отладчик остановиться на ней, как на брейкпойнте

----Советы по стилю кода
Между параметрами пробел
Пробел перед открывающей фигурной скобкой
Пробел после for
Пробелы вокруг операторов
Пустая строка между логическими блоками
else без перевода строки
Пробелы вокруг вложенного вызова функции
Одна функция = одно действие
В начале сложного скрипта архитектурный коментарий (или справочный перед функцией) в формате JSDoc


------------Автоматические тесты при помощи chai и mocha------------
BDD (Behavion Driven Development) = тесты + документация + примеры использования
Разработка функции pow(x, n):
	Сначала пишем спецификацию
		describe("pow", function() {
			it("Возводит в n-ю степень", function() {
				assert.equal(pow(2, 3), 8);
			});
		});

		describe(название, function() { ... }) - задает что именно мы описываем. Используется для группировки "рабочих лошадок" - блоков it.
		it(название, function() { ... }) - в названии человеческим языком описывается что должна делать функция, далее следует тест, который проверяет это.
		Код внутри it, если реализация верна, должен выполняться без ошибок.
		assert.equal(value1, value2) - сравнивает два значения.
	Поток разработки:
		1. Пишется спецификация, описывающая базовый функционал
		2. Делается начальная реализация
		3. Для проверки соответсвия спецификации используем фреймворк (в нашем случае Mocha) который запускает тесты it и выводит ошибки. При ошибках вносятся исправления
		4. Спецификафия расширяется, в нее добавляются возможности, которые, возможно, не поддерживаются реализацией.
		5. Идем в пункт 2 и расширяем реализацию. И так до конца.
	Mocha - содержит общие функции для тестирования, включая describe и it.
	Chai - содержит разнообразные функции для проверок (assert.equal())
	Sinon - для эмуляции и подмены функций "заглушками".

Запуск тестов инициируется командой mocha.run();
Результат тестирования будет выводиться в элемент <div id="mocha"></div>
Если в одном it несколько assert-ов и если один из них обнаружит ошибку, то он сразу же завершает выполнение блока it
Можно создавать отдельные подгруппы тестов, с помощью вложенных describe блоков
before(functions) / after(functions) - можно внутри describe создать блоки функций, которые будут выполнены, соответственно до и после it тестов
beforeEach(functions) / afterEach(functions) - аналогично предыдущим, но функции будут выполнены после каждого it теста
assert(выражение) - выдает ошибку, если выражение, при приведении к логическому типу, не true
assert.strictEqual(value1, value2) - проверка строгого равенства
assert.notEqual(value1, value2), assert.notStrictEqual(value1, value2) - проверка неравенства и строгого неравенства соответственно
assert.isTrue(value) - если value === t
assert.isFalse(value) - если value === false
assert.isNaN(value) - true если value === NaN



------------------------Структуры Данных----------------------------
string.length - длина строки
str.toUpperCase() - возвращает строку в верхнем регистре
num.toFixed(n) - округляет число num до n знаков после запятой, при необходимости, дополняя нулями. Возвращает результат в виде строки.

----Числа
Можно записывать числа в 16-ричной системе счисления, предварив число "0х"
num.toString(система счисления) - получить число в 16-чной системе, в виде строки. Основание системы может быть от 2 до 36
<number>e<quantity of zeroes> - "научный" формат записи числа
isNaN(num) - true, если num === NaN
isFinite(num) - true, если num не равно NaN/+-Infinity
parseInt(num)/parseFloat(num) - посимвольное преобразование строки в целые/дробные числа, пока это возможно. В случае ошибки, возвращается то, что получилось, иначе сразу NaN
Math.floor(num) - округляет вниз
Math.ceil(num) - округляет вверх
Math.round(num) - до ближайшего целого
~~num - двойное побитовое НЕ, обрезает дробную часть, делая число целым
	~~12.3 == 12
Подойдет так же ИСКЛЮЧАЮЩЕЕ ИЛИ с нулем
	12.3 ^ 0 == 12
num.toFixed(precission) - округляет num до точности precission. Возвращает результат в виде строки
num.toLoacleString() - форматированный вывод числа

----Строки
\uNNNN - символ в кодировке юникод, представленный кодом NNNN
str.indexOf(substr[, start_position]) - возвращает позицию искомой подстроки или -1
	if(~str.indexOf(...)) - оператор '~' эквивалентен -(n + 1). Т.е. ? если подстрока не найдена и возвращен -1, он автоматически превращается в 0 (-(-1 + 1)), что интерпретируется if'ом как false
Взятие подстроки:
	str.substring(start [, end]) - возвращиет подстроку со start по end (не включительно). Если end нету, то идет до конца строки. Отрицательные аргументы интерпретируются как равные 0. Слищком большие усекаются до длины строки. Если start > end, то аргументы меняются местами
	str.substr(start, [, length]) - аналогичен предыдущему, только lenght обозначает количество возвращаемых сиволов
	str.slice(start [, end]) - аналогичен substring(). При отрицательных аргументах отсчет идет с конца строки
String.fromCharCode(code) - получить символ, по его коду Unicode
str.charCodeAt(pos) - возвращает код символа на позиции pos
str.localeCompare(str2) - корректное сравнение строк разных языков

----Объекты
Создание объекта:
	o = new Object(); или o = {};
Удалить свойство:
	delete obj.property;
Проверка на существование свойства:
	if("propertyName" in object_name)
obj.["property"] - доступ к свойству объекта через квадратные скобки
Объекты могут быть вложенными
Перебор свойств:
	for(var key in obj){ //если key числовая строка, то такие свойства, при переборе, сортируются как числа.
		console.log(obj[key]) //доступ через квадратные скобки
	}

----Массивы
arr.pop() - удаляет последний элемент из масива
arr.push(elem) - добавляет элемент в конец массива
arr.shift() - удаляет первый элемент массива
arr.unshift(elem) - добавляет элемент в начало массива
Можно так же удалять элемент оператором delete
arr.length = 0 - очистить массив









--------------------Стандартные функции JS-------------------------
result = prompt(title, default) - выводит модальное окно, с тектсом title и текстовым полем, заполненным изначально default. Возвращает введенное пользователем значение или null, в случае отмены ввода.
result = confirm(question) - выводит модальное окно с вопросом question и возвращает true, в случае нажатия OK, иначе false
