-----------------------------XMLHttpRequest основы--------------------------------
XMLHttpRequest, как правило, используют для загрузки данных. Конструктор для объекта, методы которого посылают запросы.
var xhr = new XMLHttpRequest();

xhr.open(method, URL, async, user, password) - задает основные параметры запроса
	method - http-метод. GET или POST. Бывают и более редкие TRACE/DELETE/PUT и т.д.
	URL - адрес запроса, с указанием протокола (http/https://..., ftp://..., file://)
		При этом есть ограничение безопасности ("Same Origin Policy") - запрос со страницы можно отправлять только на тот же протокол://домен:порт с которого она пришла. Это можно обойти.
	async - true/false. Произвести запрос асинхронно/синхронно. По умолчанию true.
		Если синхронных запрос - после вызова xhr.send() и до ответа, главный поток будет "замрожен". Страница "зависнет".
		Асинхронный - наоборот. Результат запроса можно будет получить через обработчики событий.
	user, password - данные для http-авторизации, если они нужны.
xhr.send([body]) - отсылает, настроенный в xhr.open(), запрос.
	body - тело запроса
xhr.abort() - прервать выполнение запроса.

Свойства, составляющие ответ сервера, так же записываются в xhr
xhr.status - http-код ответа (200, 404 и т.д.). Может быть 0, если сервер не ответил при запросе на другой домен.
xhr.statusText - текстовое описание статуса (OK, Not Found, Forbidden и т.д.)
xhr.responseText - текст ответа сервера.
xhr.responseXML - если сервер вернул XML с заголовком Content-type: text/xml, то браузер создаст из него xml-документ.
	Обычно возвращается json, а не xml, и преобразовывается в объект JSON.parse(xhr.responseText).

Событие readystatechange - в процессе отправки и получения ответа меняется несколько раз.
	Можно посмотреть текущее значение в свойстве xhr.readyState.
	Список возможных состояний:
		UNSENT = 0
		OPENED = 1
		HEADERS_RECEIVED = 2
		LOADING = 3 //загружается тело. Повторяется при каждом получении пакета данных
		DONE = 4
Во время пересылки данных по сети, мы не управляем, в каких местах данные делятся на пакеты.

HTTP-заголовки
	xhr.setRequestHeader(name, value) - установить заголовок name со значением value.
		Нельзя установить заголовки, контроллируемые браузером (Referer, Host и др.)
		Невозможно отменить установленный заголовок. Повторный вызов добавит информацию к существующему.
	xhr.getResponseHeader(name) - получить значение заголовка name (кроме Set-Cookie и Set-Cookie2).
	xhr.getAllResponseHeaders() - получить все заголовки ответа, в виде одной строки, кроме Set-Cookie и Set-Cookie2.
	xhr.timeout - максимальная продолжительность выполнения асинхронного запроса, в мс.
		При превышении таймаута, выполнение запроса прервется и будет сгенерировано событие ontimeout.
События по ходу выполнения запроса:
	loadstart - запрос начат.
	progress - получен очередной пакет данных. Полученные, в данный момент, данные можно прочитать в responseText
	abort - отменено, вызовом xhr.abort().
	error - произошла ошибка.
	load - запрос успешно заверщен (без ошибок)
	timeout - прервано по таймауту
	loadend - запрос завершен (успешно или неуспешно)

--------------------------XMLHttpRequest POST, формы и кодировка------------------------------
Во время обычной отправки <form>, браузер собирает значения ее полей и составляет из них тело запроса. При отправке данных через XMLHttpRequest, это делается самостоятельно.
Стандартное кодирование URL - кодировка urlencoded.
Правила составления запроса:
	Браузер перечисляет пары "имя"="значение" через &
	Все символы, кроме английских букв, цифр и символов - _ . ! ~ * ' ( ), заменяются на их UTF-8 код, со знаком % между каждым байтом.
encodeURIComponent(str) - возвращает закодированную строку str в urlencoded кодировке.
Например:
	let params = 'name=' + encodeURIComponent('name') + '&surname=' + encodeURIComponent('surname');
	xhr.open('GET', '/submit?' + params, true);
	Такую отправку формы сервер не отличит от обычной.

В методе POST, параметры передаются не в URL, а в теле запроса.
send(body) - передать запрос с телом body.
В зависимости от значения атрибута enctype, у тега <form>, браузер кодирует данные разным образом, перед отправкой на сервер. Для метода POST, доступны 3 значения:
	application/x-www-form-urlencoded
	multipart/form-data
	text-plain
При POST, обязателен заголовок Content-Type.
	Например: xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
Всегда используется кодировка UTF-8 по умолчанию.
Кодировка multipart/form-data
	Можно пересылать данные каждого поля формы отдельно.
	Поля разделяются случайно сгенерированной строкой "разницей" ("boundary"), которая может иметь в себе до 70 символов, без пробела. 
	let data = {
		name: "Lorem",
		surname: "Ipsum"
	}

	let boundary = String(Math.random()).slice(2);
	let boundaryMiddle = '--' + boundary + '\r\n';
	let boundaryLast = '--' + boundary + '--\r\n';

	let body = ['\r\n'];
	for(let key in data) {
		body.push('Content-Desposition: form-data; name="' + key + '"\r\n\r\n' + data[key] + '\r\n');
	} //каждая отдельная часть содержится в значении заголовка Content-Desposition
	body = body.join(boundaryMiddle) + boundaryLast;

	//тело готово. Отправляем
	let xhr = new XMLHttpRequest();
	xhr.open('POST', '/url');
	xhr.setRequestHeader('Content-Type', 'multipart/form-data; boundary=' + boundary);
	
	xhr.onreadystatechange = () => {
		if(xhr.readyState != 4) return;
		alert(xhr.responseText);
	}

	xhr.send(body);

Отправка файла (например, картинка)
	Так же, через post, но заголовки должны быть следующими:
	Content-Desposition: form-data; name='myfile'; filename='pic.jpg'
	Content-Type: image/jpeg
	(пустая строка)
	содержимое файла

Объект FormData 
	Позволяет добавить данные к форме (если передано в аргументах) или создать пустой объект, который потом можно будет отправить как форму (xhr.send(formData))
	Пример:
		html:
			<form name="person">
				<input name="name" value="Lorem" />
				<input name="surname" value="Ipsum" />
			</form>
		JS:
			let formData = new FormData(document.forms.person); //либо без аргументов, либо с DOM элементом формы
			formData.append('patronym', 'Robertovich'); //добавить еще данные в виде "ключ, значение" к форме, для пересылки

			let xhr = new XMLHttpRequest();
			xhr.open('POST', '/url');
			xhr.send(formData);

	Объект FormData можно сразу отсылать. Его интеграция с XMLHttpRequest встроена в браузер. Кодировка будет multipart/form-data.
Использование JSON:
	let xhr = new XMLHttpRequest();

	let json = JSON.stringify({
		name: "Lorem",
		surname: "Ipsum"
	});

	xhr.open('POST', '/url', true);
	xhr.setRequestHeader('Content-Type', 'application/json; charset=utf-8');

	xhr.onreadystatechange = ...;
	xhr.send(json);


--------------------------XMLHttpRequest POST: кросс-доменные запросы------------------------------
Запрос на другой домен отсылается просто указанием URL в .open().
Запрос обязательно должен быть асинхронным.
В спецификации CORS, запросы делятся на 2 вида:
	Простые - которые удовлетворяют 2м условиям
		1. Простой метод: GET, POST, HEAD
		2. Простые заголовки
			Accept;
			Accept-Language;
			Content-Language;
			Content-Type со значением application/x-www-form-urlencoded, multipart/form-data, text/plain
	"Непростыми" счиаются все остальные

	Разница между ними заключается в том, что простые можно сформировать и отправить без XMLHttpRequest, Н/П с помощью формы.
В спецификации CORS есть один общий принцип: все новые возможности стандарта доступны только с явного согласия сервера.

В кросс-доменный запрос браузер автоматически обавляет заголовок Origin, содержащий домен, с которого осуществлен запрос.
	Если сревер разрешает такой запрос к себе, то его ответ должен содержать заголовок Access-Control-Allow-Origin со значением '*'
	или доменом, откуда пришел запрос и будет событие onload. Иначе, браузер посчитает что сервер запретил этот запрос и будет ошибка onerror.
	При данном запросе не передаются куки и заголовки HTTP-авторизации. Параметры user и password в open игнорируются. Это возможно обойти.
Заголовки ответа:
	Чтобы JS мог прочитать заголовок из ответа, сервер должен указать его имя в заголовке Access-Constrol-Expose-Headers
		HTTP/1.1 200 OK
		Content-Type:text/html; charset=UTF-8
		Access-Control-Allow-Origin: http://javascript.ru
		X-Uid: 123
		X-Authorization: 2c9de507f2c54aa1
		Access-Control-Expose-Headers: X-Uid, X-Authorization
	По умолчанию, скрипт может прочитать только простые заголовки:
		Cache-Control
		Content-Language
		Content-Type
		Expires
		Last-Modified
		Pragma
Запросы от имени пользователя:
	Чтобы передать вместе с запросом куки и HTTP-авторизацию, нужно установить параметр
		xhr.withCredentials = true
	При запросе с withCredentials, сервер возвращает уже 2 заголовка:
		Access-Control-Allow-Origin: домен
		Access-Contol-Allow-Credentials: true //использование "*" запрещено
	Ранее не предполагалось что страница сможет делать другие запросы, помимо POST/GET. Серверы, написанные ранее, предполагают что это не браузер.
	Чтобы предотвратить "недопонимания", браузер делает предзапрос (preflight), в случаях, когда:
		- Если метод не GET/POST/HEAD
		- Если заголовок Content-Type не:
			application/x-wwww-form-urlencoded
			multipart/form-data
			text/plain
			application/xml
		- Если заголовки отличные от:
			Accept
			Accept-Language
			Content-Language
	Предзапрос:
		- использует метод OPTIONS;
		- не имеет тела;
		- содержит имя желаемого метода в заголовке Access-Control-Request-Method;
		- содержит имена желаемых заголовков в заголовке Access-Control-Request-Headers;


---------------------------------XMLHttpRequest: индикация прогресса-------------------------------------------
XHR запрос состоит из:
	1. Стадия закачки (upload). Для POST-запросов она может быть долгой. Для отслеживания прогресса на стадии закачки существует объект типа XMLHttpRequestUpload, доступный как xhr.upload и события на нем.
	2. Стадия скачивания (download). После стадии 1, браузер скачивает ответ с сервера, который так же может быть большой. На этой стадии используется обработчик xhr.onprogress.
Стадия закачки:
	Объект xhr.upload не имеет методов и служит лишь для генерации следующих событий:
		- loadstart
		- progress
		- abort
		- error
		- load
		- timeout
		- loadend
	Обработчики устанавливаются как обычно, например:
		xhr.upload.onprogress = () => {...}
Стадия скачивания:
	xhr.upload не нужен, тут обработчики навешиваются уже на сам xhr.
	событие xhr.onprogress - содержит информацию о количестве загруженных байт ответа.
		xhr.onprogress = (e) => {
			console.log(e.loaded) //получено байт
			console.log(e.total) //полный объем ответа
		}
Все события, возникающие в этих обработчиках, имеют тип ProgressEvent т.е. имеют свойства e.loaded и e.total

Демо: загрузка файла с индикатором прогресса
	Можно отправить на сервер любые данные. Для этого требуется поддержка File API.
	Разметка:
		<form name='upload'>
			<input type='file' name='myfile'>
			<input type='submit' value='Download'>
		</form>
	Скрипт:
		document.forms.upload.onsubmit = () => {
			let input = this.elements.myfile;
			let file = input.files[0];
			if(file) {
				upload(file);
			}
			return false;
		}

		function upload(file) {
			let xhr = new XMLHttpRequest();

			xhr.upload.onprogress = (e) => { log(`${e.loaded} / ${e.total}`); }

			xhr.onload = xhr.onerror = () => {
				if(this.status == 200) {
					log('success');
				} else {
					log('error ' + this.status);
				}
				
				xhr.open('POST', 'upload');
			}
		}

Событие onprogress в деталях:
	Событие, возникающее на стадии закачки на сервер (xhr.upload.onprogress) и на стадии получения ответа (xhr.onprogress), имеют тип ProgressEvent со следующими свойствами:
		loaded - сколько байт перенесено (только тело, без учета заголовков)
		lengthComputable - если true, то известно полное количество байт в свойстве total.
		total - полное количество байт для пересылки.

	При закачке данных на сервер, общее количество байт всегда известно.
	При скачивании с сервера, сервер сначала сообщает общее количество в заголовке Content-Length. Однако этого может не произойти, если сервер сам не знает или генерирует данные на лету. Тогда total будет равен 0.
	Чтобы отличить нулевой размер от неизвестного, существует lengthComputable, который будет false.

	Особенности onprogress
		- событие происходит при каждом полученном байте, но не чаще чем раз в 50мс;
		- в процессе получения данных, еще до окончания, доступен responseText, но он может быть некорректен, т.к. граница разделения пакетов может пролегать посредине одного символа, если он кодируется не одним байтом.
		- сработавшее xhr.upload.onerror говорит только о факте отправки и не отражает происходящее на сервере.
	Чтобы отправить так же и имя файла, и еще какие-то данные. Нужно воспользоваться объектом FormData.



---------------------------------XMLHttpRequest: возобновляемая закачка-------------------------------------------
Современный XMLHttpRequest дает возможность загружать файл во множестве потоков, с догрузкой, с подсчетом котнтрольной суммы и т.п.
Для управления возобновляемой загрузки есть объект Uploader. Его конструктор выглядит примерно так:
	function Uploader(file, onSuccess, onFail, onProgress) {
		var fileId = `${file.name}-${file.size}-${ +file.lastModifiedDate }`;

		var errorCount = 0;
		var MAX_ERROR_COUNT = 6;

		function upload() {
			...
		}
		function pause() {
			...
		}

		this.upload = unpload;
		this.pause = pause;
	}

	Аргументы:
		file - объект File API
		onSuccess, onProgress, onFail - коллбэки, которые будут вызываться в процессе и по окончании загрузки.

	Данные, с которыми ведется работа в процессе загрузки:
		fileId - уникальный идентификатор файла. По нему можно будет возобновить загрузку.
		errorCount / MAX_ERROR_COUNT - число ошибок подряд и максимальное число ошибок. Если достигнуто максимально число, то загрузка считается проваленной.

	Алгоритм загрузки:
		1) Генерируем fileId из названия, размера и даты последней модификации файла. Можно добавить id посетителя.
		2) Спрашиваем сервер, если ли у него файл с таким id. Если да, то сколько байт загружено.
		3) Отсылаем файл с позиции, которую указал сервер.



---------------------------------COMET с XMLHttpRequest: длинные опросы-------------------------------------------
Частые опросы:
	Можно раз в, к примеру, 10 сек, опрашивать сервер на предмет каких-либо изменений.
	Это будет порождать задержку, величиной в эти 10сек и расходовать лишний трафик на запросы. Так же задействуются ресурсы сервера при каждом запросе.

Длинные опросы:
	1) Отправляется запрос на сервер;
	2) Сервер не закрывает соединение, пока не появится сообщение;
	3) Когда появилось сообщение, сервер отправляет его и закрывает соединение;
	4) Брайзер сразу делает новый запрос

	Если соединение рвется в результате ошибки сети, браузер сразу посылает новый запрос

	Пример:
		function subscribe(url) {
			let xhr = new XMLHttpRequest();

			xhr.onreadystatechange = function() {
				if(this.readyState != 4) return;

				if(this.status == 200) {
					onMessage(this.responseText);
				} else {
					onError(this)
				}

				subscribe(url);
			}

			xhr.open('GET', url);
			xhr.send();
		}

	Длинные опросы обычно применяют при нечастых приеме/отправке сообщений


---------------------------------WebSocket-------------------------------------------
Открытие соединения
	let socket = new WebSocket('ws://javascript.ru/ws') - создать объект, указываем протокол "ws".

У объекта socket есть 4 коллбека:
	1) socket.onopen = () => {
		alert('Connection established');
	}

	2) socket.onclose = (e) => {
		if(e.wasClean) {
			alert('Connection closed properly')
		} else {
			alert('Connection broken');
		}

		alert(`Code: ${e.code}, Reason: ${e.reson}`);
	}

	3) socket.onmessage = (e) => {
		alert('Dara received: ' + e.data);
	}

	4) socket.onerror = (e) => {
		alert('Error: ' + e.message)
	}

Посылка данных
	socket.send(data) - отправить данный
	data может быть любого типа: строка или файл, выбранный в форме (socket.send(form.elements[0].file));

Установка WebSocket соединения
	Протокол WebSocket работает НАД TCP => при соединении, браузер отправляет по HTTP специальные заголовки, для выяснения поддерживает ли сервер WebSocket. Если ответ положительный, то HTTP прекращается и взаимодействие идет уже по WebSocket, который не имеет с HTTP ничего общего. 

Пример запроса, для выяснения поддержки WebSocket
	GET /chat HTTP/1.1
	Host: server.example.com
	Upgrade: websocket
	Connection: Upgrade
	Origin: http://javascript.ru
	Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==
	Sec-WebSocket-Version: 13

	GET, Host - стандартные HTTP-заголовки из URL-запроса. Генерируется браузером.
	Upgrade, Connection - указывает что браузер хочет перейти на WebSocket
	Origin - протокол, домен и порт откуда отправлен запрос
	Sec-WebSocket-Key - случайный ключ, который генерируется браузером. 16 байт в Base64
	Sec-WebSocket-Version - версия протокола.

	Вышеперечисленные заголовки нельзя установить в XHR.setRequestHeader().

Пример ответа сервера, разрешающего WebSocket
	HTTP/1.1 101 Switching Protocols
	Upgrade: websocket
	Connection: Upgrade
	Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=

	Здесь Sec-WebSocket-Accept - это перекодированный специальным образом ключ Sec-WebSocket-Key. Браузер, таким образом, проверяет что ответ предназначался именно ему.

Рвсширения и подпротоколы
	Возможны дополнительные заголовки
		Sec-WebSocket-Extensions: deflate-frame - означает что браузер поддерживает модификацию протокола, обеспечивающую сжатие данных. Устанавливается браузером.
		Sec-WebSocket-Protocol: soap, wamp - говорит о намерении передачи браузером данных по протоколам SOAP или WAMP ("The WebSocket Application Messaging Protocol"). Стандартные протоколы регистрируются в специальном каталоге IANA. Браузер установит этот заголовок, если указать второй необязательный параметр WebSocket:
			new WebSocket('ws://url.com', ['soap', 'wamp'])
			Сервер может выбрать расширения и подпротоколыб которые он поддерживает и ответить с ними.

		Например, запрос:
			GET /chat HTTP/1.1
			Host: server.example.com
			Upgrade: websocket
			Connection: Upgrade
			Origin: http://javascript.ru
			Sec-WebSocket-Key: Iv8io/9s+lYFgZWcXczP8Q==
			Sec-WebSocket-Version: 13
			Sec-WebSocket-Extensions: deflate-frame
			Sec-WebSocket-Protocol: soap, wamp

		Ответ:
			HTTP/1.1 101 Switching Protocols
			Upgrade: websocket
			Connection: Upgrade
			Sec-WebSocket-Accept: hsBlbuDTkk24srzEOTBUlZAlC2g=
			Sec-WebSocket-Extensions: deflate-frame - сервер поддерживает deflate-frame
			Sec-WebSocket-Protocol: soap - сервер поддерживает soap

WSS
	Можно указывать протокол ws:// или wss://. Последний представляет собой WebSocket над HTTPS
	WSS безопаснее.
	WSS имеет большую вероятность соединения
		Дело в том, что HTTPS шифрует трафик от клиента к серверу, а HTTP – нет. Если между клиентом и сервером есть прокси, то, в случае с HTTP, все WebSocket-заголовки и данные передаются через него. Прокси имеет к ним доступ, т.к. они не зашифрованы и может расценить что-то как нарушение HTTP протокола и обрезать заголовки или оборвать передачу.
		В случае с WSS, все данные кодируются и прокси, не имея к ним, в таком виде, доступа, не сможет оборвать соединение.

Формат данных
	В WebSocket предусмотрено несколько видов пакетов ("фреймов")
		Фреймы с данными ("data frames")
		Контроллирующие фреймы ("control frames"), предназначены для проверки связи (PING)
		/Далее, про побитовое утстройство фрейма. Сейчас счел эту информацию слишком глубокой для первых шагов в этой теме. См статью/

	PING/PONG - управляющие фреймы для проверки связи.
		Тот, кто хочет проверить соединение, отправляет фрейм PING с произвольным телом. Получаетль должен в разумное время ответить фреймом PONG с тем же телом.
		Этот функционал встроен в браузер, управлять им из JS нельзя.
		Таким образом, сервер всегда знает, "жив" ли посетитель или у него проблема с сетью.

Чистое закрытие
	Сторона-инициатор закрытия соединения (обе стороны в WebSocket равноправны), отправляет закрывающий фрейм (опкод 0x8) в теле которого указывает причину закрытия.
	В браузерной реализации эта причина будет содержаться в свойстве reason события onclose.
	Наличие такого фрейма позволит отличить чистое закрытие от обрыва связи.

	В браузерной реализации event.wasClean = true

	Коды закрытия
		1000 - нормальное закрытие
		1001 - удаленная сторона "изчезла". Например, "убит" процесс сервера или клиент перешел на другую страницу.
		1002 - удаленная сторона завершила соединение в свящи с ошибкой протокола.
		1003 - Удаленная сторона закрыла соединение в связи с получением данных, которые она не может принять. Например, ожидаются текстовые данные, а получены бинарные.

Атака "отравленный кеш" (cache poisoning)
	Существовала в ранних реализациях WebSocket. Для защиты от нее, придумали маску

Маска для защиты от атаки
	Ключ маски - случайное 32-битное число, которое варьируется от пакета к пакету. Тело сообщения проходит черехз XOR с маской. И восстанавливается его повторным XOR с ней. Можно доказать что (x ^ a) ^ a == x;

	1. Маска генерируется браузером. Хакер не будет иметь доступа к ней. После накладывания маски, тело сообщения превратится в бинарную мешанину.
	2. Получившийся пакет данных точно не сможет быть воспринят промежуточным прокси как HTTP-запрос.

Если связываются 2 клиента, доверяющие друг другу, то можно поставить бит маски в 0 и ключ маски не указывается.

---------------------------------Протокол JSONP-------------------------------------------
При добавлении тега <script> с внешним src, браузер начинает его сразу скачивать и выполнять.
	function addScript(src) {
		var elem = document.createElement('script');
		elem.src = src;
		document.head.appendChild(elem);
	}

	addScript('user?id=123');

	//ответ сервера
	var user = {name: 'Vasya', age: 25};

	По script.onload браузер отловит окончание загрузки и прочитает user.
В случае, когда делается несколько вышеперечисленных запросов, используется протокол JSONP
	1. Вместе с запросом, клиент, в, заранее оговоренном параметре, передает название функции
		addScript('user?id=123&callback=onUserData');
	2. Сервер кодирует данные в JSON и оборачивает их в вызов функции, название которой он получает из параметра callback:
		onUserData({
			name: 'Vasya',
			age: 25,
		});

	Это и называется JSONP

Реестр CallbackRegistry
Т.к. <script src> глобальный, то и callback-функция будет глобальной.
Чтобы не загрязнять глобальное пространство имен, создают глобальный объект CallbackRegistry. Для каждого запроса, в нем герерируется временная функция
	<script src='user?id=123&callback=CallbackRegistry.func12345'></script>
Сервер обернет ответ в вызов CallbackRegistry.func12345. Она вызовет нужный обработчик и очистит память, удалив себя.
Обработка ошибок
	1. При загрузке, скрипт выполняет CallbackRegistry.... . Она будет ставить флаг "все ок".
	2. В script.onload/onerror проверяем этот флаг. Если установлен, то функция вызвалась. Если нет, значит ошибка.

Полный пример
	var CallbackRegistry = {}; // реестр

	// при успехе вызовет onSuccess, при ошибке onError
	function scriptRequest(url, onSuccess, onError) {

	  var scriptOk = false; // флаг, что вызов прошел успешно

	  // сгенерировать имя JSONP-функции для запроса
	  var callbackName = 'cb' + String(Math.random()).slice(-6);

	  // укажем это имя в URL запроса
	  url += ~url.indexOf('?') ? '&' : '?';
	  url += 'callback=CallbackRegistry.' + callbackName;

	  // ..и создадим саму функцию в реестре
	  CallbackRegistry[callbackName] = function(data) {
	    scriptOk = true; // обработчик вызвался, указать что всё ок
	    delete CallbackRegistry[callbackName]; // можно очистить реестр
	    onSuccess(data); // и вызвать onSuccess
	  };

	  // эта функция сработает при любом результате запроса
	  // важно: при успешном результате - всегда после JSONP-обработчика
	  function checkCallback() {
	    if (scriptOk) return; // сработал обработчик?
	    delete CallbackRegistry[callbackName];
	    onError(url); // нет - вызвать onError
	  }

	  var script = document.createElement('script');

	  // в старых IE поддерживается только событие, а не onload/onerror
	  // в теории 'readyState=loaded' означает "скрипт загрузился",
	  // а 'readyState=complete' -- "скрипт выполнился", но иногда
	  // почему-то случается только одно из них, поэтому проверяем оба
	  script.onreadystatechange = function() {
	    if (this.readyState == 'complete' || this.readyState == 'loaded') {
	      this.onreadystatechange = null;
	      setTimeout(checkCallback, 0); // Вызвать checkCallback - после скрипта
	    }
	  }

	  // события script.onload/onerror срабатывают всегда после выполнения скрипта
	  script.onload = script.onerror = checkCallback;
	  script.src = url;

	  document.body.appendChild(script);
	}

---------------------------------Server Side Events - события с сервера-------------------------------------------
Поддерживаются всеми браузерами, кроме IE.
Стандарт Server-Sent Events позволяет бразуеру создавать объект EventSource
	Он сам соединяется с сервером
	Делает реконнект, в случае обрыва соединения
	Генерирует события при поступлении данных
	По дизайну немного меньше и проще в реализации чем WebSocket, поддерживает ряд дополнительных возможностей
	Работает по HTTP
	Это удачный выбор в тех случаях, когда нужна односторонняя передача данных.

Получение сообщений
	При создании new EventSource(src) - браузер автоматически подключается к адресу src и начинает получать с него события:
		let eventSource = new EventSource('/url');
		eventSource.onmessage = e => {
			console.log('Message received: ' + e.data);
		}

	Для открытия соединения, сервер должен в ответе выставить заголовок Content-Type: text/event-stream, оставить соединение висеть и присылать сообщения.
	Каждое сообщение имеет следующие формат:
		data: Сообщение 1

		data: Сообщение 2

		data: Сообщение 3
		data: вторая строка сообщения 3

		1. Каждое сообщение пишется в поле data:
		2. Если после двоеточия есть пробел, то он игнорируется
		3. Сообщения разделяются двумя строками \n\n
		4. Строки одного сообщения разделяются \n

		Если передавать сообщение в JSON'е, то строка data будет одна, а перевод строки будет кодироваться как \n:
			data: {userName: 'Vasya', message: 'two lines\n message'}

Восстановление соединения
	В случае обрыва соединения, браузер попытается его восстановить. Но даже если сервер умышленно закроет соединение, то браузер все равно повторит свой запрос.
	Закрыть соединение сервер может лишь двумя способами:
		1. Ответить со статусом не 200
		2. В значение Content-Type поставить что-то отличное от text/event-stream
	Между попытками возобновить соединение может быть пауза 1-3 сек (зависит от браузера)
	Сервер может установить этот интервал через указание retry:
		retry: 15000 //задержка в 15сек
		data: blabla
	Браузер может закрыть соединение вызовом close()
		let eventSource = new EventSource(...);
		eventSource.close()
	Для того, чтобы продолжить получение событий с места разрыва, нужно указать айдишник последнего полученного события:
		data: message 1
		id: 1

		data: message 2
		id: 2

		data: message 3
		data: two lines message 3
		id: 3
		При получении id, браузер:
			1. Устанавливает свойство eventSource.lastEventId в его значение
			2. При пересоединении, пошлет заголовок Last-Event-ID с этим значением, так что сервер может переслать последние пропущенные сообшения
		Event ID шлется ПОСЛЕ сообщения, когда браузер его точно получил

Статус соединения readyState
	Свойство объекта EventSource содержит несколько значений
		CONNECTING = 0 //в процессе (пере-)соединения
		OPEN = 1 //соединение установлено
		CLOSED = 2 //соединение закрыто

		При создании объекта и при закрытии, оно автоматически равно CONNECTING

События
	onmessage - пришло сообщение. Соединение доступно как e.data
	onopen - при успешном устанолвении соединения
	onerror - при ошибке соединения

Свое имя события
	По умолчанию, имя события получения данных - message. На него срабатывает обработчик onmessage.
	Для задания собственного имени события, сервер должен указать перед событием, его имя, после event:
		event: join
		data: Vasya

		data: Hello

		event: leave
		data: Vasya

	Для назначения обработчиков таких событий, рекомендуется использовать addEventListener

Кросс-доменность
	EventSource имеет второй аргумент для поддержки кросс-доменных запросов:
		let source = new EventSource('http://url.com/stream', {
			withCredentials: true
		});
	Второй аргумент сделан объектом с расчетом на будущее. Пока тут только одно свойство
	Сервер получит заголовок Origin с доменом запроса и должен ответить заголовком Access-Control-Allow-Origin (и Access-Control-Allow-Credentials, если стоит withCredentials)