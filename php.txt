$st = `any/comm.and` - выполнить команду в обратных апострофах и поместить ее вывод в переменную $st
a ** b - возвести a в степень b
a <=> b - возвращает -1, если а < b, 0 если равны и 1 если a > b
@<statement> - оператор, подавляющий вывод предупреждений о выражении на экран
a ?? b - вернет значение операнда не равного null

define("var", value) - определить константу;
defined(string $name) - проверить, была ли определена константа. Возвращает true/false

constant(string $name) - возвращает значение переданной константы

a.b - слияние строк a и b
a[2] - 3й символ строки,

foreach(array as key => value) - перебор массива по парам key-value
foreach(array as value) - будет доступ только к значениям, но не к ключам
foreach работает с копией массива

foreach($array as &$val) - работа с элементами массива, посредством ссылки. Ссылка &$val не удаляется после завершения foreach

header("Location: http://google.com") - редирект на, к примеру, гугл
exit - оператор, останавливает дальнейшее выполнение скрипта
exit($msg) - функция, завершить скрипт и вывести сообщение
die($msg) - аналог exit()
print - оператор, похожий на echo, но его можно использовать как часть выражения (Н/П тернарный оператор)
Нельзя присвоить новой статической переменной результат выражения
printf($str, arg) - наместе символа форматирования, в $str, отображается определенным образом arg. Символы и их значения:
	%b - отобразить arg в виде двоичного целого;
	%с - отображение ASCII-символа, соответственно коду arg;
	%d - отображение в виде десятиного числа;
	%e - научная форма записи;
	%f - в виде числа с плавающей точкой;
	%o - в виде восьмеричного целого;
	%s - в виде строки;
	%u - в виде беззеакового десятичного числа;
	%x - в виде шестнадцатеричного числа;
	%X - в виде шестнадцатеричного с буквами в верхнем регистре
Количество форматирующих символов должно соответсвовать каоличеству аргументов
sprintf() - аналогична printf(), но вместо передачи информации браузеру, возвращает ее
$a &= $b - создать жесткую ссылку
Жесткая ссылка - это синоним (вроде указателя) другой переменной

Символическая ссылка - переменная, хранящая имя другой переменной
$right = 123;
$a = 'right';
echo $$a - выведет '123'




---------------------подключение файлов----------------------------
require "file.ext" - вставить в код содержимое файла	
include "file.ext" - отличие от require в том что если невозможно подключить файл, то работа скрипта не завершается, а продолжается

эти инструкции рекомендуется делать для подключения html файлов. Для скриптов лучше использовать следующее:
require_once - аналогично обычному require, однако если файл был подключер ранее, то require_once во второй раз ничего не делает.
include_once - то же самое, только если невозможно подключить файл - работа скрипта продолжается





-------------------------функции------------------------------------
переменная, объявлена в функции - локальна для нее
имя функции не зависит от регистра
Чтобы функции можно было передать переменную по ссылке, нужно определить в ней "ссылочный" параметр, предварив его знаком "&"

func_num_args() - возвращает число переданных родительской функции аргументов
func_get_arg($num) - возвращает значение аргумента с номером $num, в списке переданных аргументов
func_get_args() - возвращает все переданные аргументы (и по-умолчанию тоже) в виде списка (индексный массив)

function f(...$parameters) - такой функции можно также передать сколь угодно параметров. Массив $parameters будет всех их содержать

Можно передать функции массив, предварив его оператором "...", который развернет этот массив и присвоит его элементы соответствующим параметрам
Можно строго задавать тип парпметрам, как в языке С, так же можно задать возвращаемый функцией тип, предварив его двоеточием
	function f(int $arg) : float {...body...}

declare(strict_types = 1) - включить режим жесткой типизации
До первого использования внешней переменной в теле функции, нужно ее объявить как глобальную
	global $monthes;

$GLOBALS['var_name'] - глобальный массив всех внешних переменных в программе. Ключ - имя переменной. Его нельзя присвоить переменной целиком и передать функции по значению.
static $var - статическая переменная. Переменная сохраняет свое значение после каждого вызова функции
exec($command, $output, $status) - выполнить внешнюю команду $command, результат которой будет записан в массив $output, а в $status - статус выполнения команды (bool)
settype($var, $type) - установить переменной тип. Если преобразовать тип не удалось, вернет false.
(int)$var - альтернативный синтаксис преобразования типа

$myecho = function(...) {...}; $myecho(...) - объявление и вызов анонимной функции


----------------------------Генераторы------------------------------
Это обычные функции, но для возврата значения используют слово yield вместо return
Особенность состоит в том, что возвращая значение, генератор "запоминает" свое состояние (на какой строке когда произошел выход из тела) и при следующем вызове, продолжает свое выполнение.
Во время возврата (yield) можно передать управление другой функции/генератору/массиву с помощью слова from
	yield from [1, 2];
	yielf from func();
	yield from gen();
Генератор возвращает объект класса Generator, что-то вроде массива, но только в нем каждое следующее значение вычисляется телом генератора, при обращении к первому.
Генератор может возвращать, так же, пару ключ/значение или ссылку
При помощи метода, возвращаемого генератором объекта send(), можно "впихнуть" на место yield, что-то:
	$string = yield
	...
	$ob = gen();
	$ob->send('Hello, world!') // $string станет равна передаваемой строке


-----------------------------Заыкания--------------------------------
Это когда функция запоминает состояние окружения в момент своего создания. Даже если состояние потом изменится, замыкание содержит в себе снимок первоначального состояния. Применяется только к анонимным функциям.
$message = "abcabc";
$f = function($arg) use ($message){...} - используя ключевое слово use, мы укажем что именно должно войти в замыкание


function &$f() {...} - объявление функции, которая может возвращать ссылку


------------------------Регулярные выражения-------------------------
preg_match($pattern, $subject, [, array &$matches]) - сопоставляет (проверка, удовлетворяет ли строка этому выражению) выражение $pattern, строке $subject и, в случае удачи, возвращает 1 или 0. Если совпадение было найдено, то в список $matches (если он задан), записываются отдельные участки совпадения. Возвращает в $matches только первое вхождение подстроки.

preg_match_all(...) - работает аналогично preg_match() но записывает в $matches все вхождения

Регулярное выражение начинается и заканчивается слешами (/). Если данный символ содержит сама строка (н.п. путь к файлу), то его нужно экраниновать обратным слешем.

preg_replace($pattern, $replacement, $subject) - заменяет все, согласно $pattern, в $subject на $replacement

-------------Язык PCRE
Управляющие команды разбиваются на 3 класса:
1. Простые и управляющие символы, называемые Литералами.
	Управляющие символы: ., *, +, ?, |, (, ), [, ], {, }, $, ^. 

2. Управляющие конструкции (квантификаторы повторений, оператор альтернативы и т.д.)
3. Мнимые символы (в строке не присутствуют, но помечают какую-то ее часть. Напримем конец)

+ после команды - повтор ее один или более раз
Если искомая подстрока содержит управляющие символы, то их всех нужно экранировать

Классы символов:
. - один любой символ
/S - любой непробельный символ
/s - любой пробельный символ (' ', \t, \n, \r)
\w - любая буква или цифра
\W - не буква и не цифра
\d - цифра от 0 до 9
\D - все, кроме цифры
\b - начало или конец слова
\B - любая позиция, кроме начала и конца слова

Альтернативы:
/a[xXyY]b/ - подстрока содержит любой один символ, из перечисленных в квадратных скобках
/[a-zA-Z]/ - если альтернатив много, можно поставить между крайними точками алфавитного диапазона дефис

В PHP один PCRE-слеш равен двум обычным слешам

Выбор символов по группам:
[:alpha:] - буква
[:digit:] - цифра
[:alnum:] - буква или цифра
[:space:] - пробельный символ
[:blank:] - пробельный или символы с кодом 0 и 255
[:cnrtl:] - управляющий символ
[:graph:] - символ псевдографики
[:lower:] - символ нижнего регистра
[:upper:] - символ верхнего регистра
[:print:] - печатаемый символ
[:punct:] - знак пунктуации
[:xdigit:] - цифра или буква от А до F
Все эти выражения обрамляются дополнительной парой квадратных скобок:
/abc[[:alpha:]][[:punct:]0]/ - abc, затем буква, знак пунктуации или 0

Отрицательные классы:
/abc[^<>]/ - после abc допустим любой символ, кроме < и >

Квантификаторы повторений:
Специальные символы, которые используются для указания действий предшествующего ему символа
 * - Ноль или более повторений
 	/а-*/ - выбрать букву "а", затем ноль или более минусов
 + - одно или более совпадений
 ? - ноль или одно совпадение
 {} - заданное число повторений. Значения могут принадлежать диапазону от 0 до 65 535 включительно
 	Х{n, m} - "Х" может повторяться от n до m раз
 	Х{n} - символ может повториться ровно n раз
 	Х{n,} - n или более раз

Мнимые символы (якоря):
Некая позиция в строке
	^ - обзначает начало строки (если он не в кв. скобках). Не первый символ строки, а именно позицию перед ним
	$ - конец строки (позиция после последнего символа в строке)
	\b - начало и конец слова
	\B - любая позиция кроме начала и конца слова

Оператор альтернативы:
| - он самый
	/^\d|^A/ - строка, начинающаяся с любой цифры или буквы А
	/^(\d|A)/ - приминением группирующих скобок

Карманы:
/^\s* (  (\d+) \s*[[:punct:]]\s* (\d+) \s*[[:punct:]]\s* (\d+)) \s*$/xs - блоки, обрамленные скобками, выделяются как единое целое и записываются в т.н. "карманы", которые нумеруются по порядковому номеру открывающей скобки, независимо от вложенности. Нумерация начинается с 1.
Чтобы убрать жадность управляющего символа, нужно после него поставить знак вопроса
	(.*?)
Чтобы игнорировать карман, нужн сразу после открывающей скобки записать ?:
	(?:\w+)
Модификатор x - игнорировать все пробельные символы в выражении
Карманы записываются в массив $matches. На нулевой позиции записывается полное совпадение, а начиная с 1-ой, записываются карманы.
Именование кармана - после открывающейся скобки ставим знак вопроса и в угловых скобках или апострофах задаем имя кармана, которое станет его индексом в массиве $matches.


Модификаторы:
/i - игнорирование регистра
/x - игнорирование пробелов и комментариев в выражении
/m - многострочный режим
/s - однострочный режим
/e - работает только в функции замены и трактует параметр для замены, как код php и замена будет производиться результатом работы этого кода. Ввиду несовершенства данного модификатора, его лучше избегать, используя вместо него функцию preg_replace_callback()
\u - модифицирует кодировку обрабатываемых строк в UTF-8



----------------------Передача функции по ссылке---------------------
function A($i)  {...}
$F = 'A';
$F(300) - вызовется функция A();



-----------------функции для работы с типами переменных--------------
isset($var) - проверяет, установлена ли переменная в значение, отличное от null
unset($var) - полностью удалить переменную
gettype(переменная) - возвр тип переменной

is_numeric($var) - true если $var число (или возможно привести к числу)
is_integer($var) - если изначально число
is_double($var) - имеет точку
is_string($var) - ...
is_bool($var) - если логической значение
is_scalar($var) - если переменная (не объект и не массив и т. д.)
is_null($var) - если переменная не имеет значения
is_array($arr) - если массив


----------------------математические функции---------------------------
round($var, digits) - округляет $var к целому. Если указать digits - до количества цифр после запятой
ceil($var) - округлить к большему
floor($var) - к меньшему

mt_rand(a, b) - случайное число в диапазоне от a до b
min(...) - возвратит минимальное число среди переданных аргументов
max(...) - максимальное число


------------------------строковые функции-------------------------------
strlen($str) - длина строки
strpos($str, $sym) - возвращает позицию символа $sym в строке $str. Если ничего не найдено, вернет false
substr($str, a, b) - возвратит подстроку, из b символов, начиная с символа под индексом a, в строе $str. Отрицательное значение - с конца строки
str_replace($str1, $str2, $str3) - в строке $str3 заменит $str1 на $str2. Можно работать с несколькими подстроками, передавая массивы
htmlspecialchars() - Кодирует разные спецсимволы (</> и т .п.) - так, чтобы они просто отображались на странице и не выполнялись.
strtolower($str) - нижний регистр
strtoupper($str) - верхний
md5($str) - кодирует переданную строку в md5 сумму
trim($str) - удаляет пробелы вначале и в конце строки, а внутри строки оставляет только по одному пробелу.
если перед именем свойства поставить $, то интерпретатор будет пытаться обратиться к свойствку, по-имени, которое хранит переменная. Н/П:
	$property = 'brown';
	$object->$property; //Будет пытаться обратиться как $object->brown;
$obj2 = clone $obj1 - создать клон объекта, вместо присваивания по ссылке
статическая функция (static) - может быть вызвана только в классе и работает только с классом, но не с объектами. Н/П User::pwt_password();
Свойствам класса, по умолчанию, не могут быть присвоены результаты вызова функций или выражений.
Свойство, объявленное статическим может быть доступно только из метода класса или объекта
stripslashes($str) - удаляет слеши
strip_tags($str) - удаляет весь html-код


---------------------------Наследование---------------------------------
Наследовать - extends
parent:: self:: - получить доступ к одноименным методам родителя или своему
final - запрещает дочерним классам переписывать данный метод


----------------------функции для работы с массивами---------------------
count($array) - длина массива
count($arr, 1) - второй параметр включает режим рекурсивного подсчета для многомерных массивов

$first + $second - слияние ассоциативных массивов
Если слить так обычные массивы, то в результирующем, элементы из первого массива, с аналогичными индексами(ключами), переопределят элементы из второго прибавляемого массива. Это же правило действует и при совпадении ключей в ассоциативном массиве.

array_merge($arr1, $arr2 ) - слияние массивов (любых)

print_r($arr) - вывести массив, как есть
sort($arr) - сортировать массив по возрастанию
rsort($arr) - по убыванию

asort($arr)/arsort($arr) - для ассоциативных массивов
ksort($arr)/krsort($var) - сортировка ассоциативных массивов по ключам

shuffle($arr) - перемешать все элементы массива
in_array($value, $arr) - true, если $value есть в $arr
array_slice($arr, $idx, $qty) - вернет подмассив из элементов $qty, начиная с индекса $idx

explode(dltr, $str) - вернет массив иэ элементов строки str, разделенных dltr
extract($arr) - из ассоциативного массива создает пары переменная:значение. Существующие одноименные переменные будут переписаны
compact('var1_name', 'var2_name', ...) - из переданных строковых имен переменных создает ассоциативный массив

reset($arr) - вернуть первый элемент массива
end($arr) - вернет последний элемент массива

list($var1, $var2, $var3, ...) - возвращиет массив из переданных параметров
list($var1, $var2, $var3, ...) = $array - присваивает переданным переменным, соответствующие значения из $array
define('arrname', [values...]) - определить массив-константу

array('key' => 'value', 'key' => 'value'); - создать ассоциативный массив
Ключом в ассоциативном массиве может быть АБСОЛЮТНО любая строка

end($array) - установить внутренний указатель на (и венрнуть) значение последнего элемента
reset($array) - ...первого элемента массива
prev($array) - установить и вернуть предыдущий эелемнет. Вернет false для пустого массива или если мы вышли за его предел
next($array) - ...следующий элемент...
current($array) - вернуть текущий элемент массива. Вернет false для пустого массива или несуществующего элемента
key($array) - возвращает ключ текущего элемента массива. В дургих случаях возвращает null
each($arr) - позвращает текущую пару ключ/значение в виде массива из 2х элементов и пермещает внутренний указатель $arr вперед




-------------------------функции для работы с датой------------------------
time() - сек с 1970
microtime() - сек с дробной частью. Если передать true, то возвр значение будет float, вместо string
date($format_str, $sec) - вывести дату и время, в заданном формате (см. доку). Если передать кол-фо сек с 1970, то вернет дату, соотв им.
mktime($h, $m, $s, $month, $day, $year) - создать указанную дату (в сек, прошедших с 1970)
getdate($msec) - вернет дату (ее элементы в массиве), согл кол-ву $msec, с 1970
checkdate($month, $day, $year) - true, если дата существует в календаре






----------------------------работа с файлами---------------------------------
fopen($name_str, $prmisn-str) - Создать файл (если есть - открыть). Возвр объект типа resource. Флаги прав доступа - см доку
fwrite($file_res, $info) - записать в переданный файл $file информацию $info
fclose($file) - закрыть файл
fread($file, $qty) - счиать из $file $qty символов
feof($file) - вернет true когда курсор находится в конце файла
fseek($file, $pos) - установить курсор в файле на индексную позицию $pos
file_put_contents($file_str, $info ) - открыть файл, вставить $info, закрыть файл
file_get_contents($file_str) - вернет содержимое файла, можно получить страницу по url
file_exists($file) - true, если файл существует
filesize($file) - размер (байт)
rename($old_name, $new_name) - переименовать файл
copy('file1.a', 'file2.a') - скопировать file1.a в file2.a
unlink($file) - удалить файл

fileperms($path ) - вывести права доступа 
chmod($path, $prmisns) - дать права доступа к файлу, расположенному по пути.
flock($file, OPERATION) - заблокировать доступ к файлу скриптов кроме данного
move_uploaded_file('filename', 'destination') - перемещает файл в заданное место. В случае успеха возвращает true иначе false






---------------------работа с формами-------------------------------
echo (int)... - преобразовать в int
$_POST/$_GET - содержит данные, полученные по post/get методу
	get отправит скрипту информацию из формы, как часть url строки
	post - позволяет передавать скрипту файлы. Размер данных больше
$_REQUEST - содержит смесь данных post, get, cookies

$_SERVER['QUERY_STRING'] - строка запроса к скрипту (из строки в браузере, после знака вопроса)
$_SERVER['PHP_SELF'] - имя скрипта
$_SERVER['SCRIPT_NAME'] - путь к текущему скрипту
$_SERVER['HTTP_HOST'] - имя хоста (н.п. localhost)
$_SERVER['SERVER_ADDR'] - IP of the host server
$_SERVER['REMOTE_ADDR'] - returns IP, where user is viewing the current page
$_SERVER['REMOTE_PORT'] - ...port
$_SERVER['SCRIPT_FILENAME'] - absolute path to the currently executing script
$_SERVER['REMOTE_PORT'] - port, using by server machine
$_SERVER['SCRIPT_URI'] - URI of the current script
* Все элементы можно посмотреть в выводе phpinfo(), PHP Variables

action="" - форма будет обрабатываться на этой же странице

фигурные скобки в строке служат для создания сложных выражений. Синтаксис распознается только когда $ следует сразу за {

empty($value) - существует ли переменная

$GLOBALS["var_name"] - доступ ко глобальной переменной
global $variable - объявить переменную как глобальную (внутри функции)

<input type="тип" name="имя" size="размер (символы" maxlength="максимальная вводимая длина (символы)" value="значение по умолчанию/отправляемое на сервер" src="изображение на кнопке">
Атрибут autocomplete - выводит в качестве подсказок, ранее введенные пользователем, в поле, данные
<textarea name="имя" cols="ширина (символы)" rows="Высота (символы)" wrap="тип переноса">Текст по умолчанию</textarea>
Значения wrap:
	off - текст будет печататься в одну строку, при этом будет появляться полоса прокрутки
	hard - слова будут переноситься таким образом, чтобы поместиться в поле. Для этого значения обязателен атрибут cols
	soft - значение по умолчанию. Слова переносятся автоматически, но на сервер передадутся одной строкой. Переносы, добавленные клавишей Enter, сохраняются

Если речь идет от отправки выборки элементов (checkbox/radio), нужно всем присвоить одинаковое имя и после него поставит квадратные скобки, иначе отправлен будет последный выбранный элемент

<select name="имя" size="размер (строки)" multiple> - раскрывающийся список. multiple дает возможность выбрать несколько элементов
Чтобы multiple-значения отправились на сервер в виде числового массива, нужно дать списку имя name[]
<option value="отправится на сервер" selected>Имя в списке</option> - элемент списка. selected - будет выбран по умолчанию

<label></label> - если внутрь включить текст и поле ввода, то можно будет активировать последнее, нажатием на тескт
form**** - атрибуты подмены. Переопределяют соответствующее значение атрибута формы



-------------------------Работа с БД---------------------------------
$conn = new mysqli($host, $user, $pwd, $dbname) - объект текущего подключения к БД
$result = $conn->query($query) - передача запроса. Возвращает результат запроса в виде объекта
$result->fetch_accoc() - извлекает данные в виде ассоциативного массива (только строку, на которую установлен указатель)
$result->fetch_array(const) - возвращает массив значений, в зависимости от переданной константы
	MYSQLI_NUM - обычный массив, значениями которого являются значения столбцов таблицы
	MYSQLI_ASSOC - ассоциативный массив, как и в случае с fetch_assoc()
	MYSQLI_BOTH - возвращает массив, состоящий из обычных пар "индекс-значение" и из ассоциативных пар "ключ-значение"
$result->fetch_all(const) - извлечь все строки из результирующего набора
$result->data_seek(int $num) - перемещает указатель на указанную строку
$result->num_rows - количество строк в таблице
$conn->connect_error - свойство, хранящее последнюю ошибку подключения
$conn->error - возвращает последнюю ошибку, возникшую при работе mysql
$conn->insert_id - id элемента, при последнем запросе INSERT или UPDATE, к таблице, имеющей колонку со свойством AUTO_INCREMENT. Во всех остальных случаях равно нулю.
$conn->real_escape_string($_POST['user']) - экранирует все специальные символы и возвращает  "очищенную" строку

Указатели мест заполнения:
$stmt = $conn->prepare('INSERT INTO classics VALUES(?, ?, ?, ?, ?)') - вернет объект, который, используя метод bind_param(), привяжет переменные к соответсвующим указателям заполнения (знакам вопроса)
$stmt->bind_param('<type1><type2>...', var1, var2, ...) - привяжет переменные к соответствующим указателям заполнения. Первый аргумент являет собой буву, указывающую на тип соответствующего параметра:
	i - int
	d - double
	s - string
	b - blob
Когда переменные привязаны, можно присвоить им значения, для выполнения запроса.
Когда все, для выполнения запроса, готово - $stmt->execute() - метод, для выполнения предопределенного запроса




----------------------------------Cookie, сессии и аутентификация---------------------------------
cookie - элемент, могущий хранить любую буквенно-цифровую информацию. Создается сервером с помощью браузера на диске клиента и извлекается сервером при необходимости. Объем до 4Кб. Может быть извлечен только создавшим его доменом

Хранятся по пути, указанном в переменной окружения HTTP_COOKIE, в таком же вормате, как QUERY_STRING, только разделенные точкой с запятой вместо амперсанда

1. Браузер запрашивает страницу, путем передачи заголовков
2. Сервер, возвращает свои заголовки, устанавливает куки и затем посылает страницу
3. Браузер запрашивает новую страницу и возвращает куки
4. Сервер получает куки и присылает страницу

setcookie(name, value, expire, path, domain,secure, httponly) - установка куки.
	name - имя куки, будет использоваться сервером для доступа к нему, при последующих запросах браузера
	value - значение куки. Буквенно-цифровой текст до 4Кб
	expire - Необязательный. Время истечения срока действия (time() + seconds). По умолчанию, действие до закрытия браузера
	path - Необязательный. Путь к куки на сервере. По умолчанию, каталог, где был создан куки.
	domain - Необязательный. Домен, которому принадлежит куки.
	secure - Необязательный. Должен ли куки использовать безопасное подключение (https). По умолчанию false.
	httponly - Необязательный. Должен ли куки использовать протокол http. По умолчанию false.

$_COOKIE['name'] - достать нужный куки

Прочитать куки можно, когда он уже был установлен ранее, при предыдущей загрузке страницы.
Чтобы удалить куки - нужно вызвать setcookie с теми же параметрами, что и при его создании, кроме expire, которое устанавливается на прошедшее время. Например time() - 200000000.

md5(str) - возвращает шифр переданной строки
hash(algorytm_name, data) - возвращает зашифрованное data

сессия хранится на сервере
По умолчанию, сессия длится 15мин или до закрытия браузера

session_start() - начать сессию. Нужно вызывать эту функцию в любом файле, перед использованием массива $_SESSION[]
session_destroy() - удалить сессию
session_unset() - сбросить все переменные массива $_SESSION

$_SESSION - ассоц. массив. Используется для настройки и создания сессии

session_destroy() - закрыть текущую сессию
ini_set('parameter', new_value) - установить новое значение параметра конфигурации сессии
ini_get('parameter') - получить значение параметра конфигурации сессии
session_regenerate_id() = сохраняет переменные сессии, но заменяет ее id на новый




*****************************************PHP в подленнике***********************************************
TCP - определяется IP адресом и портом
Порт - номер, идентифицирующий процесс на узле. По умолчанию, порт для http - 80
Узел - сущность, имеющая уникаьный IP адрес
Виртуальный хост - альтернативное доменное имя для основого хоста (IP адреса)
Протокол - набор текстовых команд, для обмена данными с web-сервером
CGI - набор соглашений, которые должны соблюдаться web-серверами, при выполнении ими различных приложений
Web-сервер - это программа-сервер
Сервер - сама машина

Строка, после вопросительного знака, в конце урла (get-запрос) передается CGI сценарию
http://example.com/script.cgi?time+=3&name=Vasya - передать несколько параметров cgi-сценарию
Протокол http задает правила интерпретации заголовков
Некоторые заголовки передаются сценарию с помощью переменных окружения
Переменная окружения - это именнованное значение параметра, которое может быть передано программе родительским процессом


--------------------------------Заголовки GET-запросов----------------------------------
Формат:
	GET <сценарий>?<параметры> HTTP/1.0
Переменные окружения:
	REQUEST_URI
	QUERY_STRING - хранится значение  <параметры>
	REQUEST_METHOD - ... ключевое слово GET
Этот заголовок является обязательным, если не применяется метод POST
Вместо HTTP/1.0 может быть указан другой протокол
<сценарий>?<параметры> - задается в том же самом параметре, в каком есть и URL
URL - полный путь к некоторой странице вместе с параметрами
URI - часть URL, которая находится после доменного имени (или IP адреса) и номера порта


GET somestring HTTP/1.0\n
...other information...
\n\n

\n\n - маркер окончания запроса
\n - просто новая строка
...other information... - headers, раздеренные символом новой строки



--------------------------------Заголовки POST-запросов----------------------------------
Формат:
	POST <сценарий>?<параметры> HTTP/1.0
Переменные окружения:
	Все аналогично GET
	REQUEST_METHOD = POST
В отличии от GET, данные можно передовать не только со списком параметров, но и в самом конце всех заголовков



---------------------------Content-Type----------------------------------------
Формат:
	Content-Type: application/x-www-form-urlencoded
Переменная окружения:
	CONTENT_TYPE
Идентифицирует тип передаваемых данных.
application/x-www-form-urlencoded - значение, определяющее формат, в котором все управляющие символы кодируются специальным образом
Сервер никак не интерпретирует этот заголовок, а просто передает его сценарию



------------------------------Host--------------------------------------------
Формат:
	Host: <имя_хоста>
Переменная окружения:
	HTTP_HOST - доменное имя web-сервера, на котором запущен сценарий. Точнее то что передано в заголовке Location
Указывает серверу, к какому именно хосту на узле произошло обращение.
<имя_хоста> - то самое имя, которое ввел пользователь в адресную строку
HTTP 1.1 обязывает указание данного заголовка
HTTP_HOST, в отличие от SERVER_NAME, содержит номер порта, когда оный отличен от 80




----------------------------User-Agent------------------------------------------
Формат:
	Mozilla/5.0 (Windows NT 6.3; WOW64; RV:41.0) Gecko/20100101 Firefox/41.0
Переменная окружения:
	HTTP_USER_AGENT - идентифицирует браузер пользователя
Содержит сведения о клиенте (не всегда точные и правдивые)



---------------------------------------Referer---------------------------------------------
Формат:
	Referer: URL_адрес
Переменная окружения:
	HTTP_REFERER - имя документа, в котором находится форма, запустившая CGI-сценарий
Содержит URL страницы, с которой осуществляется переход на текущую. Может быть обрезан брандмауэром или подделан умышленно




-------------------------------------Content-length----------------------------------------
Формат:
	Content-length: длина
Переменная окружения: CONTENT_LENGTH - количество байтов данных присланных пользователем
Содержит десятичное представление длинны передаваемых POST данных, в байтах. В GET этот заголовок отсутствует
Благодаря переменной CONTENT_LENGTH, получивший данные сценарий, узнает когда прекращать чтение поступившей информации





-------------------------------------------Cookie-------------------------------------------
Формат:
	Accept: text/html, text/plain, image/gif, image/jpeg
Переменная окружения:
	HTTP_ACCEPT - перечисление MIME-типов, которые могут быть восприняты браузером
В данном заголовке, браузер перечисляет, какие типы документов он понимает. Значение '*/*' означает любой тип



telnet-клиент - программа, которая может подключаться к заданному IP-адресу и порту, посылать набранные на клавиатуре и отображать на экране, поступающие "снаружи" данные



SERVER_PORT - порт сервера. Также, может генерировать парамерт для Location
REMOTE_ADDR - IP-адрес узла пользователя, на котором был запущен браузер
REMOTE_PORT - порт, закрепленный за браузером, для получения ответов от сервера
SСRIPT_NAME - виртуальне ия выполняющегося сценария (то что в урле, последнее, перед знаком "?")
REQUEST_METHOD - метод GET или POST
QUERY_STRING - параметры в урле, после вопросительного знака




-------------------------------------Заголовки ответов----------------------------------------
Первый заголовок должен быть без двоеточия. Например:
	HTTP/1.1 OK
	HTTP/1.1 404 Not Found
И далее, уже идут обычные заголовки ответа
Задает, т.н. "код ответа сервера"

Оостальные заголовки аналогичны заголовкам запроса


-----------------------------------Предопределенные константы-----------------------------------
__FILE__ - имя файла, в котором в наст моментоящий выполняется код
__LINE__ - строка, которую в данный момент выполняет интерпретатор
__FUNCTION__ - имя текущей функции
__CLASS__ - имя текущего класса
PHP_VERSION - версия интерпретатора php
PHP_OS - ОС, под управлением которой, работает пхп


-----------------------------------Альтернативный синтаксис--------------------------------------
if-else in html markup:
	<?php if(...):?>
		...html...
	<?php else:?>
		...html...
	<?php endif ?>

while in html:
	<?php while(...): ?>
		...
	<?php endwhile ?>

for in html:
	<?php for(...): ?>
		...
	<?php endfor ?>

----------------------------------------Оператор goto----------------------------------------------
goto метка;
...
метка:
Нельзя переместиться в другой файл, в цикл или свич, в функцию или из функции.




----------------------------------------Сериализация------------------------------------------------
Реализуется функциями serialize(mixed $obj) и unserialize($serialized_str) - преобразование объекта в последовательность данных





============================================ООП=====================================================
var_dump(obj) - посмотреть объект
$opd instanceof $type - если операнд opd принадлежит типу type, то оператор вернет true, иначе false

Существует ряд специальных функций, для перегрузки их в объектах. Они начинаются с двух символов подчеркивания.
__toString() - преобразование свойств объекта в строку
__construct(...) - конструктор

При создании классов принято придерживаться рекомендации "один файл = один класс"

---Стандартные методы с возможностью переопределения
__construct() - вызывается при создании обЪекта
__destruct() - вызывается при потере последней ссылки на объект
__toString() - вызывается при попытке преобразования объекта в строку
__clone() - побитовое клонирование объекта. Вызывается при применении оператора clone.
	$clone = clone $original;
Если объявить метод __clone() приватным, то такой объект нельзя будет склонировать.
__sleep() - вызывается автоматически при сериализации. Метод должен возвращать список имен свойств, которые подлежат сериализации. Остальные будут проигнорированы и не восстановятся во время десериализации.
__wakeup() - вызывается автоматически после десериализации объекта. Может использоваться для инициализации динамических свойств объекта, вроде открытых файлом, подключений к БД и т.д.

Сериализация корректно обрабатывает и вложенные объекты
Важно чтобы при десериализации объекта, было доступно определение класса. Иначе объект-контейнер, в который производилась десериализация будет хранить только восстановленные свойства, но не методы.

patent:: - обращение к методам или свойствам родительского класса

$this-> - ссылка на свойства внутри контекста класса
self:: - то же что и this, только для static свойств

При переопределении метода или свойства, нужно указать у него такой же модификатор доступа (private, public и т.д.) или менее строгий, чем в родительском классе

final function f(){...} - таким образом метод f() нельзя будет переопределить в дочерних классах
final class Class{...} - теперь класс Class нельзя будет расширить.

Константы:
	__CLASS__ - имя текущего класса. Не содержит контекст
	__METHOD__ - имя текущего метода (или функции)

Статические метод - функция, которая вызывается из области видимости класса(Класс::метод()) и не имеет доступа к обычным свойствам класса (т.к. они определяются в объектах) но имеет доступ к статическим свойствам, изменения которых получат все объекты данного класса

---Позднее статическое связывание---
Если статический метод в базовом классе использует слово self::, то при вызове его в области видимости дочернего класса, он будет все равно указывать на контекст родительского. Чтобы использовался контекст той области видиости, из которой вызывается статический метод, нужно вместо
	self:: использовать static::


---Анонимные классы---
Тот же принцип, что и в анонимных функциях
Например:
	print_r(new class{
		...
	})

---Абстрагирование---
Класс, который является лишь прототипом реализации для своих птомков, называется абстрактным
Метод, служащий тем же целям, называется абстрактным методом
Функция, которая переопределяется в производном классе, называется "виртуальной"

Абстрактный метод невозможно вызвать, если таковой не был переопределен в производном классе.
Нельзя создать объект абстрактного класса
Если класс содержит хотябы один абстрактный метод, то такой класс является абстрактным

abstract class Page{...} - объявить абстрактный класс
abstract function f(){...} - создание абстрактного метода

Правило совместимости типов
	Объекты производных классов допустимо использовать в том же контексте что и базовых. Но не наоборот

$obj instanceof Class - возвращает true/false если объект $obj соответствует классу Class или его потомку


------------------------------------Интерфейсы и трейты----------------------------------
Интерфейс - это абстрактный класс, который не имеет свойств (можно только константы) и методы которого не имеют тел. Определены только их называния, модификаторы доступа и перечислены параметры

interface Seo{...} - определение интерфейса
class News implements Seo - класс, реализующий интерфейс

Проверить, реализует ли класс интерфейс можно при помощи оператора instanceof
Интерфейсы могут наследовать друг друга так же, как и обычные классы
Только в абстрактном классе можно реализовать не все методы интерфейса


-------------------------------------Трейты-----------------------------------------------
В отличии от интерфейса, трейт содержит не абстрактные методы, а завершенные куски кода, которые можно интегрировать в класс
trait Seo{...} - объявление трейта
class Page{
	use Seo;
	...
} - объявление класса, который использует трейт

Трейты перегружают методы базового класса
Методы текущего класса перегружают методы трейта


Если в трейтах етсть одноименные методы, то будет конфликт имен. Для разрешения конфликта, следует воспользоваться фигурными скобками, после use и оператором insteadof. Можно так же использовать оператор as для задания псевдонима конкретному методу

class News{
	use Author, Tag
	{
		Author::tags insteadof Tag; //использовать метод tags() из трейта Author
		Author::tags as nodes; //теперь метод tags() можно обращаться еще как nodes()
		Tag::authors insteadof Author;
	}
}


------------------------------Пространство имен------------------------------------------
Как файлы изолированы друг от друга в каталогах, так и методы, классы и константы изолированы в пространствах имен
Объявление пространства имен
	namespace NS;
	***code***
Оператор namespace должен располагаться в файле первым.
После, все классы и классовые структуры (абстрактные классы, интерфейсы, трейты), функции и константы, в текущем файле, будут принадлежать пространству имен NS

Создание объекта класса Page пространства имен NS:
	$o = new NS\Page('title', 'content');
Вызов функции
	NS\debug();

Чтобы обратиться к элементам пространства имен, нужно подключить файл, в котором они описаны.
В файлах, где объявлено пространство имен, для обращения к стандартным функциям, перед ними указывает обратный слеш
	\strlen() //обратный слеш указывает на глобальное простнанство имен
В файле, где объявлено пространство имен, можно использовать слово "namespace" для ссылки на него (текущее пространство имен)

---Импортирование---
Для сокращения длины имен можно давать им псевдонимы с помощью use и as, как для элементов, так и для самих пространств имен
	NS\Page\functions\render as render;
	Ns\Page\functions as functions;
Если последний элемент иерархии импортируемого пространства имен совпадает с псевдонимом, то as можно опустить
	use NS\Page\functions\render; //теперь можно вызывать как render()
	use NS\Page\functions; //теперь можно создавать обекты new functions

---Автозагрузка классов---
__autoload($classname){...} - функция, принимающая один аргумент - имя класса. Внутри должна быть реализация загрузки файла (require_once, include и т.п.) с определением класса, зависимо от его имени. Введу ограниченных возможностей, данная функция используется редко

spl_autoload_register(callablef, $throw = true, $prepend = false) - позволяет зарегестрировать цепочку их функций автозагрузки. Не найдя класс при помощи первой функции, поиск продолжится со следующей и т.д. Либо завершится нахождением класса с помощью какой-то из функция, либо с ошибкой.
	clallablef - имя функции автозагрузки
	$throw - true, если функция должна генерировать исключение при ненахождении класса.
	$prepend - true, если нужно добавлять каждую новую функцию вначало цепочки


--------------------------------------Ошибки и обработка исключений-----------------------------------
---Директивы контроля ошибок---
error_reporting - регулирует уровень "строгости" системы контроля ошибок PHP.
	Значения: числовая константа (по-умолчанию E_All~E_NOTICE). Здесь "~" это побитовое XOR
	Где устанавливается: php.ini, .htaccess, ini_set(), error_reporting()

display_errors, log_errors - если display_errors установлен в on, то все сообщения об ошибках и предупреждения выводятся в браузер. Если установлен дополнительно log_errors, то вся эта информация попадает еще и в файл журнала.
	Возможные значения: on, off
	Где устанавливается: php.ini, .htaccess, ini_set().

error_log - задает путь к файлу журнала
	Возможные значения: Абсолютный путь к файлу
	Где устанавливается: php.ini, .htaccess, ini_set()


---Обработка ошибок---
set_error_handler(string $funcName, [int $errorTypes]) - регистрирует пользовательскую функци-обработчик ошибок $funcName, которая будет вызываться при возникновении сообщений, указанных в $errorTypes типов

Только в случае, когда пользовательский обработчик возвращает false, считается что ошибка не была обработана и управление передается стандартному обработчику ошибок

restore_error_handler() - после смены обработчика ошибок с помощью set_error_handler(), эта функция восстановит предыдущий обработчик
trigger_error(string $error_msg, [int $error_type = E_USER_NOTICE]) - функция генерирует ошибки пользовательского уровня (E_USER_ERROR, E_USER_WARNING, E_USER_NOTICE)
error_log($msgm [, $type=0, $dest, $extra_headers]) - похожа на trigger_error(), но направляе запись текста ошибок ($msg) в файл журнала, заданный в директиве error_log. Подробнее см. документацию

debug_backtrace() - возвращает стек вызовов, от главной программы, заканчивая текущей функцией

---Обработка исключений---
Код, обрабатывающий исключения, явно отделяется от основного кода. Исключение нужно обработать в тот момент, когда наиболее всего известно, как это сделать

Генерация исключения:
try{
	...
	throw new Exception('message'); //Создаем исключение
}
catch(Exception $e){
	обработка исключения
}

Инструкция throw, аналогично return, немедленно завершает выполнение try блока, не зависимо от уровня вложенности, на котором было сгенерировано исключение

---Исключения типа Error---
Специальный тип исключений. Появился в php7. Не наследуется от Exception.
И Exception, и Error реализуют общий интерфейс Throwable.
Исключения, наследующие Error:
	ArithmeticError - генерируется при арифметических операциях
	AssertionError - исключение для функции assert()
	DivisionByZeroError - деление на ноль. Не отлавливается при помощи catch
	ParseError - возникает при ошибке разбора php кода
	TypeError - при ошибках использования типа
Блок-финализатор finally{} - выполнится в любом случае

Использованием throw внутри catch-блока, можно "пробрасывать" исключение дальше



======================================Предопределенные классы PHP==============================================

------------------------------Directory----------------------------------------
Предопределенный класс, позволяющий получить доступ к каталогу, заменяя набор функций opendir(), rewinddir(), readdir(), closedir()
* Объект данного класса создается при помощи специальной функции dir():
Directory dir(string $directory, [, resource $context]) -  путь к каталогу записывается в параметр $directory. $context используется при сетевых операциях. В случае неудачного создания объекта возвращиется NULL
Содержит два открытых параметра:
	path - путь к открытому каталогу;
	handle - дескриптор открытого каталога, который может быть использован другими функциями, работающими с каталогами
Предоставляет три метода:
	read() - читает очередной элемент каталога, передвигая указатель на одну позицию.;
	rewind() - сбрасывает указатель каталога на исходную позицию
	close() - закрывает каталог
	Эти методы могут принимать необязательный параметр - дескриптор каталога. В таком случае операции будут осуществляться с каталогом, на который указывает дескриптор, а не с каталогом, открытым при инициализации объекта
Поскольку объект Dictionary нельзя получить посредством оператора new, то наследовать этот класс так же нельзя.


------------------------------Generator----------------------------------------
Так же нельзя получить объект класса Generanor с помощью new и так же нельзя наследовать этот класс
Доступные методы:
	current() - возвращает текущее значение. Если в операторе yield указывается ключ, то для его извлечения используется метод key();
	next() - следующая итерация;
	valid() - проверяет закрыт ли генератор. Если итерации закончилист - генератор закрыт и будет возврашен false



------------------------------Closure-------------------------------------------
Замыкание в PHP представляет собой объект класса Closure
Closure Closure::bindTo(object $newthis, [, mixed $newscope = 'static']) - возвращает анонимную функцию, с таким же телом и связанными переменнами, но привязывает ее к замыканию другого объекта $this. $newscope - это тип класса, который определит, к каким закрытым и защищиенным свойствам будет иметь доступ анонимная функция.
	public function addF($anonF){
		$anonF->bindTo($this, __CLASS__) //привязать анонимную функцию, переданную в качестве параметра к классу, методом которого является addF()
	}


------------------------------IntlChar-------------------------------------------
Предназначен для поддержки интернационализации
Содержит только статические методы
Методы:
	public static int IntlChar::ord(mixed $character) - возвращает числовой код для utf-8 символа $character
	public static string IntlChar::chr(mixed $codepoint) - позволяет получить utf-8 символ по числовому коду $codepoint
	public static mixed IntlChar::toupper(mixed $codepoint) - для utf-8 символа, возвращает его прописной эквивалент
	public static mixed IntlChar::tolower(mixed $codepoint) - для utf-8 символа, возвращает его строчный эквивалент
	public static bool IntlChar::isalnum(mixed $codepoint) - возвращает true, если $codepoint принадлежит классу цифр, иначе false
	public static bool IntlChar::isalpha(mixed $codepoint)
	public static bool IntlChar::isspace(mixed $codepoint) - пробельный ли символ
	public static bool IntlChar::iscntrl(mixed $codepoint) - управляющий ли символ
	public static bool IntlChar::ispunct(mixed $codepoint) - пунктуации ли символ
	public static bool IntlChar::islower(mixed $codepoint) - строчный ли
	public static bool IntlChar::isupper(mixed $codepoint) - прописной ли
	public static bool IntlChar::isprint(mixed $codepoint) - печатный ли символ


-------------------------------DateTime--------------------------------------------
Предоставляет средства для работы с датой и временем
$date = new DateTime("2016-01-01 00:00:00") - создать объект с заданной датой
$date->format(string $format) - вывести заданную или текущую дату в формате $format
Данный класс имеет в себе константы, определяющие различные форматы вывода даты и времени


------------------------------DateTimeZone-----------------------------------------
Позволяет задавать часовые пояса для DateTime-объектов


------------------------------DateInterval-----------------------------------------
Объекты класса DateTime можно вычитать друг из друга при помощи метода diff(), который возвращает объект класса DateInterval
Можно так же вычитать и добавлять временные интервалы, соответственно, при помощи методов add() и sub()


-------------------------------DatePeriod------------------------------------------
Позволяет создать итератор обхода последовательности дат (в виде DateTime-объектов), следующих друг за другом через определенный интервал времени.
Обхд осуществляется при помощи foreach


-----------------------------DirectoryIterator--------------------------------------
Реализует интерфейс Iterator, предоставляет доступ к содержимому каталога и получении информации о файлах.


-------------------------------FilterIterator----------------------------------------
Элементы коллекции (содержимого каталога), могут быть отфильтрованы при помощи итератора, производного от класса FilterIterator.


-------------------------------LimitIterator------------------------------------------
Данный класс и производные от него позволяют осуществлять постраничный вывод




======================================Отражения=================================================
Позволяет выяснять статус и состав отдельных методов, классов, свойств и расширений php.
Позволяют автоматически генерировать документацию иерархии классов.


------------------------------неявный вызов методов------------------------------------
С помощью функции call_user_func():
	call_user_func(array(&$obj, "methodName") [, parameters...])
	Если метод статический, то вместо obj, нужно передать строковое имя класса



-----------------------------Инстанцирование объектов-----------------------------------
Инстанцировать класс - значит создать его экземпляр (объект)
	$className = "Name";
	$obj = new $className(6, 1);


--------------------------------Аппарат отражений----------------------------------------
Встроенный в язык класс, объект которого хранит информацию о структуре самой программы.

ReflectionFunction
	Объект этого класса хранит имя функции, место ее определения в программе, данные о количестве и типе аргументов
	Список методов данного отражения (PHP7 в подленнике, стр. 573)

ReflectionClass
	Аналогично ReflectionFunction

ReflectionParameter
	Хранит информацию об одном отдельно взятом аргументе

Все классы-отражения реализуют интерфейс Reflector




======================================Работа с сетью=================================================
int header(string $string) - предназначина для установки заголовков ответа. Обычно является в самом начале скрипта
bool headers_sent([string &$file] [, int &$line]) - true, если уже были отправлены все заголовки ответа в браузер. Иначе вернет false. В $file и $string будет записано имя файла и номер строки, где впервые был осуществлен какой-либо вывод.

list headers_list() - возвращает все заголовки, отправленные скриптом прежде.
array getallheaders() - возвращает ассоциативный массив заголовков запроса клиента, спровоцировавшего запуск сценария.


---------------------------------Разбор URL------------------------------------------
void parse_str(string $str [, array $out]) - разбирает QUERY_STRING из параметра $str и записывает результат в ассоциативный массив $out.
string http_build_query(parameters) - собирает QUERY_STRING по переданным ей параметрам






======================================Паттерны проектирования==========================================
MVC - Model, View, Controller
	Model - отвечает за управление данными (запись и извлечение)
	View - отвечает за визуальное представление данных пользователю
	Controller - отвечает за обработку запросов пользователя и связывает работу Модели и Вида

Front controller - один скрипт (роутер) на весь сайт. Получает запросы от пользователя и определяет какой скрипт включить в работу.

На сайте может работать много паттернов. Например MVC для раздела "новости", MVC для раздела "товары" и т.д.
Front controller + MVC - Front controller (роутер) принимает запрос от пользователя, обрабатывает и, в соответствии с ним, передает управление той или иной модели MVC

Front controller выполняет:
	1) Общие настройки
	2) Подключение файлов системы
	3) Установка соединения с БД
	4) Класс Router
		1) Анализ запроса, определение контроллера
		2) Подключение контроллера
		3) Передача управления контроллеру
		Роутер определяет, какой именно файл нужно вызвать по специальным правилам, которые содержатся в отдельном файле Routes. В нем каждой строке запроса соответствует путь а эешен-методу. 